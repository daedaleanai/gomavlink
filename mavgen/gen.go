package main

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

var tmpl = template.Must(template.New("").Funcs(template.FuncMap{
	"lower":             strings.ToLower,
	"upper":             strings.ToUpper,
	"title":             strings.Title,
	"underscoreToCamel": underscoreToCamel,
	"gotype":            goType,
	"goscalartype":      goScalarType,
	"goarraysize":       goArraySize,
	"notabs":            notabs,
}).Parse(`// Generated enums and structures for Mavlink dialect {{.Name}} #{{.Dialect}} version {{.Version}}
package {{.Name}}

// Generated by gomavlink, DO NOT EDIT.

{{if .Messages}}
import (
	"math"

	mavlink "github.com/daedaleanai/gomavlink"
)
{{- end}}

{{- if .Enums}}
//go:generate stringer -output strings.go -type={{range $k,$v := .Enums}}{{if $k}},{{end}}{{underscoreToCamel $v.Name}}{{end}}
{{- end}}

{{range .Enums}}
{{- $tpe := underscoreToCamel .Name}}
{{if .Description}}/* {{notabs .Description}} */{{end}}
type {{$tpe}} uint32 
const (
{{- range .Entries}}
	{{if .Description}}/* {{notabs .Description}} */{{end}}
	{{upper .Name}} {{$tpe}} = {{.Value}} 
{{end -}}
){{end}}

{{if .Messages}}
func Dialect(mid int) mavlink.Message {
	switch mid {
{{- range .Messages}}
	case {{.ID}}: return &{{underscoreToCamel .Name}}{}
{{- end}}
	}
	return nil
}
{{end}}

{{range .Messages}}
{{- $tpe := underscoreToCamel .Name}}
{{if .Description}}/* {{notabs .Description}} */{{end}}
type {{$tpe}} struct {
{{- range .Fields}}
	/* {{notabs .Description}} */
	{{underscoreToCamel .Name}}  {{if .Enum}}{{underscoreToCamel .Enum}} // {{end}}{{gotype .CType}}{{if .IsExtension}} /*EXTENSION*/{{end}}
{{end}}
}

func (m *{{$tpe}}) ID() int { return {{.ID}} }
func (m *{{$tpe}}) CRCExtra() byte { return {{.CRCExtra}} }

func (m *{{$tpe}}) MarshalV1(buf []byte) []byte {
{{- range .BaseFields}}
{{- if goarraysize .CType -}}
	for _, v := range m.{{underscoreToCamel .Name}} {
		buf = marshal{{goscalartype .CType|title}}(buf, {{if .Enum}}{{goscalartype .CType}}{{end}}(v))
	}
{{- else -}}
	buf = marshal{{goscalartype .CType|title}}(buf, {{if .Enum}}{{gotype .CType}}{{end}}(m.{{underscoreToCamel .Name}}))
{{- end}}
{{end}}
	return buf
}

func (m *{{$tpe}}) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
{{range .ExtFields}}
{{- if goarraysize .CType -}}
	for _, v := range m.{{underscoreToCamel .Name}} {
		buf = marshal{{goscalartype .CType|title}}(buf, {{if .Enum}}{{goscalartype .CType}}{{end}}(v))
	}
{{- else -}}
	buf = marshal{{goscalartype .CType|title}}(buf, {{if .Enum}}{{gotype .CType}}{{end}}(m.{{underscoreToCamel .Name}}))
{{- end}}
{{end}}
	return buf
}

func (m *{{$tpe}}) UnmarshalV1(buf []byte) []byte {
{{- range .BaseFields}}
{{- if goarraysize .CType -}}
	for i, _ := range m.{{underscoreToCamel .Name}} {
	{{if .Enum -}}
		{
			var v {{goscalartype .CType}}
			buf, v = unmarshal{{goscalartype .CType|title}}(buf)
			m.{{underscoreToCamel .Name}}[i] = {{underscoreToCamel .Enum}}(v)
		}
	{{- else -}}
		buf, m.{{underscoreToCamel .Name}}[i] = unmarshal{{goscalartype .CType|title}}(buf)
	{{- end}}
	}
{{- else -}}
	{{if .Enum -}}
		{
			var v {{goscalartype .CType}}
			buf, v = unmarshal{{goscalartype .CType|title}}(buf)
			m.{{underscoreToCamel .Name}} = {{underscoreToCamel .Enum}}(v)
		}
	{{- else -}}
		buf, m.{{underscoreToCamel .Name}} = unmarshal{{goscalartype .CType|title}}(buf)
	{{- end}}
{{- end}}
{{end}}
	return buf
}

func (m *{{$tpe}}) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
{{range .ExtFields}}
{{- if goarraysize .CType -}}
	for i, _ := range m.{{underscoreToCamel .Name}} {
	{{if .Enum -}}
		{
			var v {{goscalartype .CType}}
			buf, v = unmarshal{{goscalartype .CType|title}}(buf)
			m.{{underscoreToCamel .Name}}[i] = {{underscoreToCamel .Enum}}(v)
		}
	{{- else -}}
		buf, m.{{underscoreToCamel .Name}}[i] = unmarshal{{goscalartype .CType|title}}(buf)
	{{- end}}
	}
{{- else -}}
	{{if .Enum -}}
		{
			var v {{goscalartype .CType}}
			buf, v = unmarshal{{goscalartype .CType|title}}(buf)
			m.{{underscoreToCamel .Name}} = {{underscoreToCamel .Enum}}(v)
		}
	{{- else -}}
		buf, m.{{underscoreToCamel .Name}} = unmarshal{{goscalartype .CType|title}}(buf)
	{{- end}}
{{- end}}
{{end}}

	return buf
}
{{end}}


{{if.Messages}}// These will be inlined.
func marshalByte(b []byte, v byte) []byte { return append(b, v) }
func marshalInt8(b []byte, v int8) []byte { return append(b, byte(v)) }
func marshalInt16(b []byte, v int16) []byte { return append(b, byte(v), byte(v>>8)) }
func marshalUint16(b []byte, v uint16) []byte { return append(b, byte(v), byte(v>>8)) }
func marshalInt32(b []byte, v int32) []byte { return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24)) }
func marshalUint32(b []byte, v uint32) []byte { return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24)) }
func marshalInt64(b []byte, v int64) []byte { return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24), byte(v>>32), byte(v>>40), byte(v>>48), byte(v>>56)) }
func marshalUint64(b []byte, v uint64) []byte { return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24), byte(v>>32), byte(v>>40), byte(v>>48), byte(v>>56)) }
func marshalFloat32(b []byte, v float32) []byte { return marshalUint32(b, math.Float32bits(v)) }
func marshalFloat64(b []byte, v float64) []byte { return marshalUint64(b, math.Float64bits(v)) }

func unmarshalByte(b []byte) ([]byte, byte) { return b[1:], b[0] }
func unmarshalInt8(b []byte) ([]byte, int8) { return b[1:], int8(b[0]) }
func unmarshalInt16(b []byte) ([]byte, int16) { return b[2:], int16(b[0]) | int16(b[1])<<8 }
func unmarshalUint16(b []byte) ([]byte, uint16) { return b[2:], uint16(b[0]) | uint16(b[1])<<8 }
func unmarshalInt32(b []byte) ([]byte, int32) { return b[4:], int32(b[0]) | int32(b[1])<<8 | int32(b[2])<<16 | int32(b[3])<<24}
func unmarshalUint32(b []byte) ([]byte, uint32) { return b[4:], uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24}
func unmarshalInt64(b []byte) ([]byte, int64) { return b[8:], int64(b[0]) | int64(b[1])<<8 | int64(b[2])<<16 | int64(b[3])<<24 | int64(b[4])<<32 | int64(b[5])<<40 | int64(b[6])<<48 | int64(b[7])<<56 }
func unmarshalUint64(b []byte) ([]byte, uint64) { return b[8:], uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 }
func unmarshalFloat32(b []byte) ([]byte, float32) { 
	b, v := unmarshalUint32(b)
	return b, math.Float32frombits(v)
}
func unmarshalFloat64(b []byte) ([]byte, float64) { 
	b, v := unmarshalUint64(b)
	return b, math.Float64frombits(v)
}

{{end}}

`))

func underscoreToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i, v := range parts {
		parts[i] = strings.Title(strings.ToLower(v))
	}
	return strings.Join(parts, "")
}

var wstospace = strings.NewReplacer("\t", " ", "\n", " ")

func notabs(s string) string { return wstospace.Replace(s) }

var reCType = regexp.MustCompile(`([a-z0-9_]+)(\[[0-9]+\])?`)

func goType(ctype string) (string, error) {
	parts := reCType.FindStringSubmatch(ctype)
	if len(parts) != 3 {
		return "", fmt.Errorf("Cannot parse %q as ctype([arraylen])", ctype)
	}
	var t string
	switch parts[1] {
	case "float":
		t = "float32"
	case "double":
		t = "float64"
	case "int8_t":
		t = "int8"
	case "char", "uint8_t", "uint8_t_mavlink_version", "array":
		t = "byte"
	case "int16_t":
		t = "int16"
	case "uint16_t":
		t = "uint16"
	case "int32_t":
		t = "int32"
	case "uint32_t":
		t = "uint32"
	case "int64_t":
		t = "int64"
	case "uint64_t":
		t = "uint64"
	default:
		return "", fmt.Errorf("Cannot parse %q as a ctype (invalid scalar part %q)", ctype, parts[1])
	}
	if parts[2] == "" {
		return t, nil
	}
	return fmt.Sprintf("%s%s", parts[2], t), nil
}

func scalarSize(ctype string) int {
	parts := reCType.FindStringSubmatch(ctype)
	if len(parts) != 3 {
		return 0
	}
	switch parts[1] {
	case "int8_t", "char", "uint8_t", "uint8_t_mavlink_version", "array":
		return 1
	case "int16_t", "uint16_t":
		return 2
	case "float", "int32_t", "uint32_t":
		return 4
	case "double", "int64_t", "uint64_t":
		return 8
	}
	return 0
}

func goScalarType(ctype string) (string, error) {
	parts := reCType.FindStringSubmatch(ctype)
	if len(parts) != 3 {
		return "", fmt.Errorf("Cannot parse %q as ctype([arraylen])", ctype)
	}
	var t string
	switch parts[1] {
	case "float":
		t = "float32"
	case "double":
		t = "float64"
	case "int8_t":
		t = "int8"
	case "char", "uint8_t", "uint8_t_mavlink_version", "array":
		t = "byte"
	case "int16_t":
		t = "int16"
	case "uint16_t":
		t = "uint16"
	case "int32_t":
		t = "int32"
	case "uint32_t":
		t = "uint32"
	case "int64_t":
		t = "int64"
	case "uint64_t":
		t = "uint64"
	default:
		return "", fmt.Errorf("Cannot parse %q as a ctype (invalid scalar part %q)", ctype, parts[1])
	}
	return t, nil
}

func goArraySize(ctype string) (int, error) {
	parts := reCType.FindStringSubmatch(ctype)
	if len(parts) != 3 {
		return 0, fmt.Errorf("Cannot parse %q as ctype([arraylen])", ctype)
	}
	if parts[2] == "" {
		return 0, nil
	}
	n, err := strconv.ParseUint(parts[2][1:len(parts[2])-1], 10, 8)
	if err != nil {
		return 0, err
	}
	return int(n), nil
}
