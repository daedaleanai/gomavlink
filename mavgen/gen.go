package main

import (
	"fmt"
	"regexp"
	"strings"
	"text/template"
)

var tmpl = template.Must(template.New("").Funcs(template.FuncMap{
	"lower":             strings.ToLower,
	"upper":             strings.ToUpper,
	"title":             strings.Title,
	"underscoreToCamel": underscoreToCamel,
	"gotype":            goType,
}).Parse(`// Generated enums and structures for Mavlink dialect {{.Name}} #{{.Dialect}} version {{.Version}}
package {{.Name}}

// Generated by gomavlink, DO NOT EDIT.
{{- if .Enums}}
//go:generate stringer -output strings.go -type={{range $k,$v := .Enums}}{{if $k}},{{end}}{{underscoreToCamel $v.Name}}{{end}}
{{- end}}

{{range .Enums}}
{{- $tpe := underscoreToCamel .Name}}
{{if .Description}}/* {{.Description}} */{{end}}
type {{$tpe}} uint32 
const (
{{- range .Entries}}
	{{if .Description}}/* {{.Description}} */{{end}}
	{{upper .Name}} {{$tpe}} = {{.Value}} 
{{end -}}
){{end}}

{{if .Messages}}type Message interface{
	ID() int
	Encode() []byte
	Decode([]byte) error
}{{end -}}

{{range .Messages}}
{{- $tpe := underscoreToCamel .Name}}
{{if .Description}}/* {{.Description}} */{{end}}
type {{$tpe}} struct {
{{- range .Fields}}
	/* {{.Description}} */
	{{underscoreToCamel .Name}}  {{if .Enum}}{{underscoreToCamel .Enum}} // {{end}}{{gotype .CType}}{{if .IsExtension}} /*EXTENSION*/{{end}}
{{end}}
}

func (m *{{$tpe}}) ID() int { return {{.ID}} }
{{end}}

`))

func underscoreToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i, v := range parts {
		parts[i] = strings.Title(strings.ToLower(v))
	}
	return strings.Join(parts, "")
}

var reCType = regexp.MustCompile(`([a-z0-9_]+)(\[[0-9]+\])?`)

func goType(ctype string) (string, error) {
	parts := reCType.FindStringSubmatch(ctype)
	if len(parts) != 3 {
		return "", fmt.Errorf("Cannot parse %q as ctype([arraylen])", ctype)
	}
	var t string
	switch parts[1] {
	case "float":
		t = "float32"
	case "double":
		t = "float64"
	case "int8_t":
		t = "int8"
	case "char", "uint8_t", "uint8_t_mavlink_version", "array":
		t = "byte"
	case "int16_t":
		t = "int16"
	case "uint16_t":
		t = "uint16"
	case "int32_t":
		t = "int32"
	case "uint32_t":
		t = "uint32"
	case "int64_t":
		t = "int64"
	case "uint64_t":
		t = "uint64"
	default:
		return "", fmt.Errorf("Cannot parse %q as a ctype (invalid scalar part %q)", ctype, parts[1])
	}
	if parts[2] == "" {
		return t, nil
	}
	return fmt.Sprintf("%s%s", parts[2], t), nil
}

func scalarSize(ctype string) int {
	parts := reCType.FindStringSubmatch(ctype)
	if len(parts) != 3 {
		return 0
	}
	switch parts[1] {
	case "int8_t", "char", "uint8_t", "uint8_t_mavlink_version", "array":
		return 1
	case "int16_t", "uint16_t":
		return 2
	case "float", "int32_t", "uint32_t":
		return 4
	case "double", "int64_t", "uint64_t":
		return 8
	}
	return 0
}
