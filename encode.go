package mavlink

import (
	"fmt"
	"io"
)

type Protocol int

const (
	V2       Protocol = iota // 0 is default
	V1                       // 1 : fallback to V1
	V2Signed                 // 2 : sign
)

// Message is the interface implemented by the structs generated by mavgen from the XML dialect definitions.
type Message interface {
	ID() int
	CRCExtra() uint16
	Marshal([]byte) []byte
}

// An Encoder can serialize Messages on a io.Writer
type Encoder struct {
	// w is the io.Writer that Encode serializes to.  Each frame will be written in a single call to w.Write.
	w io.Writer
	// Protocol switches between the formats used when serializing a message.
	// This can be reset freely between calls to Encode.
	Protocol Protocol
	// SeqNr counts the number of messages sent, the lower 8 bits are used to generate the packet sequence number.
	// This can be reset freely between calls to Encode.
	SeqNr uint64
	// The value of CompatFlags will be copied to the 3rd byte of the V2 messages.
	CompatFlags byte
}

func NewEncoder(w io.Writer) *Encoder { return &Encoder{w: w} }

func (e *Encoder) Encode(sysid, compid byte, m Message) error {
	buf := make([]byte, 279)
	switch e.Protocol {
	case V2:
		mid := m.ID()
		buf = append(buf, 0xFD, 0, 0, e.CompatFlags, byte(e.SeqNr), sysid, compid, byte(mid), byte(mid>>8), byte(mid>>16))
	case V2Signed:
		mid := m.ID()
		buf = append(buf, 0xFD, 0, 1, e.CompatFlags, byte(e.SeqNr), sysid, compid, byte(mid), byte(mid>>8), byte(mid>>16))
	case V1:
		if m.ID() > 255 {
			return fmt.Errorf("Cannot encode %T as V1 frame, message id %d too large.", m, m.ID())
		}
		buf = append(buf, 0xFE, 0, byte(e.SeqNr), sysid, compid, byte(m.ID()))
	}

	return nil
}
