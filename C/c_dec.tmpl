{{$pkg := lower .Name -}}
// Generated enums and structures for Mavlink dialect {{$pkg}} #{{.Dialect}} version {{.Version}}
// Generated by gomavlink, DO NOT EDIT.

#include <string.h>
#include <assert.h>

#include "{{$pkg}}.h"

// defined in {{$pkg}}_crc.h
uint8_t {{$pkg}}_crcextra(enum {{upper $pkg}}_MESSAGE mid);

inline static uint8_t 	read_byte(const uint8_t **p) { return *(*p)++; }
inline static int8_t 	read_int8(const uint8_t **p) { return *(*p)++; }
inline static int16_t 	read_int16(const uint8_t **p)  { int16_t  r = *(*p)++; r |= *(*p)++ << 8; return r; }
inline static uint16_t 	read_uint16(const uint8_t **p) { uint16_t r = *(*p)++; r |= *(*p)++ << 8; return r; }
inline static int32_t 	read_int32(const uint8_t **p)  { int32_t   r = *(*p)++; r |= *(*p)++ << 8; r |= *(*p)++ << 16; r |= *(*p)++ << 24; return r; }
inline static uint32_t 	read_uint32(const uint8_t **p) { uint32_t  r = *(*p)++; r |= *(*p)++ << 8; r |= *(*p)++ << 16; r |= *(*p)++ << 24; return r; }
inline static int64_t 	read_int64(const uint8_t **p)  { int64_t  r = read_uint32(p); r |= ((int64_t)read_int32(p)) << 32; return r; }
inline static uint64_t 	read_uint64(const uint8_t **p) { uint64_t r = read_uint32(p); r |= ((uint64_t)read_uint32(p)) << 32; return r; }

inline static float 	read_float32(const uint8_t **p) { uint32_t v = read_uint32(p); return *(float*)&v; }
inline static double 	read_float64(const uint8_t **p) { uint64_t v = read_uint64(p); return *(double*)&v; }

inline static uint16_t x25(uint16_t crc, uint8_t v) {
	v ^= crc;
    v ^= v<<4;
    return (crc>>8) ^ (v<<8) ^ (v<<3) ^ (v>>4);  // (uint8_t << int) is promoted to int (!!)
}


static void read_payload_base(const uint8_t **p, struct {{$pkg}}_message *msg) {
	switch (msg->msg_id) {
{{range .Messages}}
	case {{upper $pkg}}_MESSAGE_{{upper .Name}}:{{$str := lower .Name}}
	{{range .BaseFields}}
	    {{- if goarraysize .CType}}
		    for (size_t i = 0; i<{{goarraysize .CType}}; i++)
   				 msg->{{$str}}.{{.Name}}[i] = read_{{goscalartype .CType}}(p);
	    {{- else -}}
			msg->{{$str}}.{{.Name}} = read_{{goscalartype .CType}}(p);
		{{- end}}
	{{- end}}
		break;
{{end}}
	};
}

static void read_payload_ext(const uint8_t **p, struct {{$pkg}}_message *msg) {
	switch (msg->msg_id) {
{{range .Messages}}{{if $f := .ExtFields}}
	case {{upper $pkg}}_MESSAGE_{{upper .Name}}:{{$str := lower .Name}}
	{{- range $f}}
	    {{- if goarraysize .CType}}
		    for (size_t i = 0; i<{{goarraysize .CType}}; i++)
   				 msg->{{$str}}.{{.Name}}[i] = read_{{goscalartype .CType}}(p);
	    {{- else -}}
			msg->{{$str}}.{{.Name}} = read_{{goscalartype .CType}}(p);
		{{- end}}
	{{- end}}
		break;
{{end}}{{end}}
	default: ;// nix
	};
}

size_t {{$pkg}}_message_deserialize(const uint8_t* buf, size_t size, struct {{$pkg}}_message *msg) {
	if (size < 3) {
		return 0;
	}
	switch(buf[0]) {
	case 0xFE: 
		if (size < 8 + buf[1]){
			return 0;
		}
		break;
	case 0xFD: 
		if (size < 11 + buf[1] + ((buf[2]&0x1) ? 13 : 0)){
			return 0;
		}
		break;
	default: 
		return 0;
	}

	const uint8_t* p = buf + 1;

	msg->len = *p++;

	if(buf[0] == 0xFD) {
		p += 2; // skip incompat + compat flags
	}

	msg->seq_dropped = *p++ - 1 - (uint8_t)(msg->seq_nr); // add difference in least significant byte
	msg->seq_nr += 1 + msg->seq_dropped;

	msg->sys_id  = *p++;
	msg->comp_id = *p++;
	msg->msg_id  = *p++;
	if(buf[0] == 0xFD) {
		msg->msg_id |= (uint32_t)(*p++) << 8;
		msg->msg_id |= (uint32_t)(*p++) << 16;
	}

	uint8_t tmp[256];
	memset(tmp, 0, sizeof tmp);
	memmove(tmp, p, msg->len);
	p += msg->len;

	uint16_t crc = 0xffff;
	for (const uint8_t* pp = buf + 1; pp < p; ++pp) {
		crc = x25(crc, *pp);
	}
	crc = x25(crc, {{$pkg}}_crcextra(msg->msg_id));

	crc ^= *p++;
	crc ^= *p++ << 8;
	msg->crc = crc;  // should be zero now

	const uint8_t* q = tmp;
	read_payload_base(&q, msg);
	if(buf[0] == 0xFD) {
		read_payload_ext(&q, msg);
	}
	assert(q - tmp < sizeof tmp);

	msg->link_id = 0;
	if ((buf[0] == 0xFD) && (buf[2]&0x1)) {
		msg->link_id = *p++;
		msg->timestamp = read_uint16(&p);
		msg->timestamp |= read_uint32(&p) << 16;
		msg->signature = read_uint16(&p);
		msg->signature |= read_uint32(&p) << 16;
	}

	return p - buf;
}


size_t {{$pkg}}_message_seek(const uint8_t* buf, size_t size) {
	for (size_t r = 0; r < size; r++) {
		switch (buf[r]) {
		case 0xFD:
		case 0xFE: 
			return r;
		}
	}
	return size;
}



