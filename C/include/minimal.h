#pragma once

// Generated enums and structures for Mavlink dialect minimal #0 version 3
// Generated by gomavlink, DO NOT EDIT.

#include <stddef.h>
#include <stdint.h>

/* Micro air vehicle / autopilot classes. This identifies the individual model.
 */
enum MAV_AUTOPILOT {
  /* Generic autopilot, full support for everything */
  MAV_AUTOPILOT_GENERIC = 0,
  /* Reserved for future use. */
  MAV_AUTOPILOT_RESERVED = 1,
  /* SLUGS autopilot, http://slugsuav.soe.ucsc.edu */
  MAV_AUTOPILOT_SLUGS = 2,
  /* ArduPilot - Plane/Copter/Rover/Sub/Tracker, http://ardupilot.org */
  MAV_AUTOPILOT_ARDUPILOTMEGA = 3,
  /* OpenPilot, http://openpilot.org */
  MAV_AUTOPILOT_OPENPILOT = 4,
  /* Generic autopilot only supporting simple waypoints */
  MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY = 5,
  /* Generic autopilot supporting waypoints and other simple navigation commands
   */
  MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6,
  /* Generic autopilot supporting the full mission command set */
  MAV_AUTOPILOT_GENERIC_MISSION_FULL = 7,
  /* No valid autopilot, e.g. a GCS or other MAVLink component */
  MAV_AUTOPILOT_INVALID = 8,
  /* PPZ UAV - http://nongnu.org/paparazzi */
  MAV_AUTOPILOT_PPZ = 9,
  /* UAV Dev Board */
  MAV_AUTOPILOT_UDB = 10,
  /* FlexiPilot */
  MAV_AUTOPILOT_FP = 11,
  /* PX4 Autopilot - http://px4.io/ */
  MAV_AUTOPILOT_PX4 = 12,
  /* SMACCMPilot - http://smaccmpilot.org */
  MAV_AUTOPILOT_SMACCMPILOT = 13,
  /* AutoQuad -- http://autoquad.org */
  MAV_AUTOPILOT_AUTOQUAD = 14,
  /* Armazila -- http://armazila.com */
  MAV_AUTOPILOT_ARMAZILA = 15,
  /* Aerob -- http://aerob.ru */
  MAV_AUTOPILOT_AEROB = 16,
  /* ASLUAV autopilot -- http://www.asl.ethz.ch */
  MAV_AUTOPILOT_ASLUAV = 17,
  /* SmartAP Autopilot - http://sky-drones.com */
  MAV_AUTOPILOT_SMARTAP = 18,
  /* AirRails - http://uaventure.com */
  MAV_AUTOPILOT_AIRRAILS = 19
};

/* MAVLINK system type. All components in a system should report this type in
 * their HEARTBEAT. */
enum MAV_TYPE {
  /* Generic micro air vehicle. */
  MAV_TYPE_GENERIC = 0,
  /* Fixed wing aircraft. */
  MAV_TYPE_FIXED_WING = 1,
  /* Quadrotor */
  MAV_TYPE_QUADROTOR = 2,
  /* Coaxial helicopter */
  MAV_TYPE_COAXIAL = 3,
  /* Normal helicopter with tail rotor. */
  MAV_TYPE_HELICOPTER = 4,
  /* Ground installation */
  MAV_TYPE_ANTENNA_TRACKER = 5,
  /* Operator control unit / ground control station */
  MAV_TYPE_GCS = 6,
  /* Airship, controlled */
  MAV_TYPE_AIRSHIP = 7,
  /* Free balloon, uncontrolled */
  MAV_TYPE_FREE_BALLOON = 8,
  /* Rocket */
  MAV_TYPE_ROCKET = 9,
  /* Ground rover */
  MAV_TYPE_GROUND_ROVER = 10,
  /* Surface vessel, boat, ship */
  MAV_TYPE_SURFACE_BOAT = 11,
  /* Submarine */
  MAV_TYPE_SUBMARINE = 12,
  /* Hexarotor */
  MAV_TYPE_HEXAROTOR = 13,
  /* Octorotor */
  MAV_TYPE_OCTOROTOR = 14,
  /* Tricopter */
  MAV_TYPE_TRICOPTER = 15,
  /* Flapping wing */
  MAV_TYPE_FLAPPING_WING = 16,
  /* Kite */
  MAV_TYPE_KITE = 17,
  /* Onboard companion controller */
  MAV_TYPE_ONBOARD_CONTROLLER = 18,
  /* Two-rotor VTOL using control surfaces in vertical operation in addition.
     Tailsitter. */
  MAV_TYPE_VTOL_DUOROTOR = 19,
  /* Quad-rotor VTOL using a V-shaped quad config in vertical operation.
     Tailsitter. */
  MAV_TYPE_VTOL_QUADROTOR = 20,
  /* Tiltrotor VTOL */
  MAV_TYPE_VTOL_TILTROTOR = 21,
  /* VTOL reserved 2 */
  MAV_TYPE_VTOL_RESERVED2 = 22,
  /* VTOL reserved 3 */
  MAV_TYPE_VTOL_RESERVED3 = 23,
  /* VTOL reserved 4 */
  MAV_TYPE_VTOL_RESERVED4 = 24,
  /* VTOL reserved 5 */
  MAV_TYPE_VTOL_RESERVED5 = 25,
  /* Gimbal (standalone) */
  MAV_TYPE_GIMBAL = 26,
  /* ADSB system (standalone) */
  MAV_TYPE_ADSB = 27,
  /* Steerable, nonrigid airfoil */
  MAV_TYPE_PARAFOIL = 28,
  /* Dodecarotor */
  MAV_TYPE_DODECAROTOR = 29,
  /* Camera (standalone) */
  MAV_TYPE_CAMERA = 30,
  /* Charging station */
  MAV_TYPE_CHARGING_STATION = 31,
  /* FLARM collision avoidance system (standalone) */
  MAV_TYPE_FLARM = 32
};

/* These flags encode the MAV mode. */
enum MAV_MODE_FLAG {
  /* 0b10000000 MAV safety set to armed. Motors are enabled / running / can
     start. Ready to fly. Additional note: this flag is to be ignore when sent
     in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM shall
     be used instead. The flag can still be used to report the armed state. */
  MAV_MODE_FLAG_SAFETY_ARMED = 128,
  /* 0b01000000 remote control input is enabled. */
  MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = 64,
  /* 0b00100000 hardware in the loop simulation. All motors / actuators are
     blocked, but internal software is full operational. */
  MAV_MODE_FLAG_HIL_ENABLED = 32,
  /* 0b00010000 system stabilizes electronically its attitude (and optionally
     position). It needs however further control inputs to move around. */
  MAV_MODE_FLAG_STABILIZE_ENABLED = 16,
  /* 0b00001000 guided mode enabled, system flies waypoints / mission items. */
  MAV_MODE_FLAG_GUIDED_ENABLED = 8,
  /* 0b00000100 autonomous mode enabled, system finds its own goal positions.
     Guided flag can be set or not, depends on the actual implementation. */
  MAV_MODE_FLAG_AUTO_ENABLED = 4,
  /* 0b00000010 system has a test mode enabled. This flag is intended for
     temporary system tests and should not be used for stable implementations.
   */
  MAV_MODE_FLAG_TEST_ENABLED = 2,
  /* 0b00000001 Reserved for future use. */
  MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = 1
};

/* These values encode the bit positions of the decode position. These values
 * can be used to read the value of a flag bit by combining the base_mode
 * variable with AND with the flag position value. The result will be either 0
 * or 1, depending on if the flag is set or not. */
enum MAV_MODE_FLAG_DECODE_POSITION {
  /* First bit:  10000000 */
  MAV_MODE_FLAG_DECODE_POSITION_SAFETY = 128,
  /* Second bit: 01000000 */
  MAV_MODE_FLAG_DECODE_POSITION_MANUAL = 64,
  /* Third bit:  00100000 */
  MAV_MODE_FLAG_DECODE_POSITION_HIL = 32,
  /* Fourth bit: 00010000 */
  MAV_MODE_FLAG_DECODE_POSITION_STABILIZE = 16,
  /* Fifth bit:  00001000 */
  MAV_MODE_FLAG_DECODE_POSITION_GUIDED = 8,
  /* Sixt bit:   00000100 */
  MAV_MODE_FLAG_DECODE_POSITION_AUTO = 4,
  /* Seventh bit: 00000010 */
  MAV_MODE_FLAG_DECODE_POSITION_TEST = 2,
  /* Eighth bit: 00000001 */
  MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE = 1
};

enum MAV_STATE {
  /* Uninitialized system, state is unknown. */
  MAV_STATE_UNINIT = 0,
  /* System is booting up. */
  MAV_STATE_BOOT = 1,
  /* System is calibrating and not flight-ready. */
  MAV_STATE_CALIBRATING = 2,
  /* System is grounded and on standby. It can be launched any time. */
  MAV_STATE_STANDBY = 3,
  /* System is active and might be already airborne. Motors are engaged. */
  MAV_STATE_ACTIVE = 4,
  /* System is in a non-normal flight mode. It can however still navigate. */
  MAV_STATE_CRITICAL = 5,
  /* System is in a non-normal flight mode. It lost control over parts or over
     the whole airframe. It is in mayday and going down. */
  MAV_STATE_EMERGENCY = 6,
  /* System just initialized its power-down sequence, will shut down now. */
  MAV_STATE_POWEROFF = 7,
  /* System is terminating itself. */
  MAV_STATE_FLIGHT_TERMINATION = 8
};

/* Component ids (values) for the different types and instances of onboard
 * hardware/software that might make up a MAVLink system (autopilot, cameras,
 * servos, GPS systems, avoidance systems etc.).        Components must use the
 * appropriate ID in their source address when sending messages. Components can
 * also use IDs to determine if they are the intended recipient of an incoming
 * message. The MAV_COMP_ID_ALL value is used to indicate messages that must be
 * processed by all components.       When creating new entries, components that
 * can have multiple instances (e.g. cameras, servos etc.) should be allocated
 * sequential values. An appropriate number of values should be left free after
 * these components to allow the number of instances to be expanded. */
enum MAV_COMPONENT {
  /* Used to broadcast messages to all components of the receiving system.
     Components should attempt to process messages with this component ID and
     forward to components on any other interfaces. */
  MAV_COMP_ID_ALL = 0,
  /* System flight controller component ("autopilot"). Only one autopilot is
     expected in a particular system. */
  MAV_COMP_ID_AUTOPILOT1 = 1,
  /* Camera #1. */
  MAV_COMP_ID_CAMERA = 100,
  /* Camera #2. */
  MAV_COMP_ID_CAMERA2 = 101,
  /* Camera #3. */
  MAV_COMP_ID_CAMERA3 = 102,
  /* Camera #4. */
  MAV_COMP_ID_CAMERA4 = 103,
  /* Camera #5. */
  MAV_COMP_ID_CAMERA5 = 104,
  /* Camera #6. */
  MAV_COMP_ID_CAMERA6 = 105,
  /* Servo #1. */
  MAV_COMP_ID_SERVO1 = 140,
  /* Servo #2. */
  MAV_COMP_ID_SERVO2 = 141,
  /* Servo #3. */
  MAV_COMP_ID_SERVO3 = 142,
  /* Servo #4. */
  MAV_COMP_ID_SERVO4 = 143,
  /* Servo #5. */
  MAV_COMP_ID_SERVO5 = 144,
  /* Servo #6. */
  MAV_COMP_ID_SERVO6 = 145,
  /* Servo #7. */
  MAV_COMP_ID_SERVO7 = 146,
  /* Servo #8. */
  MAV_COMP_ID_SERVO8 = 147,
  /* Servo #9. */
  MAV_COMP_ID_SERVO9 = 148,
  /* Servo #10. */
  MAV_COMP_ID_SERVO10 = 149,
  /* Servo #11. */
  MAV_COMP_ID_SERVO11 = 150,
  /* Servo #12. */
  MAV_COMP_ID_SERVO12 = 151,
  /* Servo #13. */
  MAV_COMP_ID_SERVO13 = 152,
  /* Servo #14. */
  MAV_COMP_ID_SERVO14 = 153,
  /* Gimbal component. */
  MAV_COMP_ID_GIMBAL = 154,
  /* Logging component. */
  MAV_COMP_ID_LOG = 155,
  /* Automatic Dependent Surveillance-Broadcast (ADS-B) component. */
  MAV_COMP_ID_ADSB = 156,
  /* On Screen Display (OSD) devices for video links. */
  MAV_COMP_ID_OSD = 157,
  /* Generic autopilot peripheral component ID. Meant for devices that do not
     implement the parameter microservice. */
  MAV_COMP_ID_PERIPHERAL = 158,
  /* Gimbal ID for QX1. */
  MAV_COMP_ID_QX1_GIMBAL = 159,
  /* FLARM collision alert component. */
  MAV_COMP_ID_FLARM = 160,
  /* Component that supports the Mission microservice. */
  MAV_COMP_ID_MISSIONPLANNER = 190,
  /* Component that finds an optimal path between points based on a certain
     constraint (e.g. minimum snap, shortest path, cost, etc.). */
  MAV_COMP_ID_PATHPLANNER = 195,
  /* Component that plans a collision free path between two points. */
  MAV_COMP_ID_OBSTACLE_AVOIDANCE = 196,
  /* Component that provides position estimates using VIO techniques. */
  MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY = 197,
  /* Inertial Measurement Unit (IMU) #1. */
  MAV_COMP_ID_IMU = 200,
  /* Inertial Measurement Unit (IMU) #2. */
  MAV_COMP_ID_IMU_2 = 201,
  /* Inertial Measurement Unit (IMU) #3. */
  MAV_COMP_ID_IMU_3 = 202,
  /* GPS #1. */
  MAV_COMP_ID_GPS = 220,
  /* GPS #2. */
  MAV_COMP_ID_GPS2 = 221,
  /* Component to bridge MAVLink to UDP (i.e. from a UART). */
  MAV_COMP_ID_UDP_BRIDGE = 240,
  /* Component to bridge to UART (i.e. from UDP). */
  MAV_COMP_ID_UART_BRIDGE = 241,
  /* Component for handling system messages (e.g. to ARM, takeoff, etc.). */
  MAV_COMP_ID_SYSTEM_CONTROL = 250
};

// This enum is used to switch the anonymous union in minimal_message.
enum MINIMAL_MESSAGE { MINIMAL_MESSAGE_HEARTBEAT = 0 };

// A message contains the information encoded in a mavlink v1 or v2 frame
// header, plus the frame payload. It can always be serialized into maximally
// 280 bytes.
struct minimal_message {
  // bytes consumed when deserializing, or needed when serializing.
  // This is the sum of header (v1/v2) + payload lengths, set by _serialize or
  // _deserialize functions.
  size_t len;
  // if non zero, the crc was bad on deserializing.  ignored when serializing.
  uint16_t crc;

  // System, Component and Link IDs
  uint8_t sys_id;
  uint8_t comp_id;
  uint8_t link_id; // only used on signed V2

  // These only used for signed V2 messages, should be zero otherwise.
  uint64_t timestamp; //  10 microsecond units since 1st January 2015 GMT (unix
                      //  time 1420070400)
  uint64_t signature;

  // Lower 8 bits of seqNr are used to set the seq byte on serialized messages.
  // On deserialized messages, used to update seqDropped (ignored for
  // serialization). The sequence number is supposed to be unique per stream
  // (sys/comp/link), so the caller must manage that explicitly if these change.
  uint64_t seq_nr;
  uint32_t seq_dropped;

  // msg_id determines which of the union members is set.
  enum MINIMAL_MESSAGE msg_id;
  union {
    /* The heartbeat message shows that a system or component is present and
     * responding. The type and autopilot fields (along with the message
     * component id), allow the receiving system to treat further messages from
     * this system appropriately (e.g. by laying out the user interface based on
     * the autopilot). */
    struct {
      uint32_t
          custom_mode; /* A bitfield for use for autopilot-specific flags */
      enum MAV_TYPE
          type; /* (uint8_t) Type of the system (quadrotor, helicopter, etc.).
                   Components use the same type as their associated system. */
      enum MAV_AUTOPILOT autopilot; /* (uint8_t) Autopilot type / class. */
      enum MAV_MODE_FLAG base_mode; /* (uint8_t) System mode bitmap. */
      enum MAV_STATE system_status; /* (uint8_t) System status flag. */
      uint8_t mavlink_version; /* MAVLink version, not writable by user, gets
                                  added by protocol because of magic data type:
                                  uint8_t_mavlink_version */
    } heartbeat;
  };
};

/* Sign[ed] sets/checks the signature field of message based on the shared
 * secret. Signed returns non-zero (true) iff the signature is zero (V1 or
 * unsigned V2) or correct (signed V2), zero (false) for a non-zero signature
 * field that does not match the shared secret (signed V2 only).
 *
 * implemented in minimal_sign.c
 */
void minimal_message_sign(struct minimal_message *msg, uint8_t shared[32]);
int minimal_message_signed(struct minimal_message *msg, uint8_t shared[32]);

/* Serialize_v1 and _v2 write the message to buf in mavlink V1/V2 frame
 * encoding. These functions takes care not to write more than size bytes, and
 * return the number of bytes needed, even if that exceeds size. On succesful
 * encoding, the sequence number is updated, so the same structure can be
 * re-used easily for sending a stream of messages. If the message can not be
 * encoded for whatever reason (e.g. msg id > 255), the return value is 0.
 *
 * implemented in minimal_enc.c
 */
size_t minimal_message_serialize_v1(struct minimal_message *msg, uint8_t *buf,
                                    size_t size);
size_t minimal_message_serialize_v2(struct minimal_message *msg, uint8_t *buf,
                                    size_t size);

/* Seek returns the number of bytes to skip to the start of a frame, or when buf
 * starts with a frame STX, it returns 0. If seek can not find the start of a
 * frame it returns size.
 *
 * implemented in minimal_dec.c
 */
size_t minimal_message_seek(const uint8_t *buf, size_t size);

/* Deserialize reads up to min(size, 280) bytes from buf and decodes a V1, V2
 * signed or unsigned message. if buf is too small, i.e. does not contain a
 * complete frame, or does not start with a valid STX, it returns zero, but msg
 * may have been modified with the partially decoded message.  It will not
 * increment seqnr/dropped in this case. If the frame is corrupt, its crc field
 * will be non zero.  This is the only integrity check if the message is not
 * _signed(); In case of a corrupt package, the advised way to proceed is to
 * call _seek on (++buf,--size) to find the next possible packet start. If the
 * message id is unknown by this library the payload will be ignored, but all
 * header fields will be set accordingly.
 *
 * implemented in minimal_dec.c
 */
size_t minimal_message_deserialize(const uint8_t *buf, size_t size,
                                   struct minimal_message *msg);

/* _snprintf appends a debug representation of the message to a buffer
 * implemented in minimal_fmt.c
 */
size_t minimal_message_snprintf(char *buf, size_t size,
                                const struct minimal_message *msg);
