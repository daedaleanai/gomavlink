#pragma once

// Generated enums and structures for Mavlink dialect {{.Name}} #{{.Dialect}} version {{.Version}}
// Generated by gomavlink, DO NOT EDIT.

#include <cstdint>

namespace mavlink {
namespace {{lower .Name}} {

{{range .Enums}}
{{- $tpe := underscoreToCamel .Name}}
{{if .Description}}/* {{notabs .Description}} */{{end}}
enum {{$tpe}} {
{{- range $i, $v := .Entries -}}{{if $i}},{{end}}
	{{if $v.Description}}/* {{notabs $v.Description}} */{{end}}
	{{upper $v.Name}} = {{$v.Value}} 
{{- end}}
};
{{end}}

// Message is the base class for all message classed generated from the xml.
// You can construct a concrete derived class or decode an abstract base class
// from a stream and use the id() to decide what to cast to.
class Message {
public:

	// Decode deserializes a frame from *buf, not reading more than size bytes.
	// It returns a message of the appropriate derived type if decoding was successful
	// or one of the reserved Error messages defined below.  Use len() to find out how many
	// bytes to advance buf by.
	// The sequence number will be updated and used to calculate the apparent number of missed frames.
	static Message* decode(const uint8_t* buf, size_t size, uint64_t* seqnr);

	// for decoded messages len() returns the number of bytes consumed by the decode() call.
	// For freshly constructed concrete subtype messageslen() returns zero.
	size_t len() const { return len_; }

	// Encode serializes a frame into buf.  Format and header  are controlled by the encoding, 
	// sysId, compId and linkId fields.
	// Encode returns the number of bytes that are needed to encode this message into a frame
	// but will not write beyond size bytes into buffer.
	// The sequence number will be incremented.
	size_t encode(uint8_t* buf, size_t size, uint64_t* seqnr) const;

	// The generated id() method can be used to compare the derived class' message id to 
	// their static ID members, to switch type casts.
	virtual int id() const = 0;

	// TODO(lvd) maybe move this and seqnr, timestamp into a nested struct type and keep outside?
	// Parameters that control the frame encodingor reflect the frame that was decoded.
	// The user may freely set these before any call to encode() to control the next emitted frame.
	enum Protocol { V2 = 0, V1 = 1, V2Signed = 2 } protocol;
	uint8_t sysId;
	uint8_t compId;
	uint8_t linkId;

	/* TODO 
	// For V2Signed messages, isValidSignature returns false if the signature was not valid,
	// for V1 always returns true
	bool isValidSignature(const uint8_t shared_secret[32) const;
	void sign(const uint8_t shared_secret[32], uint64_t timestamp);
	uint64_t timestamp(); // only for decoded V2 signed messages
	*/

	// for decoded frames, the number of apparently skipped frames as calculated from the sequence number.
	int skippedFrames() const;

	// a virtual constructor shouldnt be necesary(?)
	virtual ~Message() {};

protected:
	Message(): protocol(V2), sysId(0), compId(0), linkId(0), len_(0), skipped_(0) {}

	// the generated appendToBuf methods de/serialize the payload fields of the derived type from/to buf[0:size]
	// append returns the number of bytes needed to serialize this message even if it did not fit.  readFrom
	// uses zeros when reading beyond size.
	virtual size_t appendToBuf(uint8_t* buf, size_t size) const = 0;
	virtual void   readFromBuf(uint8_t* buf, size_t size) = 0;

	virtual uint8_t crcExtra() const = 0;

private:
	size_t  len_; 		// number of bytes consumed when decoding;
	uint8_t skipped_;	// apparent number of dropped frames in the decoded stream
};

// Message::Decode returns a message of these types if it could not find a valid message in the buffer
class ErrorMessage public Message {
protected:
	virtual size_t  appendToBuf(uint8_t* buf, size_t size) {return 0; };
	virtual void    readFromBuf(uint8_t* buf, size_t size) {};
	virtual uint8_t crcExtra() const                       { return 0; };
}


class PartialMessage public ErrorMessage { static const int ID = -1; virtual int id() const { return ID; } }; // premature EOF, Len() == size
class InvalidMessage public ErrorMessage { static const int ID = -2; virtual int id() const { return ID; } }; // unknown message ID
class CorruptMessage public ErrorMessage { static const int ID = -3; virtual int id() const { return ID; } }; // bad CRC

// Message::Decode returns a message of this type if there is leading garbage before an STX marker
// Len() will indicate the number of bytes to skip before the marker.
class ResyncMessage public ErrorMessage { static const int ID = -4; virtual int id() const { return ID; } };


{{range .Messages}}
{{- $tpe := underscoreToCamel .Name}}
{{if .Description}}/* {{notabs .Description}} */{{end}}
class {{$tpe}} public Message {
public:
	static const int ID = {{.ID}};
	virtual int id() const { return ID; }

{{range .Fields}}
	/* {{notabs .Description}} */
	{{if .Enum -}} {{underscoreToCamel .Enum}} {{- else -}} {{cscalartype .CType}} {{- end}} {{underscoreToCamel .Name}}
	{{- if goarraysize .CType}}[{{goarraysize .CType}}]{{end}}; 
	{{- if or .Enum .IsExtension}}	//{{end}} {{if .Enum -}}({{.CType}}){{end}} {{if .IsExtension}}EXTENSION{{end}}
{{end}}

protected:
	virtual size_t appendToBuf(uint8_t* buf, size_t size) const;
	virtual void   readFromBuf(uint8_t* buf, size_t size);

	virtual uint8_t crcExtra() const { return {{.CRCExtra}}; }
};

{{end}}



{{if .Messages}}
//**** this goes to the cpp.tmpl
// The Dialect factory function constructs the proper empty message given the message ID.
void* Dialect(int mid) {
	switch (mid) {
{{- range .Messages}}
	case {{.ID}}: return new {{underscoreToCamel .Name}};
{{- end}}
	}
	return 0;
}
*/
{{end}}


} // {{lower .Name}}
} // namespace mavlink
