// Generated enums and structures for Mavlink dialect uavionix #0 version 3
package uavionix

// Generated by gomavlink, DO NOT EDIT.

import (
	"math"

	mavlink "github.com/daedaleanai/gomavlink"
)

//go:generate stringer -output strings.go -type=UavionixAdsbOutDynamicState,UavionixAdsbOutRfSelect,UavionixAdsbOutDynamicGpsFix,UavionixAdsbRfHealth,UavionixAdsbOutCfgAircraftSize,UavionixAdsbOutCfgGpsOffsetLat,UavionixAdsbOutCfgGpsOffsetLon,UavionixAdsbEmergencyStatus,MavAutopilot,MavType,FirmwareVersionType,HlFailureFlag,MavModeFlag,MavModeFlagDecodePosition,MavGoto,MavMode,MavState,MavComponent,MavSysStatusSensor,MavFrame,MavlinkDataStreamType,FenceAction,FenceBreach,MavMountMode,UavcanNodeHealth,UavcanNodeMode,MavCmd,MavDataStream,MavRoi,MavCmdAck,MavParamType,MavParamExtType,MavResult,MavMissionResult,MavSeverity,MavPowerStatus,SerialControlDev,SerialControlFlag,MavDistanceSensor,MavSensorOrientation,MavProtocolCapability,MavMissionType,MavEstimatorType,MavBatteryType,MavBatteryFunction,MavBatteryChargeState,MavSmartBatteryFault,MavVtolState,MavLandedState,AdsbAltitudeType,AdsbEmitterType,AdsbFlags,MavDoRepositionFlags,EstimatorStatusFlags,MotorTestOrder,MotorTestThrottleType,GpsInputIgnoreFlags,MavCollisionAction,MavCollisionThreatLevel,MavCollisionSrc,GpsFixType,RtkBaselineCoordinateSystem,LandingTargetType,VtolTransitionHeading,CameraCapFlags,VideoStreamStatusFlags,VideoStreamType,CameraZoomType,SetFocusType,ParamAck,CameraMode,MavArmAuthDeniedReason,RcType,PositionTargetTypemask,UtmFlightState,UtmDataAvailFlags,CellularNetworkRadioType,CellularNetworkStatusFlag,PrecisionLandMode,ParachuteAction

/* State flags for ADS-B transponder dynamic report */
type UavionixAdsbOutDynamicState uint32

const (
	UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE UavionixAdsbOutDynamicState = 1

	UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED UavionixAdsbOutDynamicState = 2

	UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED UavionixAdsbOutDynamicState = 4

	UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND UavionixAdsbOutDynamicState = 8

	UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT UavionixAdsbOutDynamicState = 16
)

/* Transceiver RF control flags for ADS-B transponder dynamic reports */
type UavionixAdsbOutRfSelect uint32

const (
	UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY UavionixAdsbOutRfSelect = 0

	UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED UavionixAdsbOutRfSelect = 1

	UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED UavionixAdsbOutRfSelect = 2
)

/* Status for ADS-B transponder dynamic input */
type UavionixAdsbOutDynamicGpsFix uint32

const (
	UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 UavionixAdsbOutDynamicGpsFix = 0

	UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1 UavionixAdsbOutDynamicGpsFix = 1

	UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D UavionixAdsbOutDynamicGpsFix = 2

	UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D UavionixAdsbOutDynamicGpsFix = 3

	UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS UavionixAdsbOutDynamicGpsFix = 4

	UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK UavionixAdsbOutDynamicGpsFix = 5
)

/* Status flags for ADS-B transponder dynamic output */
type UavionixAdsbRfHealth uint32

const (
	UAVIONIX_ADSB_RF_HEALTH_INITIALIZING UavionixAdsbRfHealth = 0

	UAVIONIX_ADSB_RF_HEALTH_OK UavionixAdsbRfHealth = 1

	UAVIONIX_ADSB_RF_HEALTH_FAIL_TX UavionixAdsbRfHealth = 2

	UAVIONIX_ADSB_RF_HEALTH_FAIL_RX UavionixAdsbRfHealth = 16
)

/* Definitions for aircraft size */
type UavionixAdsbOutCfgAircraftSize uint32

const (
	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA UavionixAdsbOutCfgAircraftSize = 0

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M UavionixAdsbOutCfgAircraftSize = 1

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M UavionixAdsbOutCfgAircraftSize = 2

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M UavionixAdsbOutCfgAircraftSize = 3

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M UavionixAdsbOutCfgAircraftSize = 4

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M UavionixAdsbOutCfgAircraftSize = 5

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M UavionixAdsbOutCfgAircraftSize = 6

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M UavionixAdsbOutCfgAircraftSize = 7

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M UavionixAdsbOutCfgAircraftSize = 8

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M UavionixAdsbOutCfgAircraftSize = 9

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M UavionixAdsbOutCfgAircraftSize = 10

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M UavionixAdsbOutCfgAircraftSize = 11

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M UavionixAdsbOutCfgAircraftSize = 12

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M UavionixAdsbOutCfgAircraftSize = 13

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M UavionixAdsbOutCfgAircraftSize = 14

	UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M UavionixAdsbOutCfgAircraftSize = 15
)

/* GPS lataral offset encoding */
type UavionixAdsbOutCfgGpsOffsetLat uint32

const (
	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_NO_DATA UavionixAdsbOutCfgGpsOffsetLat = 0

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_2M UavionixAdsbOutCfgGpsOffsetLat = 1

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_4M UavionixAdsbOutCfgGpsOffsetLat = 2

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_6M UavionixAdsbOutCfgGpsOffsetLat = 3

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_0M UavionixAdsbOutCfgGpsOffsetLat = 4

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_2M UavionixAdsbOutCfgGpsOffsetLat = 5

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_4M UavionixAdsbOutCfgGpsOffsetLat = 6

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_6M UavionixAdsbOutCfgGpsOffsetLat = 7
)

/* GPS longitudinal offset encoding */
type UavionixAdsbOutCfgGpsOffsetLon uint32

const (
	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA UavionixAdsbOutCfgGpsOffsetLon = 0

	UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR UavionixAdsbOutCfgGpsOffsetLon = 1
)

/* Emergency status encoding */
type UavionixAdsbEmergencyStatus uint32

const (
	UAVIONIX_ADSB_OUT_NO_EMERGENCY UavionixAdsbEmergencyStatus = 0

	UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY UavionixAdsbEmergencyStatus = 1

	UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY UavionixAdsbEmergencyStatus = 2

	UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY UavionixAdsbEmergencyStatus = 3

	UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY UavionixAdsbEmergencyStatus = 4

	UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY UavionixAdsbEmergencyStatus = 5

	UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY UavionixAdsbEmergencyStatus = 6

	UAVIONIX_ADSB_OUT_RESERVED UavionixAdsbEmergencyStatus = 7
)

/* Micro air vehicle / autopilot classes. This identifies the individual model. */
type MavAutopilot uint32

const (
	/* Generic autopilot, full support for everything */
	MAV_AUTOPILOT_GENERIC MavAutopilot = 0

	/* Reserved for future use. */
	MAV_AUTOPILOT_RESERVED MavAutopilot = 1

	/* SLUGS autopilot, http://slugsuav.soe.ucsc.edu */
	MAV_AUTOPILOT_SLUGS MavAutopilot = 2

	/* ArduPilot - Plane/Copter/Rover/Sub/Tracker, http://ardupilot.org */
	MAV_AUTOPILOT_ARDUPILOTMEGA MavAutopilot = 3

	/* OpenPilot, http://openpilot.org */
	MAV_AUTOPILOT_OPENPILOT MavAutopilot = 4

	/* Generic autopilot only supporting simple waypoints */
	MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY MavAutopilot = 5

	/* Generic autopilot supporting waypoints and other simple navigation commands */
	MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY MavAutopilot = 6

	/* Generic autopilot supporting the full mission command set */
	MAV_AUTOPILOT_GENERIC_MISSION_FULL MavAutopilot = 7

	/* No valid autopilot, e.g. a GCS or other MAVLink component */
	MAV_AUTOPILOT_INVALID MavAutopilot = 8

	/* PPZ UAV - http://nongnu.org/paparazzi */
	MAV_AUTOPILOT_PPZ MavAutopilot = 9

	/* UAV Dev Board */
	MAV_AUTOPILOT_UDB MavAutopilot = 10

	/* FlexiPilot */
	MAV_AUTOPILOT_FP MavAutopilot = 11

	/* PX4 Autopilot - http://px4.io/ */
	MAV_AUTOPILOT_PX4 MavAutopilot = 12

	/* SMACCMPilot - http://smaccmpilot.org */
	MAV_AUTOPILOT_SMACCMPILOT MavAutopilot = 13

	/* AutoQuad -- http://autoquad.org */
	MAV_AUTOPILOT_AUTOQUAD MavAutopilot = 14

	/* Armazila -- http://armazila.com */
	MAV_AUTOPILOT_ARMAZILA MavAutopilot = 15

	/* Aerob -- http://aerob.ru */
	MAV_AUTOPILOT_AEROB MavAutopilot = 16

	/* ASLUAV autopilot -- http://www.asl.ethz.ch */
	MAV_AUTOPILOT_ASLUAV MavAutopilot = 17

	/* SmartAP Autopilot - http://sky-drones.com */
	MAV_AUTOPILOT_SMARTAP MavAutopilot = 18

	/* AirRails - http://uaventure.com */
	MAV_AUTOPILOT_AIRRAILS MavAutopilot = 19
)

/* MAVLINK system type. All components in a system should report this type in their HEARTBEAT. */
type MavType uint32

const (
	/* Generic micro air vehicle. */
	MAV_TYPE_GENERIC MavType = 0

	/* Fixed wing aircraft. */
	MAV_TYPE_FIXED_WING MavType = 1

	/* Quadrotor */
	MAV_TYPE_QUADROTOR MavType = 2

	/* Coaxial helicopter */
	MAV_TYPE_COAXIAL MavType = 3

	/* Normal helicopter with tail rotor. */
	MAV_TYPE_HELICOPTER MavType = 4

	/* Ground installation */
	MAV_TYPE_ANTENNA_TRACKER MavType = 5

	/* Operator control unit / ground control station */
	MAV_TYPE_GCS MavType = 6

	/* Airship, controlled */
	MAV_TYPE_AIRSHIP MavType = 7

	/* Free balloon, uncontrolled */
	MAV_TYPE_FREE_BALLOON MavType = 8

	/* Rocket */
	MAV_TYPE_ROCKET MavType = 9

	/* Ground rover */
	MAV_TYPE_GROUND_ROVER MavType = 10

	/* Surface vessel, boat, ship */
	MAV_TYPE_SURFACE_BOAT MavType = 11

	/* Submarine */
	MAV_TYPE_SUBMARINE MavType = 12

	/* Hexarotor */
	MAV_TYPE_HEXAROTOR MavType = 13

	/* Octorotor */
	MAV_TYPE_OCTOROTOR MavType = 14

	/* Tricopter */
	MAV_TYPE_TRICOPTER MavType = 15

	/* Flapping wing */
	MAV_TYPE_FLAPPING_WING MavType = 16

	/* Kite */
	MAV_TYPE_KITE MavType = 17

	/* Onboard companion controller */
	MAV_TYPE_ONBOARD_CONTROLLER MavType = 18

	/* Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter. */
	MAV_TYPE_VTOL_DUOROTOR MavType = 19

	/* Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter. */
	MAV_TYPE_VTOL_QUADROTOR MavType = 20

	/* Tiltrotor VTOL */
	MAV_TYPE_VTOL_TILTROTOR MavType = 21

	/* VTOL reserved 2 */
	MAV_TYPE_VTOL_RESERVED2 MavType = 22

	/* VTOL reserved 3 */
	MAV_TYPE_VTOL_RESERVED3 MavType = 23

	/* VTOL reserved 4 */
	MAV_TYPE_VTOL_RESERVED4 MavType = 24

	/* VTOL reserved 5 */
	MAV_TYPE_VTOL_RESERVED5 MavType = 25

	/* Gimbal (standalone) */
	MAV_TYPE_GIMBAL MavType = 26

	/* ADSB system (standalone) */
	MAV_TYPE_ADSB MavType = 27

	/* Steerable, nonrigid airfoil */
	MAV_TYPE_PARAFOIL MavType = 28

	/* Dodecarotor */
	MAV_TYPE_DODECAROTOR MavType = 29

	/* Camera (standalone) */
	MAV_TYPE_CAMERA MavType = 30

	/* Charging station */
	MAV_TYPE_CHARGING_STATION MavType = 31

	/* FLARM collision avoidance system (standalone) */
	MAV_TYPE_FLARM MavType = 32
)

/* These values define the type of firmware release.  These values indicate the first version or release of this type.  For example the first alpha release would be 64, the second would be 65. */
type FirmwareVersionType uint32

const (
	/* development release */
	FIRMWARE_VERSION_TYPE_DEV FirmwareVersionType = 0

	/* alpha release */
	FIRMWARE_VERSION_TYPE_ALPHA FirmwareVersionType = 64

	/* beta release */
	FIRMWARE_VERSION_TYPE_BETA FirmwareVersionType = 128

	/* release candidate */
	FIRMWARE_VERSION_TYPE_RC FirmwareVersionType = 192

	/* official stable release */
	FIRMWARE_VERSION_TYPE_OFFICIAL FirmwareVersionType = 255
)

/* Flags to report failure cases over the high latency telemtry. */
type HlFailureFlag uint32

const (
	/* GPS failure. */
	HL_FAILURE_FLAG_GPS HlFailureFlag = 1

	/* Differential pressure sensor failure. */
	HL_FAILURE_FLAG_DIFFERENTIAL_PRESSURE HlFailureFlag = 2

	/* Absolute pressure sensor failure. */
	HL_FAILURE_FLAG_ABSOLUTE_PRESSURE HlFailureFlag = 4

	/* Accelerometer sensor failure. */
	HL_FAILURE_FLAG_3D_ACCEL HlFailureFlag = 8

	/* Gyroscope sensor failure. */
	HL_FAILURE_FLAG_3D_GYRO HlFailureFlag = 16

	/* Magnetometer sensor failure. */
	HL_FAILURE_FLAG_3D_MAG HlFailureFlag = 32

	/* Terrain subsystem failure. */
	HL_FAILURE_FLAG_TERRAIN HlFailureFlag = 64

	/* Battery failure/critical low battery. */
	HL_FAILURE_FLAG_BATTERY HlFailureFlag = 128

	/* RC receiver failure/no rc connection. */
	HL_FAILURE_FLAG_RC_RECEIVER HlFailureFlag = 256

	/* Offboard link failure. */
	HL_FAILURE_FLAG_OFFBOARD_LINK HlFailureFlag = 512

	/* Engine failure. */
	HL_FAILURE_FLAG_ENGINE HlFailureFlag = 1024

	/* Geofence violation. */
	HL_FAILURE_FLAG_GEOFENCE HlFailureFlag = 2048

	/* Estimator failure, for example measurement rejection or large variances. */
	HL_FAILURE_FLAG_ESTIMATOR HlFailureFlag = 4096

	/* Mission failure. */
	HL_FAILURE_FLAG_MISSION HlFailureFlag = 8192
)

/* These flags encode the MAV mode. */
type MavModeFlag uint32

const (
	/* 0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM shall be used instead. The flag can still be used to report the armed state. */
	MAV_MODE_FLAG_SAFETY_ARMED MavModeFlag = 128

	/* 0b01000000 remote control input is enabled. */
	MAV_MODE_FLAG_MANUAL_INPUT_ENABLED MavModeFlag = 64

	/* 0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational. */
	MAV_MODE_FLAG_HIL_ENABLED MavModeFlag = 32

	/* 0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around. */
	MAV_MODE_FLAG_STABILIZE_ENABLED MavModeFlag = 16

	/* 0b00001000 guided mode enabled, system flies waypoints / mission items. */
	MAV_MODE_FLAG_GUIDED_ENABLED MavModeFlag = 8

	/* 0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation. */
	MAV_MODE_FLAG_AUTO_ENABLED MavModeFlag = 4

	/* 0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations. */
	MAV_MODE_FLAG_TEST_ENABLED MavModeFlag = 2

	/* 0b00000001 Reserved for future use. */
	MAV_MODE_FLAG_CUSTOM_MODE_ENABLED MavModeFlag = 1
)

/* These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not. */
type MavModeFlagDecodePosition uint32

const (
	/* First bit:  10000000 */
	MAV_MODE_FLAG_DECODE_POSITION_SAFETY MavModeFlagDecodePosition = 128

	/* Second bit: 01000000 */
	MAV_MODE_FLAG_DECODE_POSITION_MANUAL MavModeFlagDecodePosition = 64

	/* Third bit:  00100000 */
	MAV_MODE_FLAG_DECODE_POSITION_HIL MavModeFlagDecodePosition = 32

	/* Fourth bit: 00010000 */
	MAV_MODE_FLAG_DECODE_POSITION_STABILIZE MavModeFlagDecodePosition = 16

	/* Fifth bit:  00001000 */
	MAV_MODE_FLAG_DECODE_POSITION_GUIDED MavModeFlagDecodePosition = 8

	/* Sixt bit:   00000100 */
	MAV_MODE_FLAG_DECODE_POSITION_AUTO MavModeFlagDecodePosition = 4

	/* Seventh bit: 00000010 */
	MAV_MODE_FLAG_DECODE_POSITION_TEST MavModeFlagDecodePosition = 2

	/* Eighth bit: 00000001 */
	MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE MavModeFlagDecodePosition = 1
)

/* Actions that may be specified in MAV_CMD_OVERRIDE_GOTO to override mission execution. */
type MavGoto uint32

const (
	/* Hold at the current position. */
	MAV_GOTO_DO_HOLD MavGoto = 0

	/* Continue with the next item in mission execution. */
	MAV_GOTO_DO_CONTINUE MavGoto = 1

	/* Hold at the current position of the system */
	MAV_GOTO_HOLD_AT_CURRENT_POSITION MavGoto = 2

	/* Hold at the position specified in the parameters of the DO_HOLD action */
	MAV_GOTO_HOLD_AT_SPECIFIED_POSITION MavGoto = 3
)

/* These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it                simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override. */
type MavMode uint32

const (
	/* System is not ready to fly, booting, calibrating, etc. No flag is set. */
	MAV_MODE_PREFLIGHT MavMode = 0

	/* System is allowed to be active, under assisted RC control. */
	MAV_MODE_STABILIZE_DISARMED MavMode = 80

	/* System is allowed to be active, under assisted RC control. */
	MAV_MODE_STABILIZE_ARMED MavMode = 208

	/* System is allowed to be active, under manual (RC) control, no stabilization */
	MAV_MODE_MANUAL_DISARMED MavMode = 64

	/* System is allowed to be active, under manual (RC) control, no stabilization */
	MAV_MODE_MANUAL_ARMED MavMode = 192

	/* System is allowed to be active, under autonomous control, manual setpoint */
	MAV_MODE_GUIDED_DISARMED MavMode = 88

	/* System is allowed to be active, under autonomous control, manual setpoint */
	MAV_MODE_GUIDED_ARMED MavMode = 216

	/* System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints) */
	MAV_MODE_AUTO_DISARMED MavMode = 92

	/* System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints) */
	MAV_MODE_AUTO_ARMED MavMode = 220

	/* UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only. */
	MAV_MODE_TEST_DISARMED MavMode = 66

	/* UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only. */
	MAV_MODE_TEST_ARMED MavMode = 194
)

type MavState uint32

const (
	/* Uninitialized system, state is unknown. */
	MAV_STATE_UNINIT MavState = 0

	/* System is booting up. */
	MAV_STATE_BOOT MavState = 2

	/* System is calibrating and not flight-ready. */
	MAV_STATE_CALIBRATING MavState = 3

	/* System is grounded and on standby. It can be launched any time. */
	MAV_STATE_STANDBY MavState = 4

	/* System is active and might be already airborne. Motors are engaged. */
	MAV_STATE_ACTIVE MavState = 5

	/* System is in a non-normal flight mode. It can however still navigate. */
	MAV_STATE_CRITICAL MavState = 6

	/* System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down. */
	MAV_STATE_EMERGENCY MavState = 7

	/* System just initialized its power-down sequence, will shut down now. */
	MAV_STATE_POWEROFF MavState = 8

	/* System is terminating itself. */
	MAV_STATE_FLIGHT_TERMINATION MavState = 9
)

/* Component ids (values) for the different types and instances of onboard hardware/software that might make up a MAVLink system (autopilot, cameras, servos, GPS systems, avoidance systems etc.).       Components must use the appropriate ID in their source address when sending messages. Components can also use IDs to determine if they are the intended recipient of an incoming message. The MAV_COMP_ID_ALL value is used to indicate messages that must be processed by all components.       When creating new entries, components that can have multiple instances (e.g. cameras, servos etc.) should be allocated sequential values. An appropriate number of values should be left free after these components to allow the number of instances to be expanded. */
type MavComponent uint32

const (
	/* Used to broadcast messages to all components of the receiving system. Components should attempt to process messages with this component ID and forward to components on any other interfaces. */
	MAV_COMP_ID_ALL MavComponent = 0

	/* System flight controller component ("autopilot"). Only one autopilot is expected in a particular system. */
	MAV_COMP_ID_AUTOPILOT1 MavComponent = 1

	/* Camera #1. */
	MAV_COMP_ID_CAMERA MavComponent = 100

	/* Camera #2. */
	MAV_COMP_ID_CAMERA2 MavComponent = 101

	/* Camera #3. */
	MAV_COMP_ID_CAMERA3 MavComponent = 102

	/* Camera #4. */
	MAV_COMP_ID_CAMERA4 MavComponent = 103

	/* Camera #5. */
	MAV_COMP_ID_CAMERA5 MavComponent = 104

	/* Camera #6. */
	MAV_COMP_ID_CAMERA6 MavComponent = 105

	/* Servo #1. */
	MAV_COMP_ID_SERVO1 MavComponent = 140

	/* Servo #2. */
	MAV_COMP_ID_SERVO2 MavComponent = 141

	/* Servo #3. */
	MAV_COMP_ID_SERVO3 MavComponent = 142

	/* Servo #4. */
	MAV_COMP_ID_SERVO4 MavComponent = 143

	/* Servo #5. */
	MAV_COMP_ID_SERVO5 MavComponent = 144

	/* Servo #6. */
	MAV_COMP_ID_SERVO6 MavComponent = 145

	/* Servo #7. */
	MAV_COMP_ID_SERVO7 MavComponent = 146

	/* Servo #8. */
	MAV_COMP_ID_SERVO8 MavComponent = 147

	/* Servo #9. */
	MAV_COMP_ID_SERVO9 MavComponent = 148

	/* Servo #10. */
	MAV_COMP_ID_SERVO10 MavComponent = 149

	/* Servo #11. */
	MAV_COMP_ID_SERVO11 MavComponent = 150

	/* Servo #12. */
	MAV_COMP_ID_SERVO12 MavComponent = 151

	/* Servo #13. */
	MAV_COMP_ID_SERVO13 MavComponent = 152

	/* Servo #14. */
	MAV_COMP_ID_SERVO14 MavComponent = 153

	/* Gimbal component. */
	MAV_COMP_ID_GIMBAL MavComponent = 154

	/* Logging component. */
	MAV_COMP_ID_LOG MavComponent = 155

	/* Automatic Dependent Surveillance-Broadcast (ADS-B) component. */
	MAV_COMP_ID_ADSB MavComponent = 156

	/* On Screen Display (OSD) devices for video links. */
	MAV_COMP_ID_OSD MavComponent = 157

	/* Generic autopilot peripheral component ID. Meant for devices that do not implement the parameter microservice. */
	MAV_COMP_ID_PERIPHERAL MavComponent = 158

	/* Gimbal ID for QX1. */
	MAV_COMP_ID_QX1_GIMBAL MavComponent = 159

	/* FLARM collision alert component. */
	MAV_COMP_ID_FLARM MavComponent = 160

	/* Component that can generate/supply a mission flight plan (e.g. GCS or developer API). */
	MAV_COMP_ID_MISSIONPLANNER MavComponent = 190

	/* Component that finds an optimal path between points based on a certain constraint (e.g. minimum snap, shortest path, cost, etc.). */
	MAV_COMP_ID_PATHPLANNER MavComponent = 195

	/* Component that plans a collision free path between two points. */
	MAV_COMP_ID_OBSTACLE_AVOIDANCE MavComponent = 196

	/* Component that provides position estimates using VIO techniques. */
	MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY MavComponent = 197

	/* Inertial Measurement Unit (IMU) #1. */
	MAV_COMP_ID_IMU MavComponent = 200

	/* Inertial Measurement Unit (IMU) #2. */
	MAV_COMP_ID_IMU_2 MavComponent = 201

	/* Inertial Measurement Unit (IMU) #3. */
	MAV_COMP_ID_IMU_3 MavComponent = 202

	/* GPS #1. */
	MAV_COMP_ID_GPS MavComponent = 220

	/* GPS #2. */
	MAV_COMP_ID_GPS2 MavComponent = 221

	/* Component to bridge MAVLink to UDP (i.e. from a UART). */
	MAV_COMP_ID_UDP_BRIDGE MavComponent = 240

	/* Component to bridge to UART (i.e. from UDP). */
	MAV_COMP_ID_UART_BRIDGE MavComponent = 241

	/* Component for handling system messages (e.g. to ARM, takeoff, etc.). */
	MAV_COMP_ID_SYSTEM_CONTROL MavComponent = 250
)

/* These encode the sensors whose status is sent as part of the SYS_STATUS message. */
type MavSysStatusSensor uint32

const (
	/* 0x01 3D gyro */
	MAV_SYS_STATUS_SENSOR_3D_GYRO MavSysStatusSensor = 1

	/* 0x02 3D accelerometer */
	MAV_SYS_STATUS_SENSOR_3D_ACCEL MavSysStatusSensor = 2

	/* 0x04 3D magnetometer */
	MAV_SYS_STATUS_SENSOR_3D_MAG MavSysStatusSensor = 4

	/* 0x08 absolute pressure */
	MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE MavSysStatusSensor = 8

	/* 0x10 differential pressure */
	MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE MavSysStatusSensor = 16

	/* 0x20 GPS */
	MAV_SYS_STATUS_SENSOR_GPS MavSysStatusSensor = 32

	/* 0x40 optical flow */
	MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW MavSysStatusSensor = 64

	/* 0x80 computer vision position */
	MAV_SYS_STATUS_SENSOR_VISION_POSITION MavSysStatusSensor = 128

	/* 0x100 laser based position */
	MAV_SYS_STATUS_SENSOR_LASER_POSITION MavSysStatusSensor = 256

	/* 0x200 external ground truth (Vicon or Leica) */
	MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH MavSysStatusSensor = 512

	/* 0x400 3D angular rate control */
	MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL MavSysStatusSensor = 1024

	/* 0x800 attitude stabilization */
	MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION MavSysStatusSensor = 2048

	/* 0x1000 yaw position */
	MAV_SYS_STATUS_SENSOR_YAW_POSITION MavSysStatusSensor = 4096

	/* 0x2000 z/altitude control */
	MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL MavSysStatusSensor = 8192

	/* 0x4000 x/y position control */
	MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL MavSysStatusSensor = 16384

	/* 0x8000 motor outputs / control */
	MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS MavSysStatusSensor = 32768

	/* 0x10000 rc receiver */
	MAV_SYS_STATUS_SENSOR_RC_RECEIVER MavSysStatusSensor = 65536

	/* 0x20000 2nd 3D gyro */
	MAV_SYS_STATUS_SENSOR_3D_GYRO2 MavSysStatusSensor = 131072

	/* 0x40000 2nd 3D accelerometer */
	MAV_SYS_STATUS_SENSOR_3D_ACCEL2 MavSysStatusSensor = 262144

	/* 0x80000 2nd 3D magnetometer */
	MAV_SYS_STATUS_SENSOR_3D_MAG2 MavSysStatusSensor = 524288

	/* 0x100000 geofence */
	MAV_SYS_STATUS_GEOFENCE MavSysStatusSensor = 1048576

	/* 0x200000 AHRS subsystem health */
	MAV_SYS_STATUS_AHRS MavSysStatusSensor = 2097152

	/* 0x400000 Terrain subsystem health */
	MAV_SYS_STATUS_TERRAIN MavSysStatusSensor = 4194304

	/* 0x800000 Motors are reversed */
	MAV_SYS_STATUS_REVERSE_MOTOR MavSysStatusSensor = 8388608

	/* 0x1000000 Logging */
	MAV_SYS_STATUS_LOGGING MavSysStatusSensor = 16777216

	/* 0x2000000 Battery */
	MAV_SYS_STATUS_SENSOR_BATTERY MavSysStatusSensor = 33554432

	/* 0x4000000 Proximity */
	MAV_SYS_STATUS_SENSOR_PROXIMITY MavSysStatusSensor = 67108864

	/* 0x8000000 Satellite Communication  */
	MAV_SYS_STATUS_SENSOR_SATCOM MavSysStatusSensor = 134217728
)

type MavFrame uint32

const (
	/* Global (WGS84) coordinate frame + MSL altitude. First value / x: latitude, second value / y: longitude, third value / z: positive altitude over mean sea level (MSL). */
	MAV_FRAME_GLOBAL MavFrame = 0

	/* Local coordinate frame, Z-down (x: north, y: east, z: down). */
	MAV_FRAME_LOCAL_NED MavFrame = 1

	/* NOT a coordinate frame, indicates a mission command. */
	MAV_FRAME_MISSION MavFrame = 2

	/* Global (WGS84) coordinate frame + altitude relative to the home position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude with 0 being at the altitude of the home location. */
	MAV_FRAME_GLOBAL_RELATIVE_ALT MavFrame = 3

	/* Local coordinate frame, Z-up (x: east, y: north, z: up). */
	MAV_FRAME_LOCAL_ENU MavFrame = 4

	/* Global (WGS84) coordinate frame (scaled) + MSL altitude. First value / x: latitude in degrees*1.0e-7, second value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL). */
	MAV_FRAME_GLOBAL_INT MavFrame = 5

	/* Global (WGS84) coordinate frame (scaled) + altitude relative to the home position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude with 0 being at the altitude of the home location. */
	MAV_FRAME_GLOBAL_RELATIVE_ALT_INT MavFrame = 6

	/* Offset to the current local frame. Anything expressed in this frame should be added to the current local frame position. */
	MAV_FRAME_LOCAL_OFFSET_NED MavFrame = 7

	/* Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right. */
	MAV_FRAME_BODY_NED MavFrame = 8

	/* Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an obstacle - e.g. useful to command 2 m/s^2 acceleration to the east. */
	MAV_FRAME_BODY_OFFSET_NED MavFrame = 9

	/* Global (WGS84) coordinate frame with AGL altitude (at the waypoint coordinate). First value / x: latitude in degrees, second value / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level in terrain model. */
	MAV_FRAME_GLOBAL_TERRAIN_ALT MavFrame = 10

	/* Global (WGS84) coordinate frame (scaled) with AGL altitude (at the waypoint coordinate). First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground level in terrain model. */
	MAV_FRAME_GLOBAL_TERRAIN_ALT_INT MavFrame = 11

	/* Body fixed frame of reference, Z-down (x: forward, y: right, z: down). */
	MAV_FRAME_BODY_FRD MavFrame = 12

	/* Body fixed frame of reference, Z-up (x: forward, y: left, z: up). */
	MAV_FRAME_BODY_FLU MavFrame = 13

	/* Odometry local coordinate frame of data given by a motion capture system, Z-down (x: north, y: east, z: down). */
	MAV_FRAME_MOCAP_NED MavFrame = 14

	/* Odometry local coordinate frame of data given by a motion capture system, Z-up (x: east, y: north, z: up). */
	MAV_FRAME_MOCAP_ENU MavFrame = 15

	/* Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: north, y: east, z: down). */
	MAV_FRAME_VISION_NED MavFrame = 16

	/* Odometry local coordinate frame of data given by a vision estimation system, Z-up (x: east, y: north, z: up). */
	MAV_FRAME_VISION_ENU MavFrame = 17

	/* Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: north, y: east, z: down). */
	MAV_FRAME_ESTIM_NED MavFrame = 18

	/* Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-up (x: east, y: noth, z: up). */
	MAV_FRAME_ESTIM_ENU MavFrame = 19
)

type MavlinkDataStreamType uint32

const (
	MAVLINK_DATA_STREAM_IMG_JPEG MavlinkDataStreamType = 1

	MAVLINK_DATA_STREAM_IMG_BMP MavlinkDataStreamType = 2

	MAVLINK_DATA_STREAM_IMG_RAW8U MavlinkDataStreamType = 3

	MAVLINK_DATA_STREAM_IMG_RAW32U MavlinkDataStreamType = 4

	MAVLINK_DATA_STREAM_IMG_PGM MavlinkDataStreamType = 5

	MAVLINK_DATA_STREAM_IMG_PNG MavlinkDataStreamType = 6
)

type FenceAction uint32

const (
	/* Disable fenced mode */
	FENCE_ACTION_NONE FenceAction = 0

	/* Switched to guided mode to return point (fence point 0) */
	FENCE_ACTION_GUIDED FenceAction = 1

	/* Report fence breach, but don't take action */
	FENCE_ACTION_REPORT FenceAction = 2

	/* Switched to guided mode to return point (fence point 0) with manual throttle control */
	FENCE_ACTION_GUIDED_THR_PASS FenceAction = 3

	/* Switch to RTL (return to launch) mode and head for the return point. */
	FENCE_ACTION_RTL FenceAction = 4
)

type FenceBreach uint32

const (
	/* No last fence breach */
	FENCE_BREACH_NONE FenceBreach = 0

	/* Breached minimum altitude */
	FENCE_BREACH_MINALT FenceBreach = 1

	/* Breached maximum altitude */
	FENCE_BREACH_MAXALT FenceBreach = 2

	/* Breached fence boundary */
	FENCE_BREACH_BOUNDARY FenceBreach = 3
)

/* Enumeration of possible mount operation modes */
type MavMountMode uint32

const (
	/* Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization */
	MAV_MOUNT_MODE_RETRACT MavMountMode = 0

	/* Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory. */
	MAV_MOUNT_MODE_NEUTRAL MavMountMode = 1

	/* Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization */
	MAV_MOUNT_MODE_MAVLINK_TARGETING MavMountMode = 2

	/* Load neutral position and start RC Roll,Pitch,Yaw control with stabilization */
	MAV_MOUNT_MODE_RC_TARGETING MavMountMode = 3

	/* Load neutral position and start to point to Lat,Lon,Alt */
	MAV_MOUNT_MODE_GPS_POINT MavMountMode = 4
)

/* Generalized UAVCAN node health */
type UavcanNodeHealth uint32

const (
	/* The node is functioning properly. */
	UAVCAN_NODE_HEALTH_OK UavcanNodeHealth = 0

	/* A critical parameter went out of range or the node has encountered a minor failure. */
	UAVCAN_NODE_HEALTH_WARNING UavcanNodeHealth = 1

	/* The node has encountered a major failure. */
	UAVCAN_NODE_HEALTH_ERROR UavcanNodeHealth = 2

	/* The node has suffered a fatal malfunction. */
	UAVCAN_NODE_HEALTH_CRITICAL UavcanNodeHealth = 3
)

/* Generalized UAVCAN node mode */
type UavcanNodeMode uint32

const (
	/* The node is performing its primary functions. */
	UAVCAN_NODE_MODE_OPERATIONAL UavcanNodeMode = 0

	/* The node is initializing; this mode is entered immediately after startup. */
	UAVCAN_NODE_MODE_INITIALIZATION UavcanNodeMode = 1

	/* The node is under maintenance. */
	UAVCAN_NODE_MODE_MAINTENANCE UavcanNodeMode = 2

	/* The node is in the process of updating its software. */
	UAVCAN_NODE_MODE_SOFTWARE_UPDATE UavcanNodeMode = 3

	/* The node is no longer available online. */
	UAVCAN_NODE_MODE_OFFLINE UavcanNodeMode = 7
)

/* Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data. See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the structure of the MAV_CMD entries */
type MavCmd uint32

const (
	/* Navigate to waypoint. */
	MAV_CMD_NAV_WAYPOINT MavCmd = 16

	/* Loiter around this waypoint an unlimited amount of time */
	MAV_CMD_NAV_LOITER_UNLIM MavCmd = 17

	/* Loiter around this waypoint for X turns */
	MAV_CMD_NAV_LOITER_TURNS MavCmd = 18

	/* Loiter around this waypoint for X seconds */
	MAV_CMD_NAV_LOITER_TIME MavCmd = 19

	/* Return to launch location */
	MAV_CMD_NAV_RETURN_TO_LAUNCH MavCmd = 20

	/* Land at location. */
	MAV_CMD_NAV_LAND MavCmd = 21

	/* Takeoff from ground / hand */
	MAV_CMD_NAV_TAKEOFF MavCmd = 22

	/* Land at local position (local frame only) */
	MAV_CMD_NAV_LAND_LOCAL MavCmd = 23

	/* Takeoff from local position (local frame only) */
	MAV_CMD_NAV_TAKEOFF_LOCAL MavCmd = 24

	/* Vehicle following, i.e. this waypoint represents the position of a moving vehicle */
	MAV_CMD_NAV_FOLLOW MavCmd = 25

	/* Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached. */
	MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT MavCmd = 30

	/* Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.  Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.  Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter until heading toward the next waypoint. */
	MAV_CMD_NAV_LOITER_TO_ALT MavCmd = 31

	/* Being following a target */
	MAV_CMD_DO_FOLLOW MavCmd = 32

	/* Reposition the MAV after a follow target command has been sent */
	MAV_CMD_DO_FOLLOW_REPOSITION MavCmd = 33

	/* Start orbiting on the circumference of a circle defined by the parameters. Setting any value NaN results in using defaults. */
	MAV_CMD_DO_ORBIT MavCmd = 34

	/* Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. */
	MAV_CMD_NAV_ROI MavCmd = 80

	/* Control autonomous path planning on the MAV. */
	MAV_CMD_NAV_PATHPLANNING MavCmd = 81

	/* Navigate to waypoint using a spline path. */
	MAV_CMD_NAV_SPLINE_WAYPOINT MavCmd = 82

	/* Takeoff from ground using VTOL mode, and transition to forward flight with specified heading. */
	MAV_CMD_NAV_VTOL_TAKEOFF MavCmd = 84

	/* Land using VTOL mode */
	MAV_CMD_NAV_VTOL_LAND MavCmd = 85

	/* hand control over to an external controller */
	MAV_CMD_NAV_GUIDED_ENABLE MavCmd = 92

	/* Delay the next navigation command a number of seconds or until a specified time */
	MAV_CMD_NAV_DELAY MavCmd = 93

	/* Descend and place payload. Vehicle moves to specified location, descends until it detects a hanging payload has reached the ground, and then releases the payload. If ground is not detected before the reaching the maximum descent value (param1), the command will complete without releasing the payload. */
	MAV_CMD_NAV_PAYLOAD_PLACE MavCmd = 94

	/* NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeration */
	MAV_CMD_NAV_LAST MavCmd = 95

	/* Delay mission state machine. */
	MAV_CMD_CONDITION_DELAY MavCmd = 112

	/* Ascend/descend at rate.  Delay mission state machine until desired altitude reached. */
	MAV_CMD_CONDITION_CHANGE_ALT MavCmd = 113

	/* Delay mission state machine until within desired distance of next NAV point. */
	MAV_CMD_CONDITION_DISTANCE MavCmd = 114

	/* Reach a certain target angle. */
	MAV_CMD_CONDITION_YAW MavCmd = 115

	/* NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeration */
	MAV_CMD_CONDITION_LAST MavCmd = 159

	/* Set system mode. */
	MAV_CMD_DO_SET_MODE MavCmd = 176

	/* Jump to the desired command in the mission list.  Repeat this action only the specified number of times */
	MAV_CMD_DO_JUMP MavCmd = 177

	/* Change speed and/or throttle set points. */
	MAV_CMD_DO_CHANGE_SPEED MavCmd = 178

	/* Changes the home location either to the current location or a specified location. */
	MAV_CMD_DO_SET_HOME MavCmd = 179

	/* Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter. */
	MAV_CMD_DO_SET_PARAMETER MavCmd = 180

	/* Set a relay to a condition. */
	MAV_CMD_DO_SET_RELAY MavCmd = 181

	/* Cycle a relay on and off for a desired number of cycles with a desired period. */
	MAV_CMD_DO_REPEAT_RELAY MavCmd = 182

	/* Set a servo to a desired PWM value. */
	MAV_CMD_DO_SET_SERVO MavCmd = 183

	/* Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period. */
	MAV_CMD_DO_REPEAT_SERVO MavCmd = 184

	/* Terminate flight immediately */
	MAV_CMD_DO_FLIGHTTERMINATION MavCmd = 185

	/* Change altitude set point. */
	MAV_CMD_DO_CHANGE_ALTITUDE MavCmd = 186

	/* Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will be used. The Latitude/Longitude is optional, and may be set to 0 if not needed. If specified then it will be used to help find the closest landing sequence. */
	MAV_CMD_DO_LAND_START MavCmd = 189

	/* Mission command to perform a landing from a rally point. */
	MAV_CMD_DO_RALLY_LAND MavCmd = 190

	/* Mission command to safely abort an autonomous landing. */
	MAV_CMD_DO_GO_AROUND MavCmd = 191

	/* Reposition the vehicle to a specific WGS84 global position. */
	MAV_CMD_DO_REPOSITION MavCmd = 192

	/* If in a GPS controlled position mode, hold the current position or continue. */
	MAV_CMD_DO_PAUSE_CONTINUE MavCmd = 193

	/* Set moving direction to forward or reverse. */
	MAV_CMD_DO_SET_REVERSE MavCmd = 194

	/* Sets the region of interest (ROI) to a location. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. */
	MAV_CMD_DO_SET_ROI_LOCATION MavCmd = 195

	/* Sets the region of interest (ROI) to be toward next waypoint, with optional pitch/roll/yaw offset. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. */
	MAV_CMD_DO_SET_ROI_WPNEXT_OFFSET MavCmd = 196

	/* Cancels any previous ROI command returning the vehicle/sensors to default flight characteristics. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. */
	MAV_CMD_DO_SET_ROI_NONE MavCmd = 197

	/* Control onboard camera system. */
	MAV_CMD_DO_CONTROL_VIDEO MavCmd = 200

	/* Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. */
	MAV_CMD_DO_SET_ROI MavCmd = 201

	/* Configure digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ). */
	MAV_CMD_DO_DIGICAM_CONFIGURE MavCmd = 202

	/* Control digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ). */
	MAV_CMD_DO_DIGICAM_CONTROL MavCmd = 203

	/* Mission command to configure a camera or antenna mount */
	MAV_CMD_DO_MOUNT_CONFIGURE MavCmd = 204

	/* Mission command to control a camera or antenna mount */
	MAV_CMD_DO_MOUNT_CONTROL MavCmd = 205

	/* Mission command to set camera trigger distance for this flight. The camera is triggered each time this distance is exceeded. This command can also be used to set the shutter integration time for the camera. */
	MAV_CMD_DO_SET_CAM_TRIGG_DIST MavCmd = 206

	/* Mission command to enable the geofence */
	MAV_CMD_DO_FENCE_ENABLE MavCmd = 207

	/* Mission command to trigger a parachute */
	MAV_CMD_DO_PARACHUTE MavCmd = 208

	/* Mission command to perform motor test. */
	MAV_CMD_DO_MOTOR_TEST MavCmd = 209

	/* Change to/from inverted flight. */
	MAV_CMD_DO_INVERTED_FLIGHT MavCmd = 210

	/* Sets a desired vehicle turn angle and speed change. */
	MAV_CMD_NAV_SET_YAW_SPEED MavCmd = 213

	/* Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is triggered each time this interval expires. This command can also be used to set the shutter integration time for the camera. */
	MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL MavCmd = 214

	/* Mission command to control a camera or antenna mount, using a quaternion as reference. */
	MAV_CMD_DO_MOUNT_CONTROL_QUAT MavCmd = 220

	/* set id of master controller */
	MAV_CMD_DO_GUIDED_MASTER MavCmd = 221

	/* Set limits for external control */
	MAV_CMD_DO_GUIDED_LIMITS MavCmd = 222

	/* Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine state. It is intended for vehicles with internal combustion engines */
	MAV_CMD_DO_ENGINE_CONTROL MavCmd = 223

	/* Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between). */
	MAV_CMD_DO_SET_MISSION_CURRENT MavCmd = 224

	/* NOP - This command is only used to mark the upper limit of the DO commands in the enumeration */
	MAV_CMD_DO_LAST MavCmd = 240

	/* Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature Calibration, only one sensor should be set in a single message and all others should be zero. */
	MAV_CMD_PREFLIGHT_CALIBRATION MavCmd = 241

	/* Set sensor offsets. This command will be only accepted if in pre-flight mode. */
	MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS MavCmd = 242

	/* Trigger UAVCAN config. This command will be only accepted if in pre-flight mode. */
	MAV_CMD_PREFLIGHT_UAVCAN MavCmd = 243

	/* Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode. */
	MAV_CMD_PREFLIGHT_STORAGE MavCmd = 245

	/* Request the reboot or shutdown of system components. */
	MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN MavCmd = 246

	/* Override current mission with command to pause mission, pause mission and move to position, continue/resume mission. When param 1 indicates that the mission is paused (MAV_GOTO_DO_HOLD), param 2 defines whether it holds in place or moves to another position. */
	MAV_CMD_OVERRIDE_GOTO MavCmd = 252

	/* start running a mission */
	MAV_CMD_MISSION_START MavCmd = 300

	/* Arms / Disarms a component */
	MAV_CMD_COMPONENT_ARM_DISARM MavCmd = 400

	/* Request the home position from the vehicle. */
	MAV_CMD_GET_HOME_POSITION MavCmd = 410

	/* Starts receiver pairing. */
	MAV_CMD_START_RX_PAIR MavCmd = 500

	/* Request the interval between messages for a particular MAVLink message ID */
	MAV_CMD_GET_MESSAGE_INTERVAL MavCmd = 510

	/* Set the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREAM */
	MAV_CMD_SET_MESSAGE_INTERVAL MavCmd = 511

	/* Request the target system(s) emit a single instance of a specified message (i.e. a "one-shot" version of MAV_CMD_SET_MESSAGE_INTERVAL). */
	MAV_CMD_REQUEST_MESSAGE MavCmd = 512

	/* Request MAVLink protocol version compatibility */
	MAV_CMD_REQUEST_PROTOCOL_VERSION MavCmd = 519

	/* Request autopilot capabilities */
	MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES MavCmd = 520

	/* Request camera information (CAMERA_INFORMATION). */
	MAV_CMD_REQUEST_CAMERA_INFORMATION MavCmd = 521

	/* Request camera settings (CAMERA_SETTINGS). */
	MAV_CMD_REQUEST_CAMERA_SETTINGS MavCmd = 522

	/* Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a specific component's storage. */
	MAV_CMD_REQUEST_STORAGE_INFORMATION MavCmd = 525

	/* Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the command's target_component to target a specific component's storage. */
	MAV_CMD_STORAGE_FORMAT MavCmd = 526

	/* Request camera capture status (CAMERA_CAPTURE_STATUS) */
	MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS MavCmd = 527

	/* Request flight information (FLIGHT_INFORMATION) */
	MAV_CMD_REQUEST_FLIGHT_INFORMATION MavCmd = 528

	/* Reset all camera settings to Factory Default */
	MAV_CMD_RESET_CAMERA_SETTINGS MavCmd = 529

	/* Set camera running mode. Use NaN for reserved values. GCS will send a MAV_CMD_REQUEST_VIDEO_STREAM_STATUS command after a mode change if the camera supports video streaming. */
	MAV_CMD_SET_CAMERA_MODE MavCmd = 530

	/* Set camera zoom. Camera must respond with a CAMERA_SETTINGS message (on success). Use NaN for reserved values. */
	MAV_CMD_SET_CAMERA_ZOOM MavCmd = 531

	/* Set camera focus. Camera must respond with a CAMERA_SETTINGS message (on success). Use NaN for reserved values. */
	MAV_CMD_SET_CAMERA_FOCUS MavCmd = 532

	/* Tagged jump target. Can be jumped to with MAV_CMD_DO_JUMP_TAG. */
	MAV_CMD_JUMP_TAG MavCmd = 600

	/* Jump to the matching tag in the mission list. Repeat this action for the specified number of times. A mission should contain a single matching tag for each jump. If this is not the case then a jump to a missing tag should complete the mission, and a jump where there are multiple matching tags should always select the one with the lowest mission sequence number. */
	MAV_CMD_DO_JUMP_TAG MavCmd = 601

	/* Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NaN for reserved values. */
	MAV_CMD_IMAGE_START_CAPTURE MavCmd = 2000

	/* Stop image capture sequence Use NaN for reserved values. */
	MAV_CMD_IMAGE_STOP_CAPTURE MavCmd = 2001

	/* Re-request a CAMERA_IMAGE_CAPTURE message. Use NaN for reserved values. */
	MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE MavCmd = 2002

	/* Enable or disable on-board camera triggering system. */
	MAV_CMD_DO_TRIGGER_CONTROL MavCmd = 2003

	/* Starts video capture (recording). Use NaN for reserved values. */
	MAV_CMD_VIDEO_START_CAPTURE MavCmd = 2500

	/* Stop the current video capture (recording). Use NaN for reserved values. */
	MAV_CMD_VIDEO_STOP_CAPTURE MavCmd = 2501

	/* Start video streaming */
	MAV_CMD_VIDEO_START_STREAMING MavCmd = 2502

	/* Stop the given video stream */
	MAV_CMD_VIDEO_STOP_STREAMING MavCmd = 2503

	/* Request video stream information (VIDEO_STREAM_INFORMATION) */
	MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION MavCmd = 2504

	/* Request video stream status (VIDEO_STREAM_STATUS) */
	MAV_CMD_REQUEST_VIDEO_STREAM_STATUS MavCmd = 2505

	/* Request to start streaming logging data over MAVLink (see also LOGGING_DATA message) */
	MAV_CMD_LOGGING_START MavCmd = 2510

	/* Request to stop streaming log data over MAVLink */
	MAV_CMD_LOGGING_STOP MavCmd = 2511

	MAV_CMD_AIRFRAME_CONFIGURATION MavCmd = 2520

	/* Request to start/stop transmitting over the high latency telemetry */
	MAV_CMD_CONTROL_HIGH_LATENCY MavCmd = 2600

	/* Create a panorama at the current position */
	MAV_CMD_PANORAMA_CREATE MavCmd = 2800

	/* Request VTOL transition */
	MAV_CMD_DO_VTOL_TRANSITION MavCmd = 3000

	/* Request authorization to arm the vehicle to a external entity, the arm authorizer is responsible to request all data that is needs from the vehicle before authorize or deny the request. If approved the progress of command_ack message should be set with period of time that this authorization is valid in seconds or in case it was denied it should be set with one of the reasons in ARM_AUTH_DENIED_REASON.          */
	MAV_CMD_ARM_AUTHORIZATION_REQUEST MavCmd = 3001

	/* This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocities along all three axes.                    */
	MAV_CMD_SET_GUIDED_SUBMODE_STANDARD MavCmd = 4000

	/* This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.                    */
	MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE MavCmd = 4001

	/* Delay mission state machine until gate has been reached. */
	MAV_CMD_CONDITION_GATE MavCmd = 4501

	/* Fence return point. There can only be one fence return point.          */
	MAV_CMD_NAV_FENCE_RETURN_POINT MavCmd = 5000

	/* Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.          */
	MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION MavCmd = 5001

	/* Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.          */
	MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION MavCmd = 5002

	/* Circular fence area. The vehicle must stay inside this area.          */
	MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION MavCmd = 5003

	/* Circular fence area. The vehicle must stay outside this area.          */
	MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION MavCmd = 5004

	/* Rally point. You can have multiple rally points defined.          */
	MAV_CMD_NAV_RALLY_POINT MavCmd = 5100

	/* Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN node that is online. Note that some of the response messages can be lost, which the receiver can detect easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO received earlier; if not, this command should be sent again in order to request re-transmission of the node information messages. */
	MAV_CMD_UAVCAN_GET_NODE_INFO MavCmd = 5200

	/* Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity. */
	MAV_CMD_PAYLOAD_PREPARE_DEPLOY MavCmd = 30001

	/* Control the payload deployment. */
	MAV_CMD_PAYLOAD_CONTROL_DEPLOY MavCmd = 30002

	/* User defined waypoint item. Ground Station will show the Vehicle as flying through this item. */
	MAV_CMD_WAYPOINT_USER_1 MavCmd = 31000

	/* User defined waypoint item. Ground Station will show the Vehicle as flying through this item. */
	MAV_CMD_WAYPOINT_USER_2 MavCmd = 31001

	/* User defined waypoint item. Ground Station will show the Vehicle as flying through this item. */
	MAV_CMD_WAYPOINT_USER_3 MavCmd = 31002

	/* User defined waypoint item. Ground Station will show the Vehicle as flying through this item. */
	MAV_CMD_WAYPOINT_USER_4 MavCmd = 31003

	/* User defined waypoint item. Ground Station will show the Vehicle as flying through this item. */
	MAV_CMD_WAYPOINT_USER_5 MavCmd = 31004

	/* User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. */
	MAV_CMD_SPATIAL_USER_1 MavCmd = 31005

	/* User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. */
	MAV_CMD_SPATIAL_USER_2 MavCmd = 31006

	/* User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. */
	MAV_CMD_SPATIAL_USER_3 MavCmd = 31007

	/* User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. */
	MAV_CMD_SPATIAL_USER_4 MavCmd = 31008

	/* User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. */
	MAV_CMD_SPATIAL_USER_5 MavCmd = 31009

	/* User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. */
	MAV_CMD_USER_1 MavCmd = 31010

	/* User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. */
	MAV_CMD_USER_2 MavCmd = 31011

	/* User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. */
	MAV_CMD_USER_3 MavCmd = 31012

	/* User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. */
	MAV_CMD_USER_4 MavCmd = 31013

	/* User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. */
	MAV_CMD_USER_5 MavCmd = 31014
)

/* A data stream is not a fixed set of messages, but rather a      recommendation to the autopilot software. Individual autopilots may or may not obey      the recommended messages. */
type MavDataStream uint32

const (
	/* Enable all data streams */
	MAV_DATA_STREAM_ALL MavDataStream = 0

	/* Enable IMU_RAW, GPS_RAW, GPS_STATUS packets. */
	MAV_DATA_STREAM_RAW_SENSORS MavDataStream = 1

	/* Enable GPS_STATUS, CONTROL_STATUS, AUX_STATUS */
	MAV_DATA_STREAM_EXTENDED_STATUS MavDataStream = 2

	/* Enable RC_CHANNELS_SCALED, RC_CHANNELS_RAW, SERVO_OUTPUT_RAW */
	MAV_DATA_STREAM_RC_CHANNELS MavDataStream = 3

	/* Enable ATTITUDE_CONTROLLER_OUTPUT, POSITION_CONTROLLER_OUTPUT, NAV_CONTROLLER_OUTPUT. */
	MAV_DATA_STREAM_RAW_CONTROLLER MavDataStream = 4

	/* Enable LOCAL_POSITION, GLOBAL_POSITION/GLOBAL_POSITION_INT messages. */
	MAV_DATA_STREAM_POSITION MavDataStream = 6

	/* Dependent on the autopilot */
	MAV_DATA_STREAM_EXTRA1 MavDataStream = 10

	/* Dependent on the autopilot */
	MAV_DATA_STREAM_EXTRA2 MavDataStream = 11

	/* Dependent on the autopilot */
	MAV_DATA_STREAM_EXTRA3 MavDataStream = 12
)

/* The ROI (region of interest) for the vehicle. This can be                 be used by the vehicle for camera/vehicle attitude alignment (see                 MAV_CMD_NAV_ROI). */
type MavRoi uint32

const (
	/* No region of interest. */
	MAV_ROI_NONE MavRoi = 0

	/* Point toward next waypoint, with optional pitch/roll/yaw offset. */
	MAV_ROI_WPNEXT MavRoi = 1

	/* Point toward given waypoint. */
	MAV_ROI_WPINDEX MavRoi = 2

	/* Point toward fixed location. */
	MAV_ROI_LOCATION MavRoi = 3

	/* Point toward of given id. */
	MAV_ROI_TARGET MavRoi = 4
)

/* ACK / NACK / ERROR values as a result of MAV_CMDs and for mission item transmission. */
type MavCmdAck uint32

const (
	/* Command / mission item is ok. */
	MAV_CMD_ACK_OK MavCmdAck = 1

	/* Generic error message if none of the other reasons fails or if no detailed error reporting is implemented. */
	MAV_CMD_ACK_ERR_FAIL MavCmdAck = 2

	/* The system is refusing to accept this command from this source / communication partner. */
	MAV_CMD_ACK_ERR_ACCESS_DENIED MavCmdAck = 3

	/* Command or mission item is not supported, other commands would be accepted. */
	MAV_CMD_ACK_ERR_NOT_SUPPORTED MavCmdAck = 4

	/* The coordinate frame of this command / mission item is not supported. */
	MAV_CMD_ACK_ERR_COORDINATE_FRAME_NOT_SUPPORTED MavCmdAck = 5

	/* The coordinate frame of this command is ok, but he coordinate values exceed the safety limits of this system. This is a generic error, please use the more specific error messages below if possible. */
	MAV_CMD_ACK_ERR_COORDINATES_OUT_OF_RANGE MavCmdAck = 6

	/* The X or latitude value is out of range. */
	MAV_CMD_ACK_ERR_X_LAT_OUT_OF_RANGE MavCmdAck = 7

	/* The Y or longitude value is out of range. */
	MAV_CMD_ACK_ERR_Y_LON_OUT_OF_RANGE MavCmdAck = 8

	/* The Z or altitude value is out of range. */
	MAV_CMD_ACK_ERR_Z_ALT_OUT_OF_RANGE MavCmdAck = 9
)

/* Specifies the datatype of a MAVLink parameter. */
type MavParamType uint32

const (
	/* 8-bit unsigned integer */
	MAV_PARAM_TYPE_UINT8 MavParamType = 1

	/* 8-bit signed integer */
	MAV_PARAM_TYPE_INT8 MavParamType = 2

	/* 16-bit unsigned integer */
	MAV_PARAM_TYPE_UINT16 MavParamType = 3

	/* 16-bit signed integer */
	MAV_PARAM_TYPE_INT16 MavParamType = 4

	/* 32-bit unsigned integer */
	MAV_PARAM_TYPE_UINT32 MavParamType = 5

	/* 32-bit signed integer */
	MAV_PARAM_TYPE_INT32 MavParamType = 6

	/* 64-bit unsigned integer */
	MAV_PARAM_TYPE_UINT64 MavParamType = 7

	/* 64-bit signed integer */
	MAV_PARAM_TYPE_INT64 MavParamType = 8

	/* 32-bit floating-point */
	MAV_PARAM_TYPE_REAL32 MavParamType = 9

	/* 64-bit floating-point */
	MAV_PARAM_TYPE_REAL64 MavParamType = 10
)

/* Specifies the datatype of a MAVLink extended parameter. */
type MavParamExtType uint32

const (
	/* 8-bit unsigned integer */
	MAV_PARAM_EXT_TYPE_UINT8 MavParamExtType = 1

	/* 8-bit signed integer */
	MAV_PARAM_EXT_TYPE_INT8 MavParamExtType = 2

	/* 16-bit unsigned integer */
	MAV_PARAM_EXT_TYPE_UINT16 MavParamExtType = 3

	/* 16-bit signed integer */
	MAV_PARAM_EXT_TYPE_INT16 MavParamExtType = 4

	/* 32-bit unsigned integer */
	MAV_PARAM_EXT_TYPE_UINT32 MavParamExtType = 5

	/* 32-bit signed integer */
	MAV_PARAM_EXT_TYPE_INT32 MavParamExtType = 6

	/* 64-bit unsigned integer */
	MAV_PARAM_EXT_TYPE_UINT64 MavParamExtType = 7

	/* 64-bit signed integer */
	MAV_PARAM_EXT_TYPE_INT64 MavParamExtType = 8

	/* 32-bit floating-point */
	MAV_PARAM_EXT_TYPE_REAL32 MavParamExtType = 9

	/* 64-bit floating-point */
	MAV_PARAM_EXT_TYPE_REAL64 MavParamExtType = 10

	/* Custom Type */
	MAV_PARAM_EXT_TYPE_CUSTOM MavParamExtType = 11
)

/* result from a mavlink command */
type MavResult uint32

const (
	/* Command ACCEPTED and EXECUTED */
	MAV_RESULT_ACCEPTED MavResult = 0

	/* Command TEMPORARY REJECTED/DENIED */
	MAV_RESULT_TEMPORARILY_REJECTED MavResult = 1

	/* Command PERMANENTLY DENIED */
	MAV_RESULT_DENIED MavResult = 2

	/* Command UNKNOWN/UNSUPPORTED */
	MAV_RESULT_UNSUPPORTED MavResult = 3

	/* Command executed, but failed */
	MAV_RESULT_FAILED MavResult = 4

	/* WIP: Command being executed */
	MAV_RESULT_IN_PROGRESS MavResult = 5
)

/* Result of mission operation (in a MISSION_ACK message). */
type MavMissionResult uint32

const (
	/* mission accepted OK */
	MAV_MISSION_ACCEPTED MavMissionResult = 0

	/* Generic error / not accepting mission commands at all right now. */
	MAV_MISSION_ERROR MavMissionResult = 1

	/* Coordinate frame is not supported. */
	MAV_MISSION_UNSUPPORTED_FRAME MavMissionResult = 2

	/* Command is not supported. */
	MAV_MISSION_UNSUPPORTED MavMissionResult = 3

	/* Mission item exceeds storage space. */
	MAV_MISSION_NO_SPACE MavMissionResult = 4

	/* One of the parameters has an invalid value. */
	MAV_MISSION_INVALID MavMissionResult = 5

	/* param1 has an invalid value. */
	MAV_MISSION_INVALID_PARAM1 MavMissionResult = 6

	/* param2 has an invalid value. */
	MAV_MISSION_INVALID_PARAM2 MavMissionResult = 7

	/* param3 has an invalid value. */
	MAV_MISSION_INVALID_PARAM3 MavMissionResult = 8

	/* param4 has an invalid value. */
	MAV_MISSION_INVALID_PARAM4 MavMissionResult = 9

	/* x / param5 has an invalid value. */
	MAV_MISSION_INVALID_PARAM5_X MavMissionResult = 10

	/* y / param6 has an invalid value. */
	MAV_MISSION_INVALID_PARAM6_Y MavMissionResult = 11

	/* z / param7 has an invalid value. */
	MAV_MISSION_INVALID_PARAM7 MavMissionResult = 12

	/* Mission item received out of sequence */
	MAV_MISSION_INVALID_SEQUENCE MavMissionResult = 13

	/* Not accepting any mission commands from this communication partner. */
	MAV_MISSION_DENIED MavMissionResult = 14

	/* Current mission operation cancelled (e.g. mission upload, mission download). */
	MAV_MISSION_OPERATION_CANCELLED MavMissionResult = 15
)

/* Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: http://www.kiwisyslog.com/kb/info:-syslog-message-levels/. */
type MavSeverity uint32

const (
	/* System is unusable. This is a "panic" condition. */
	MAV_SEVERITY_EMERGENCY MavSeverity = 0

	/* Action should be taken immediately. Indicates error in non-critical systems. */
	MAV_SEVERITY_ALERT MavSeverity = 1

	/* Action must be taken immediately. Indicates failure in a primary system. */
	MAV_SEVERITY_CRITICAL MavSeverity = 2

	/* Indicates an error in secondary/redundant systems. */
	MAV_SEVERITY_ERROR MavSeverity = 3

	/* Indicates about a possible future error if this is not resolved within a given timeframe. Example would be a low battery warning. */
	MAV_SEVERITY_WARNING MavSeverity = 4

	/* An unusual event has occurred, though not an error condition. This should be investigated for the root cause. */
	MAV_SEVERITY_NOTICE MavSeverity = 5

	/* Normal operational messages. Useful for logging. No action is required for these messages. */
	MAV_SEVERITY_INFO MavSeverity = 6

	/* Useful non-operational messages that can assist in debugging. These should not occur during normal operation. */
	MAV_SEVERITY_DEBUG MavSeverity = 7
)

/* Power supply status flags (bitmask) */
type MavPowerStatus uint32

const (
	/* main brick power supply valid */
	MAV_POWER_STATUS_BRICK_VALID MavPowerStatus = 1

	/* main servo power supply valid for FMU */
	MAV_POWER_STATUS_SERVO_VALID MavPowerStatus = 2

	/* USB power is connected */
	MAV_POWER_STATUS_USB_CONNECTED MavPowerStatus = 4

	/* peripheral supply is in over-current state */
	MAV_POWER_STATUS_PERIPH_OVERCURRENT MavPowerStatus = 8

	/* hi-power peripheral supply is in over-current state */
	MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT MavPowerStatus = 16

	/* Power status has changed since boot */
	MAV_POWER_STATUS_CHANGED MavPowerStatus = 32
)

/* SERIAL_CONTROL device types */
type SerialControlDev uint32

const (
	/* First telemetry port */
	SERIAL_CONTROL_DEV_TELEM1 SerialControlDev = 0

	/* Second telemetry port */
	SERIAL_CONTROL_DEV_TELEM2 SerialControlDev = 1

	/* First GPS port */
	SERIAL_CONTROL_DEV_GPS1 SerialControlDev = 2

	/* Second GPS port */
	SERIAL_CONTROL_DEV_GPS2 SerialControlDev = 3

	/* system shell */
	SERIAL_CONTROL_DEV_SHELL SerialControlDev = 10
)

/* SERIAL_CONTROL flags (bitmask) */
type SerialControlFlag uint32

const (
	/* Set if this is a reply */
	SERIAL_CONTROL_FLAG_REPLY SerialControlFlag = 1

	/* Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message */
	SERIAL_CONTROL_FLAG_RESPOND SerialControlFlag = 2

	/* Set if access to the serial port should be removed from whatever driver is currently using it, giving exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without this flag set */
	SERIAL_CONTROL_FLAG_EXCLUSIVE SerialControlFlag = 4

	/* Block on writes to the serial port */
	SERIAL_CONTROL_FLAG_BLOCKING SerialControlFlag = 8

	/* Send multiple replies until port is drained */
	SERIAL_CONTROL_FLAG_MULTI SerialControlFlag = 16
)

/* Enumeration of distance sensor types */
type MavDistanceSensor uint32

const (
	/* Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units */
	MAV_DISTANCE_SENSOR_LASER MavDistanceSensor = 0

	/* Ultrasound rangefinder, e.g. MaxBotix units */
	MAV_DISTANCE_SENSOR_ULTRASOUND MavDistanceSensor = 1

	/* Infrared rangefinder, e.g. Sharp units */
	MAV_DISTANCE_SENSOR_INFRARED MavDistanceSensor = 2

	/* Radar type, e.g. uLanding units */
	MAV_DISTANCE_SENSOR_RADAR MavDistanceSensor = 3

	/* Broken or unknown type, e.g. analog units */
	MAV_DISTANCE_SENSOR_UNKNOWN MavDistanceSensor = 4
)

/* Enumeration of sensor orientation, according to its rotations */
type MavSensorOrientation uint32

const (
	/* Roll: 0, Pitch: 0, Yaw: 0 */
	MAV_SENSOR_ROTATION_NONE MavSensorOrientation = 0

	/* Roll: 0, Pitch: 0, Yaw: 45 */
	MAV_SENSOR_ROTATION_YAW_45 MavSensorOrientation = 1

	/* Roll: 0, Pitch: 0, Yaw: 90 */
	MAV_SENSOR_ROTATION_YAW_90 MavSensorOrientation = 2

	/* Roll: 0, Pitch: 0, Yaw: 135 */
	MAV_SENSOR_ROTATION_YAW_135 MavSensorOrientation = 3

	/* Roll: 0, Pitch: 0, Yaw: 180 */
	MAV_SENSOR_ROTATION_YAW_180 MavSensorOrientation = 4

	/* Roll: 0, Pitch: 0, Yaw: 225 */
	MAV_SENSOR_ROTATION_YAW_225 MavSensorOrientation = 5

	/* Roll: 0, Pitch: 0, Yaw: 270 */
	MAV_SENSOR_ROTATION_YAW_270 MavSensorOrientation = 6

	/* Roll: 0, Pitch: 0, Yaw: 315 */
	MAV_SENSOR_ROTATION_YAW_315 MavSensorOrientation = 7

	/* Roll: 180, Pitch: 0, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_180 MavSensorOrientation = 8

	/* Roll: 180, Pitch: 0, Yaw: 45 */
	MAV_SENSOR_ROTATION_ROLL_180_YAW_45 MavSensorOrientation = 9

	/* Roll: 180, Pitch: 0, Yaw: 90 */
	MAV_SENSOR_ROTATION_ROLL_180_YAW_90 MavSensorOrientation = 10

	/* Roll: 180, Pitch: 0, Yaw: 135 */
	MAV_SENSOR_ROTATION_ROLL_180_YAW_135 MavSensorOrientation = 11

	/* Roll: 0, Pitch: 180, Yaw: 0 */
	MAV_SENSOR_ROTATION_PITCH_180 MavSensorOrientation = 12

	/* Roll: 180, Pitch: 0, Yaw: 225 */
	MAV_SENSOR_ROTATION_ROLL_180_YAW_225 MavSensorOrientation = 13

	/* Roll: 180, Pitch: 0, Yaw: 270 */
	MAV_SENSOR_ROTATION_ROLL_180_YAW_270 MavSensorOrientation = 14

	/* Roll: 180, Pitch: 0, Yaw: 315 */
	MAV_SENSOR_ROTATION_ROLL_180_YAW_315 MavSensorOrientation = 15

	/* Roll: 90, Pitch: 0, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_90 MavSensorOrientation = 16

	/* Roll: 90, Pitch: 0, Yaw: 45 */
	MAV_SENSOR_ROTATION_ROLL_90_YAW_45 MavSensorOrientation = 17

	/* Roll: 90, Pitch: 0, Yaw: 90 */
	MAV_SENSOR_ROTATION_ROLL_90_YAW_90 MavSensorOrientation = 18

	/* Roll: 90, Pitch: 0, Yaw: 135 */
	MAV_SENSOR_ROTATION_ROLL_90_YAW_135 MavSensorOrientation = 19

	/* Roll: 270, Pitch: 0, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_270 MavSensorOrientation = 20

	/* Roll: 270, Pitch: 0, Yaw: 45 */
	MAV_SENSOR_ROTATION_ROLL_270_YAW_45 MavSensorOrientation = 21

	/* Roll: 270, Pitch: 0, Yaw: 90 */
	MAV_SENSOR_ROTATION_ROLL_270_YAW_90 MavSensorOrientation = 22

	/* Roll: 270, Pitch: 0, Yaw: 135 */
	MAV_SENSOR_ROTATION_ROLL_270_YAW_135 MavSensorOrientation = 23

	/* Roll: 0, Pitch: 90, Yaw: 0 */
	MAV_SENSOR_ROTATION_PITCH_90 MavSensorOrientation = 24

	/* Roll: 0, Pitch: 270, Yaw: 0 */
	MAV_SENSOR_ROTATION_PITCH_270 MavSensorOrientation = 25

	/* Roll: 0, Pitch: 180, Yaw: 90 */
	MAV_SENSOR_ROTATION_PITCH_180_YAW_90 MavSensorOrientation = 26

	/* Roll: 0, Pitch: 180, Yaw: 270 */
	MAV_SENSOR_ROTATION_PITCH_180_YAW_270 MavSensorOrientation = 27

	/* Roll: 90, Pitch: 90, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_90_PITCH_90 MavSensorOrientation = 28

	/* Roll: 180, Pitch: 90, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_180_PITCH_90 MavSensorOrientation = 29

	/* Roll: 270, Pitch: 90, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_270_PITCH_90 MavSensorOrientation = 30

	/* Roll: 90, Pitch: 180, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_90_PITCH_180 MavSensorOrientation = 31

	/* Roll: 270, Pitch: 180, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_270_PITCH_180 MavSensorOrientation = 32

	/* Roll: 90, Pitch: 270, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_90_PITCH_270 MavSensorOrientation = 33

	/* Roll: 180, Pitch: 270, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_180_PITCH_270 MavSensorOrientation = 34

	/* Roll: 270, Pitch: 270, Yaw: 0 */
	MAV_SENSOR_ROTATION_ROLL_270_PITCH_270 MavSensorOrientation = 35

	/* Roll: 90, Pitch: 180, Yaw: 90 */
	MAV_SENSOR_ROTATION_ROLL_90_PITCH_180_YAW_90 MavSensorOrientation = 36

	/* Roll: 90, Pitch: 0, Yaw: 270 */
	MAV_SENSOR_ROTATION_ROLL_90_YAW_270 MavSensorOrientation = 37

	/* Roll: 90, Pitch: 68, Yaw: 293 */
	MAV_SENSOR_ROTATION_ROLL_90_PITCH_68_YAW_293 MavSensorOrientation = 38

	/* Pitch: 315 */
	MAV_SENSOR_ROTATION_PITCH_315 MavSensorOrientation = 39

	/* Roll: 90, Pitch: 315 */
	MAV_SENSOR_ROTATION_ROLL_90_PITCH_315 MavSensorOrientation = 40

	/* Custom orientation */
	MAV_SENSOR_ROTATION_CUSTOM MavSensorOrientation = 100
)

/* Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability. */
type MavProtocolCapability uint32

const (
	/* Autopilot supports MISSION float message type. */
	MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT MavProtocolCapability = 1

	/* Autopilot supports the new param float message type. */
	MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT MavProtocolCapability = 2

	/* Autopilot supports MISSION_INT scaled integer message type. */
	MAV_PROTOCOL_CAPABILITY_MISSION_INT MavProtocolCapability = 4

	/* Autopilot supports COMMAND_INT scaled integer message type. */
	MAV_PROTOCOL_CAPABILITY_COMMAND_INT MavProtocolCapability = 8

	/* Autopilot supports the new param union message type. */
	MAV_PROTOCOL_CAPABILITY_PARAM_UNION MavProtocolCapability = 16

	/* Autopilot supports the new FILE_TRANSFER_PROTOCOL message type. */
	MAV_PROTOCOL_CAPABILITY_FTP MavProtocolCapability = 32

	/* Autopilot supports commanding attitude offboard. */
	MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET MavProtocolCapability = 64

	/* Autopilot supports commanding position and velocity targets in local NED frame. */
	MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED MavProtocolCapability = 128

	/* Autopilot supports commanding position and velocity targets in global scaled integers. */
	MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT MavProtocolCapability = 256

	/* Autopilot supports terrain protocol / data handling. */
	MAV_PROTOCOL_CAPABILITY_TERRAIN MavProtocolCapability = 512

	/* Autopilot supports direct actuator control. */
	MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET MavProtocolCapability = 1024

	/* Autopilot supports the flight termination command. */
	MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION MavProtocolCapability = 2048

	/* Autopilot supports onboard compass calibration. */
	MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION MavProtocolCapability = 4096

	/* Autopilot supports MAVLink version 2. */
	MAV_PROTOCOL_CAPABILITY_MAVLINK2 MavProtocolCapability = 8192

	/* Autopilot supports mission fence protocol. */
	MAV_PROTOCOL_CAPABILITY_MISSION_FENCE MavProtocolCapability = 16384

	/* Autopilot supports mission rally point protocol. */
	MAV_PROTOCOL_CAPABILITY_MISSION_RALLY MavProtocolCapability = 32768

	/* Autopilot supports the flight information protocol. */
	MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION MavProtocolCapability = 65536
)

/* Type of mission items being requested/sent in mission protocol. */
type MavMissionType uint32

const (
	/* Items are mission commands for main mission. */
	MAV_MISSION_TYPE_MISSION MavMissionType = 0

	/* Specifies GeoFence area(s). Items are MAV_CMD_NAV_FENCE_ GeoFence items. */
	MAV_MISSION_TYPE_FENCE MavMissionType = 1

	/* Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_NAV_RALLY_POINT rally point items. */
	MAV_MISSION_TYPE_RALLY MavMissionType = 2

	/* Only used in MISSION_CLEAR_ALL to clear all mission types. */
	MAV_MISSION_TYPE_ALL MavMissionType = 255
)

/* Enumeration of estimator types */
type MavEstimatorType uint32

const (
	/* This is a naive estimator without any real covariance feedback. */
	MAV_ESTIMATOR_TYPE_NAIVE MavEstimatorType = 1

	/* Computer vision based estimate. Might be up to scale. */
	MAV_ESTIMATOR_TYPE_VISION MavEstimatorType = 2

	/* Visual-inertial estimate. */
	MAV_ESTIMATOR_TYPE_VIO MavEstimatorType = 3

	/* Plain GPS estimate. */
	MAV_ESTIMATOR_TYPE_GPS MavEstimatorType = 4

	/* Estimator integrating GPS and inertial sensing. */
	MAV_ESTIMATOR_TYPE_GPS_INS MavEstimatorType = 5
)

/* Enumeration of battery types */
type MavBatteryType uint32

const (
	/* Not specified. */
	MAV_BATTERY_TYPE_UNKNOWN MavBatteryType = 0

	/* Lithium polymer battery */
	MAV_BATTERY_TYPE_LIPO MavBatteryType = 1

	/* Lithium-iron-phosphate battery */
	MAV_BATTERY_TYPE_LIFE MavBatteryType = 2

	/* Lithium-ION battery */
	MAV_BATTERY_TYPE_LION MavBatteryType = 3

	/* Nickel metal hydride battery */
	MAV_BATTERY_TYPE_NIMH MavBatteryType = 4
)

/* Enumeration of battery functions */
type MavBatteryFunction uint32

const (
	/* Battery function is unknown */
	MAV_BATTERY_FUNCTION_UNKNOWN MavBatteryFunction = 0

	/* Battery supports all flight systems */
	MAV_BATTERY_FUNCTION_ALL MavBatteryFunction = 1

	/* Battery for the propulsion system */
	MAV_BATTERY_FUNCTION_PROPULSION MavBatteryFunction = 2

	/* Avionics battery */
	MAV_BATTERY_FUNCTION_AVIONICS MavBatteryFunction = 3

	/* Payload battery */
	MAV_BATTERY_TYPE_PAYLOAD MavBatteryFunction = 4
)

/* Enumeration for battery charge states. */
type MavBatteryChargeState uint32

const (
	/* Low battery state is not provided */
	MAV_BATTERY_CHARGE_STATE_UNDEFINED MavBatteryChargeState = 0

	/* Battery is not in low state. Normal operation. */
	MAV_BATTERY_CHARGE_STATE_OK MavBatteryChargeState = 1

	/* Battery state is low, warn and monitor close. */
	MAV_BATTERY_CHARGE_STATE_LOW MavBatteryChargeState = 2

	/* Battery state is critical, return or abort immediately. */
	MAV_BATTERY_CHARGE_STATE_CRITICAL MavBatteryChargeState = 3

	/* Battery state is too low for ordinary abort sequence. Perform fastest possible emergency stop to prevent damage. */
	MAV_BATTERY_CHARGE_STATE_EMERGENCY MavBatteryChargeState = 4

	/* Battery failed, damage unavoidable. */
	MAV_BATTERY_CHARGE_STATE_FAILED MavBatteryChargeState = 5

	/* Battery is diagnosed to be defective or an error occurred, usage is discouraged / prohibited. */
	MAV_BATTERY_CHARGE_STATE_UNHEALTHY MavBatteryChargeState = 6

	/* Battery is charging. */
	MAV_BATTERY_CHARGE_STATE_CHARGING MavBatteryChargeState = 7
)

/* Smart battery supply status/fault flags (bitmask) for health indication. */
type MavSmartBatteryFault uint32

const (
	/* Battery has deep discharged. */
	MAV_SMART_BATTERY_FAULT_DEEP_DISCHARGE MavSmartBatteryFault = 1

	/* Voltage spikes. */
	MAV_SMART_BATTERY_FAULT_SPIKES MavSmartBatteryFault = 2

	/* Single cell has failed. */
	MAV_SMART_BATTERY_FAULT_SINGLE_CELL_FAIL MavSmartBatteryFault = 4

	/* Over-current fault. */
	MAV_SMART_BATTERY_FAULT_OVER_CURRENT MavSmartBatteryFault = 8

	/* Over-temperature fault. */
	MAV_SMART_BATTERY_FAULT_OVER_TEMPERATURE MavSmartBatteryFault = 16

	/* Under-temperature fault. */
	MAV_SMART_BATTERY_FAULT_UNDER_TEMPERATURE MavSmartBatteryFault = 32
)

/* Enumeration of VTOL states */
type MavVtolState uint32

const (
	/* MAV is not configured as VTOL */
	MAV_VTOL_STATE_UNDEFINED MavVtolState = 0

	/* VTOL is in transition from multicopter to fixed-wing */
	MAV_VTOL_STATE_TRANSITION_TO_FW MavVtolState = 1

	/* VTOL is in transition from fixed-wing to multicopter */
	MAV_VTOL_STATE_TRANSITION_TO_MC MavVtolState = 2

	/* VTOL is in multicopter state */
	MAV_VTOL_STATE_MC MavVtolState = 3

	/* VTOL is in fixed-wing state */
	MAV_VTOL_STATE_FW MavVtolState = 4
)

/* Enumeration of landed detector states */
type MavLandedState uint32

const (
	/* MAV landed state is unknown */
	MAV_LANDED_STATE_UNDEFINED MavLandedState = 0

	/* MAV is landed (on ground) */
	MAV_LANDED_STATE_ON_GROUND MavLandedState = 1

	/* MAV is in air */
	MAV_LANDED_STATE_IN_AIR MavLandedState = 2

	/* MAV currently taking off */
	MAV_LANDED_STATE_TAKEOFF MavLandedState = 3

	/* MAV currently landing */
	MAV_LANDED_STATE_LANDING MavLandedState = 4
)

/* Enumeration of the ADSB altimeter types */
type AdsbAltitudeType uint32

const (
	/* Altitude reported from a Baro source using QNH reference */
	ADSB_ALTITUDE_TYPE_PRESSURE_QNH AdsbAltitudeType = 0

	/* Altitude reported from a GNSS source */
	ADSB_ALTITUDE_TYPE_GEOMETRIC AdsbAltitudeType = 1
)

/* ADSB classification for the type of vehicle emitting the transponder signal */
type AdsbEmitterType uint32

const (
	ADSB_EMITTER_TYPE_NO_INFO AdsbEmitterType = 0

	ADSB_EMITTER_TYPE_LIGHT AdsbEmitterType = 1

	ADSB_EMITTER_TYPE_SMALL AdsbEmitterType = 2

	ADSB_EMITTER_TYPE_LARGE AdsbEmitterType = 3

	ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE AdsbEmitterType = 4

	ADSB_EMITTER_TYPE_HEAVY AdsbEmitterType = 5

	ADSB_EMITTER_TYPE_HIGHLY_MANUV AdsbEmitterType = 6

	ADSB_EMITTER_TYPE_ROTOCRAFT AdsbEmitterType = 7

	ADSB_EMITTER_TYPE_UNASSIGNED AdsbEmitterType = 8

	ADSB_EMITTER_TYPE_GLIDER AdsbEmitterType = 9

	ADSB_EMITTER_TYPE_LIGHTER_AIR AdsbEmitterType = 10

	ADSB_EMITTER_TYPE_PARACHUTE AdsbEmitterType = 11

	ADSB_EMITTER_TYPE_ULTRA_LIGHT AdsbEmitterType = 12

	ADSB_EMITTER_TYPE_UNASSIGNED2 AdsbEmitterType = 13

	ADSB_EMITTER_TYPE_UAV AdsbEmitterType = 14

	ADSB_EMITTER_TYPE_SPACE AdsbEmitterType = 15

	ADSB_EMITTER_TYPE_UNASSGINED3 AdsbEmitterType = 16

	ADSB_EMITTER_TYPE_EMERGENCY_SURFACE AdsbEmitterType = 17

	ADSB_EMITTER_TYPE_SERVICE_SURFACE AdsbEmitterType = 18

	ADSB_EMITTER_TYPE_POINT_OBSTACLE AdsbEmitterType = 19
)

/* These flags indicate status such as data validity of each data source. Set = data valid */
type AdsbFlags uint32

const (
	ADSB_FLAGS_VALID_COORDS AdsbFlags = 1

	ADSB_FLAGS_VALID_ALTITUDE AdsbFlags = 2

	ADSB_FLAGS_VALID_HEADING AdsbFlags = 4

	ADSB_FLAGS_VALID_VELOCITY AdsbFlags = 8

	ADSB_FLAGS_VALID_CALLSIGN AdsbFlags = 16

	ADSB_FLAGS_VALID_SQUAWK AdsbFlags = 32

	ADSB_FLAGS_SIMULATED AdsbFlags = 64
)

/* Bitmap of options for the MAV_CMD_DO_REPOSITION */
type MavDoRepositionFlags uint32

const (
	/* The aircraft should immediately transition into guided. This should not be set for follow me applications */
	MAV_DO_REPOSITION_FLAGS_CHANGE_MODE MavDoRepositionFlags = 1
)

/* Flags in EKF_STATUS message */
type EstimatorStatusFlags uint32

const (
	/* True if the attitude estimate is good */
	ESTIMATOR_ATTITUDE EstimatorStatusFlags = 1

	/* True if the horizontal velocity estimate is good */
	ESTIMATOR_VELOCITY_HORIZ EstimatorStatusFlags = 2

	/* True if the  vertical velocity estimate is good */
	ESTIMATOR_VELOCITY_VERT EstimatorStatusFlags = 4

	/* True if the horizontal position (relative) estimate is good */
	ESTIMATOR_POS_HORIZ_REL EstimatorStatusFlags = 8

	/* True if the horizontal position (absolute) estimate is good */
	ESTIMATOR_POS_HORIZ_ABS EstimatorStatusFlags = 16

	/* True if the vertical position (absolute) estimate is good */
	ESTIMATOR_POS_VERT_ABS EstimatorStatusFlags = 32

	/* True if the vertical position (above ground) estimate is good */
	ESTIMATOR_POS_VERT_AGL EstimatorStatusFlags = 64

	/* True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical flow) */
	ESTIMATOR_CONST_POS_MODE EstimatorStatusFlags = 128

	/* True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimate */
	ESTIMATOR_PRED_POS_HORIZ_REL EstimatorStatusFlags = 256

	/* True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimate */
	ESTIMATOR_PRED_POS_HORIZ_ABS EstimatorStatusFlags = 512

	/* True if the EKF has detected a GPS glitch */
	ESTIMATOR_GPS_GLITCH EstimatorStatusFlags = 1024

	/* True if the EKF has detected bad accelerometer data */
	ESTIMATOR_ACCEL_ERROR EstimatorStatusFlags = 2048
)

type MotorTestOrder uint32

const (
	/* default autopilot motor test method */
	MOTOR_TEST_ORDER_DEFAULT MotorTestOrder = 0

	/* motor numbers are specified as their index in a predefined vehicle-specific sequence */
	MOTOR_TEST_ORDER_SEQUENCE MotorTestOrder = 1

	/* motor numbers are specified as the output as labeled on the board */
	MOTOR_TEST_ORDER_BOARD MotorTestOrder = 2
)

type MotorTestThrottleType uint32

const (
	/* throttle as a percentage from 0 ~ 100 */
	MOTOR_TEST_THROTTLE_PERCENT MotorTestThrottleType = 0

	/* throttle as an absolute PWM value (normally in range of 1000~2000) */
	MOTOR_TEST_THROTTLE_PWM MotorTestThrottleType = 1

	/* throttle pass-through from pilot's transmitter */
	MOTOR_TEST_THROTTLE_PILOT MotorTestThrottleType = 2

	/* per-motor compass calibration test */
	MOTOR_TEST_COMPASS_CAL MotorTestThrottleType = 3
)

type GpsInputIgnoreFlags uint32

const (
	/* ignore altitude field */
	GPS_INPUT_IGNORE_FLAG_ALT GpsInputIgnoreFlags = 1

	/* ignore hdop field */
	GPS_INPUT_IGNORE_FLAG_HDOP GpsInputIgnoreFlags = 2

	/* ignore vdop field */
	GPS_INPUT_IGNORE_FLAG_VDOP GpsInputIgnoreFlags = 4

	/* ignore horizontal velocity field (vn and ve) */
	GPS_INPUT_IGNORE_FLAG_VEL_HORIZ GpsInputIgnoreFlags = 8

	/* ignore vertical velocity field (vd) */
	GPS_INPUT_IGNORE_FLAG_VEL_VERT GpsInputIgnoreFlags = 16

	/* ignore speed accuracy field */
	GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY GpsInputIgnoreFlags = 32

	/* ignore horizontal accuracy field */
	GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY GpsInputIgnoreFlags = 64

	/* ignore vertical accuracy field */
	GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY GpsInputIgnoreFlags = 128
)

/* Possible actions an aircraft can take to avoid a collision. */
type MavCollisionAction uint32

const (
	/* Ignore any potential collisions */
	MAV_COLLISION_ACTION_NONE MavCollisionAction = 0

	/* Report potential collision */
	MAV_COLLISION_ACTION_REPORT MavCollisionAction = 1

	/* Ascend or Descend to avoid threat */
	MAV_COLLISION_ACTION_ASCEND_OR_DESCEND MavCollisionAction = 2

	/* Move horizontally to avoid threat */
	MAV_COLLISION_ACTION_MOVE_HORIZONTALLY MavCollisionAction = 3

	/* Aircraft to move perpendicular to the collision's velocity vector */
	MAV_COLLISION_ACTION_MOVE_PERPENDICULAR MavCollisionAction = 4

	/* Aircraft to fly directly back to its launch point */
	MAV_COLLISION_ACTION_RTL MavCollisionAction = 5

	/* Aircraft to stop in place */
	MAV_COLLISION_ACTION_HOVER MavCollisionAction = 6
)

/* Aircraft-rated danger from this threat. */
type MavCollisionThreatLevel uint32

const (
	/* Not a threat */
	MAV_COLLISION_THREAT_LEVEL_NONE MavCollisionThreatLevel = 0

	/* Craft is mildly concerned about this threat */
	MAV_COLLISION_THREAT_LEVEL_LOW MavCollisionThreatLevel = 1

	/* Craft is panicking, and may take actions to avoid threat */
	MAV_COLLISION_THREAT_LEVEL_HIGH MavCollisionThreatLevel = 2
)

/* Source of information about this collision. */
type MavCollisionSrc uint32

const (
	/* ID field references ADSB_VEHICLE packets */
	MAV_COLLISION_SRC_ADSB MavCollisionSrc = 0

	/* ID field references MAVLink SRC ID */
	MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT MavCollisionSrc = 1
)

/* Type of GPS fix */
type GpsFixType uint32

const (
	/* No GPS connected */
	GPS_FIX_TYPE_NO_GPS GpsFixType = 0

	/* No position information, GPS is connected */
	GPS_FIX_TYPE_NO_FIX GpsFixType = 1

	/* 2D position */
	GPS_FIX_TYPE_2D_FIX GpsFixType = 2

	/* 3D position */
	GPS_FIX_TYPE_3D_FIX GpsFixType = 3

	/* DGPS/SBAS aided 3D position */
	GPS_FIX_TYPE_DGPS GpsFixType = 4

	/* RTK float, 3D position */
	GPS_FIX_TYPE_RTK_FLOAT GpsFixType = 5

	/* RTK Fixed, 3D position */
	GPS_FIX_TYPE_RTK_FIXED GpsFixType = 6

	/* Static fixed, typically used for base stations */
	GPS_FIX_TYPE_STATIC GpsFixType = 7

	/* PPP, 3D position. */
	GPS_FIX_TYPE_PPP GpsFixType = 8
)

/* RTK GPS baseline coordinate system, used for RTK corrections */
type RtkBaselineCoordinateSystem uint32

const (
	/* Earth-centered, Earth-fixed */
	RTK_BASELINE_COORDINATE_SYSTEM_ECEF RtkBaselineCoordinateSystem = 0

	/* North, East, Down */
	RTK_BASELINE_COORDINATE_SYSTEM_NED RtkBaselineCoordinateSystem = 1
)

/* Type of landing target */
type LandingTargetType uint32

const (
	/* Landing target signaled by light beacon (ex: IR-LOCK) */
	LANDING_TARGET_TYPE_LIGHT_BEACON LandingTargetType = 0

	/* Landing target signaled by radio beacon (ex: ILS, NDB) */
	LANDING_TARGET_TYPE_RADIO_BEACON LandingTargetType = 1

	/* Landing target represented by a fiducial marker (ex: ARTag) */
	LANDING_TARGET_TYPE_VISION_FIDUCIAL LandingTargetType = 2

	/* Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square) */
	LANDING_TARGET_TYPE_VISION_OTHER LandingTargetType = 3
)

/* Direction of VTOL transition */
type VtolTransitionHeading uint32

const (
	/* Respect the heading configuration of the vehicle. */
	VTOL_TRANSITION_HEADING_VEHICLE_DEFAULT VtolTransitionHeading = 0

	/* Use the heading pointing towards the next waypoint. */
	VTOL_TRANSITION_HEADING_NEXT_WAYPOINT VtolTransitionHeading = 1

	/* Use the heading on takeoff (while sitting on the ground). */
	VTOL_TRANSITION_HEADING_TAKEOFF VtolTransitionHeading = 2

	/* Use the specified heading in parameter 4. */
	VTOL_TRANSITION_HEADING_SPECIFIED VtolTransitionHeading = 3

	/* Use the current heading when reaching takeoff altitude (potentially facing the wind when weather-vaning is active). */
	VTOL_TRANSITION_HEADING_ANY VtolTransitionHeading = 4
)

/* Camera capability flags (Bitmap) */
type CameraCapFlags uint32

const (
	/* Camera is able to record video */
	CAMERA_CAP_FLAGS_CAPTURE_VIDEO CameraCapFlags = 1

	/* Camera is able to capture images */
	CAMERA_CAP_FLAGS_CAPTURE_IMAGE CameraCapFlags = 2

	/* Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE) */
	CAMERA_CAP_FLAGS_HAS_MODES CameraCapFlags = 4

	/* Camera can capture images while in video mode */
	CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE CameraCapFlags = 8

	/* Camera can capture videos while in Photo/Image mode */
	CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE CameraCapFlags = 16

	/* Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE) */
	CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE CameraCapFlags = 32

	/* Camera has basic zoom control (MAV_CMD_SET_CAMERA_ZOOM) */
	CAMERA_CAP_FLAGS_HAS_BASIC_ZOOM CameraCapFlags = 64

	/* Camera has basic focus control (MAV_CMD_SET_CAMERA_FOCUS) */
	CAMERA_CAP_FLAGS_HAS_BASIC_FOCUS CameraCapFlags = 128

	/* Camera has video streaming capabilities (use MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION for video streaming info) */
	CAMERA_CAP_FLAGS_HAS_VIDEO_STREAM CameraCapFlags = 256
)

/* Stream status flags (Bitmap) */
type VideoStreamStatusFlags uint32

const (
	/* Stream is active (running) */
	VIDEO_STREAM_STATUS_FLAGS_RUNNING VideoStreamStatusFlags = 1

	/* Stream is thermal imaging */
	VIDEO_STREAM_STATUS_FLAGS_THERMAL VideoStreamStatusFlags = 2
)

/* Video stream types */
type VideoStreamType uint32

const (
	/* Stream is RTSP */
	VIDEO_STREAM_TYPE_RTSP VideoStreamType = 0

	/* Stream is RTP UDP (URI gives the port number) */
	VIDEO_STREAM_TYPE_RTPUDP VideoStreamType = 1

	/* Stream is MPEG on TCP */
	VIDEO_STREAM_TYPE_TCP_MPEG VideoStreamType = 2

	/* Stream is h.264 on MPEG TS (URI gives the port number) */
	VIDEO_STREAM_TYPE_MPEG_TS_H264 VideoStreamType = 3
)

/* Zoom types for MAV_CMD_SET_CAMERA_ZOOM */
type CameraZoomType uint32

const (
	/* Zoom one step increment (-1 for wide, 1 for tele) */
	ZOOM_TYPE_STEP CameraZoomType = 0

	/* Continuous zoom up/down until stopped (-1 for wide, 1 for tele, 0 to stop zooming) */
	ZOOM_TYPE_CONTINUOUS CameraZoomType = 1

	/* Zoom value as proportion of full camera range (a value between 0.0 and 100.0) */
	ZOOM_TYPE_RANGE CameraZoomType = 2
)

/* Focus types for MAV_CMD_SET_CAMERA_FOCUS */
type SetFocusType uint32

const (
	/* Focus one step increment (-1 for focusing in, 1 for focusing out towards infinity). */
	FOCUS_TYPE_STEP SetFocusType = 0

	/* Continuous focus up/down until stopped (-1 for focusing in, 1 for focusing out towards infinity, 0 to stop focusing) */
	FOCUS_TYPE_CONTINUOUS SetFocusType = 1

	/* Zoom value as proportion of full camera range (a value between 0.0 and 100.0) */
	FOCUS_TYPE_RANGE SetFocusType = 2
)

/* Result from a PARAM_EXT_SET message. */
type ParamAck uint32

const (
	/* Parameter value ACCEPTED and SET */
	PARAM_ACK_ACCEPTED ParamAck = 0

	/* Parameter value UNKNOWN/UNSUPPORTED */
	PARAM_ACK_VALUE_UNSUPPORTED ParamAck = 1

	/* Parameter failed to set */
	PARAM_ACK_FAILED ParamAck = 2

	/* Parameter value received but not yet validated or set. A subsequent PARAM_EXT_ACK will follow once operation is completed with the actual result. These are for parameters that may take longer to set. Instead of waiting for an ACK and potentially timing out, you will immediately receive this response to let you know it was received. */
	PARAM_ACK_IN_PROGRESS ParamAck = 3
)

/* Camera Modes. */
type CameraMode uint32

const (
	/* Camera is in image/photo capture mode. */
	CAMERA_MODE_IMAGE CameraMode = 0

	/* Camera is in video capture mode. */
	CAMERA_MODE_VIDEO CameraMode = 1

	/* Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys. */
	CAMERA_MODE_IMAGE_SURVEY CameraMode = 2
)

type MavArmAuthDeniedReason uint32

const (
	/* Not a specific reason */
	MAV_ARM_AUTH_DENIED_REASON_GENERIC MavArmAuthDeniedReason = 0

	/* Authorizer will send the error as string to GCS */
	MAV_ARM_AUTH_DENIED_REASON_NONE MavArmAuthDeniedReason = 1

	/* At least one waypoint have a invalid value */
	MAV_ARM_AUTH_DENIED_REASON_INVALID_WAYPOINT MavArmAuthDeniedReason = 2

	/* Timeout in the authorizer process(in case it depends on network) */
	MAV_ARM_AUTH_DENIED_REASON_TIMEOUT MavArmAuthDeniedReason = 3

	/* Airspace of the mission in use by another vehicle, second result parameter can have the waypoint id that caused it to be denied. */
	MAV_ARM_AUTH_DENIED_REASON_AIRSPACE_IN_USE MavArmAuthDeniedReason = 4

	/* Weather is not good to fly */
	MAV_ARM_AUTH_DENIED_REASON_BAD_WEATHER MavArmAuthDeniedReason = 5
)

/* RC type */
type RcType uint32

const (
	/* Spektrum DSM2 */
	RC_TYPE_SPEKTRUM_DSM2 RcType = 0

	/* Spektrum DSMX */
	RC_TYPE_SPEKTRUM_DSMX RcType = 1
)

/* Bitmap to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 9 is set the floats afx afy afz should be interpreted as force instead of acceleration. */
type PositionTargetTypemask uint32

const (
	/* Ignore position x */
	POSITION_TARGET_TYPEMASK_X_IGNORE PositionTargetTypemask = 1

	/* Ignore position y */
	POSITION_TARGET_TYPEMASK_Y_IGNORE PositionTargetTypemask = 2

	/* Ignore position z */
	POSITION_TARGET_TYPEMASK_Z_IGNORE PositionTargetTypemask = 4

	/* Ignore velocity x */
	POSITION_TARGET_TYPEMASK_VX_IGNORE PositionTargetTypemask = 8

	/* Ignore velocity y */
	POSITION_TARGET_TYPEMASK_VY_IGNORE PositionTargetTypemask = 16

	/* Ignore velocity z */
	POSITION_TARGET_TYPEMASK_VZ_IGNORE PositionTargetTypemask = 32

	/* Ignore acceleration x */
	POSITION_TARGET_TYPEMASK_AX_IGNORE PositionTargetTypemask = 64

	/* Ignore acceleration y */
	POSITION_TARGET_TYPEMASK_AY_IGNORE PositionTargetTypemask = 128

	/* Ignore acceleration z */
	POSITION_TARGET_TYPEMASK_AZ_IGNORE PositionTargetTypemask = 256

	/* Use force instead of acceleration */
	POSITION_TARGET_TYPEMASK_FORCE_SET PositionTargetTypemask = 512

	/* Ignore yaw */
	POSITION_TARGET_TYPEMASK_YAW_IGNORE PositionTargetTypemask = 1024

	/* Ignore yaw rate */
	POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE PositionTargetTypemask = 2048
)

/* Airborne status of UAS. */
type UtmFlightState uint32

const (
	/* The flight state can't be determined. */
	UTM_FLIGHT_STATE_UNKNOWN UtmFlightState = 1

	/* UAS on ground. */
	UTM_FLIGHT_STATE_GROUND UtmFlightState = 2

	/* UAS airborne. */
	UTM_FLIGHT_STATE_AIRBORNE UtmFlightState = 3

	/* UAS is in an emergency flight state. */
	UTM_FLIGHT_STATE_EMERGENCY UtmFlightState = 16

	/* UAS has no active controls. */
	UTM_FLIGHT_STATE_NOCTRL UtmFlightState = 32
)

/* Flags for the global position report. */
type UtmDataAvailFlags uint32

const (
	/* The field time contains valid data. */
	UTM_DATA_AVAIL_FLAGS_TIME_VALID UtmDataAvailFlags = 1

	/* The field uas_id contains valid data. */
	UTM_DATA_AVAIL_FLAGS_UAS_ID_AVAILABLE UtmDataAvailFlags = 2

	/* The fields lat, lon and h_acc contain valid data. */
	UTM_DATA_AVAIL_FLAGS_POSITION_AVAILABLE UtmDataAvailFlags = 4

	/* The fields alt and v_acc contain valid data. */
	UTM_DATA_AVAIL_FLAGS_ALTITUDE_AVAILABLE UtmDataAvailFlags = 8

	/* The field relative_alt contains valid data. */
	UTM_DATA_AVAIL_FLAGS_RELATIVE_ALTITUDE_AVAILABLE UtmDataAvailFlags = 16

	/* The fields vx and vy contain valid data. */
	UTM_DATA_AVAIL_FLAGS_HORIZONTAL_VELO_AVAILABLE UtmDataAvailFlags = 32

	/* The field vz contains valid data. */
	UTM_DATA_AVAIL_FLAGS_VERTICAL_VELO_AVAILABLE UtmDataAvailFlags = 64

	/* The fields next_lat, next_lon and next_alt contain valid data. */
	UTM_DATA_AVAIL_FLAGS_NEXT_WAYPOINT_AVAILABLE UtmDataAvailFlags = 128
)

/* Cellular network radio type */
type CellularNetworkRadioType uint32

const (
	CELLULAR_NETWORK_RADIO_TYPE_NONE CellularNetworkRadioType = 0

	CELLULAR_NETWORK_RADIO_TYPE_GSM CellularNetworkRadioType = 1

	CELLULAR_NETWORK_RADIO_TYPE_CDMA CellularNetworkRadioType = 2

	CELLULAR_NETWORK_RADIO_TYPE_WCDMA CellularNetworkRadioType = 3

	CELLULAR_NETWORK_RADIO_TYPE_LTE CellularNetworkRadioType = 4
)

/* These flags encode the cellular network status */
type CellularNetworkStatusFlag uint32

const (
	/* Roaming is active */
	CELLULAR_NETWORK_STATUS_FLAG_ROAMING CellularNetworkStatusFlag = 1
)

/* Precision land modes (used in MAV_CMD_NAV_LAND). */
type PrecisionLandMode uint32

const (
	/* Normal (non-precision) landing. */
	PRECISION_LAND_MODE_DISABLED PrecisionLandMode = 0

	/* Use precision landing if beacon detected when land command accepted, otherwise land normally. */
	PRECISION_LAND_MODE_OPPORTUNISTIC PrecisionLandMode = 1

	/* Use precision landing, searching for beacon if not found when land command accepted (land normally if beacon cannot be found). */
	PRECISION_LAND_MODE_REQUIRED PrecisionLandMode = 2
)

type ParachuteAction uint32

const (
	/* Disable parachute release. */
	PARACHUTE_DISABLE ParachuteAction = 0

	/* Enable parachute release. */
	PARACHUTE_ENABLE ParachuteAction = 1

	/* Release parachute. */
	PARACHUTE_RELEASE ParachuteAction = 2
)

// The Dialect factory function constructs the proper empty message given the message ID.
func Dialect(mid int) mavlink.Message {
	switch mid {
	case 10001:
		return &UavionixAdsbOutCfg{}
	case 10002:
		return &UavionixAdsbOutDynamic{}
	case 10003:
		return &UavionixAdsbTransceiverHealthReport{}
	case 0:
		return &Heartbeat{}
	case 1:
		return &SysStatus{}
	case 2:
		return &SystemTime{}
	case 4:
		return &Ping{}
	case 5:
		return &ChangeOperatorControl{}
	case 6:
		return &ChangeOperatorControlAck{}
	case 7:
		return &AuthKey{}
	case 11:
		return &SetMode{}
	case 20:
		return &ParamRequestRead{}
	case 21:
		return &ParamRequestList{}
	case 22:
		return &ParamValue{}
	case 23:
		return &ParamSet{}
	case 24:
		return &GpsRawInt{}
	case 25:
		return &GpsStatus{}
	case 26:
		return &ScaledImu{}
	case 27:
		return &RawImu{}
	case 28:
		return &RawPressure{}
	case 29:
		return &ScaledPressure{}
	case 30:
		return &Attitude{}
	case 31:
		return &AttitudeQuaternion{}
	case 32:
		return &LocalPositionNed{}
	case 33:
		return &GlobalPositionInt{}
	case 34:
		return &RcChannelsScaled{}
	case 35:
		return &RcChannelsRaw{}
	case 36:
		return &ServoOutputRaw{}
	case 37:
		return &MissionRequestPartialList{}
	case 38:
		return &MissionWritePartialList{}
	case 39:
		return &MissionItem{}
	case 40:
		return &MissionRequest{}
	case 41:
		return &MissionSetCurrent{}
	case 42:
		return &MissionCurrent{}
	case 43:
		return &MissionRequestList{}
	case 44:
		return &MissionCount{}
	case 45:
		return &MissionClearAll{}
	case 46:
		return &MissionItemReached{}
	case 47:
		return &MissionAck{}
	case 48:
		return &SetGpsGlobalOrigin{}
	case 49:
		return &GpsGlobalOrigin{}
	case 50:
		return &ParamMapRc{}
	case 51:
		return &MissionRequestInt{}
	case 54:
		return &SafetySetAllowedArea{}
	case 55:
		return &SafetyAllowedArea{}
	case 61:
		return &AttitudeQuaternionCov{}
	case 62:
		return &NavControllerOutput{}
	case 63:
		return &GlobalPositionIntCov{}
	case 64:
		return &LocalPositionNedCov{}
	case 65:
		return &RcChannels{}
	case 66:
		return &RequestDataStream{}
	case 67:
		return &DataStream{}
	case 69:
		return &ManualControl{}
	case 70:
		return &RcChannelsOverride{}
	case 73:
		return &MissionItemInt{}
	case 74:
		return &VfrHud{}
	case 75:
		return &CommandInt{}
	case 76:
		return &CommandLong{}
	case 77:
		return &CommandAck{}
	case 81:
		return &ManualSetpoint{}
	case 82:
		return &SetAttitudeTarget{}
	case 83:
		return &AttitudeTarget{}
	case 84:
		return &SetPositionTargetLocalNed{}
	case 85:
		return &PositionTargetLocalNed{}
	case 86:
		return &SetPositionTargetGlobalInt{}
	case 87:
		return &PositionTargetGlobalInt{}
	case 89:
		return &LocalPositionNedSystemGlobalOffset{}
	case 90:
		return &HilState{}
	case 91:
		return &HilControls{}
	case 92:
		return &HilRcInputsRaw{}
	case 93:
		return &HilActuatorControls{}
	case 100:
		return &OpticalFlow{}
	case 101:
		return &GlobalVisionPositionEstimate{}
	case 102:
		return &VisionPositionEstimate{}
	case 103:
		return &VisionSpeedEstimate{}
	case 104:
		return &ViconPositionEstimate{}
	case 105:
		return &HighresImu{}
	case 106:
		return &OpticalFlowRad{}
	case 107:
		return &HilSensor{}
	case 108:
		return &SimState{}
	case 109:
		return &RadioStatus{}
	case 110:
		return &FileTransferProtocol{}
	case 111:
		return &Timesync{}
	case 112:
		return &CameraTrigger{}
	case 113:
		return &HilGps{}
	case 114:
		return &HilOpticalFlow{}
	case 115:
		return &HilStateQuaternion{}
	case 116:
		return &ScaledImu2{}
	case 117:
		return &LogRequestList{}
	case 118:
		return &LogEntry{}
	case 119:
		return &LogRequestData{}
	case 120:
		return &LogData{}
	case 121:
		return &LogErase{}
	case 122:
		return &LogRequestEnd{}
	case 123:
		return &GpsInjectData{}
	case 124:
		return &Gps2Raw{}
	case 125:
		return &PowerStatus{}
	case 126:
		return &SerialControl{}
	case 127:
		return &GpsRtk{}
	case 128:
		return &Gps2Rtk{}
	case 129:
		return &ScaledImu3{}
	case 130:
		return &DataTransmissionHandshake{}
	case 131:
		return &EncapsulatedData{}
	case 132:
		return &DistanceSensor{}
	case 133:
		return &TerrainRequest{}
	case 134:
		return &TerrainData{}
	case 135:
		return &TerrainCheck{}
	case 136:
		return &TerrainReport{}
	case 137:
		return &ScaledPressure2{}
	case 138:
		return &AttPosMocap{}
	case 139:
		return &SetActuatorControlTarget{}
	case 140:
		return &ActuatorControlTarget{}
	case 141:
		return &Altitude{}
	case 142:
		return &ResourceRequest{}
	case 143:
		return &ScaledPressure3{}
	case 144:
		return &FollowTarget{}
	case 146:
		return &ControlSystemState{}
	case 147:
		return &BatteryStatus{}
	case 148:
		return &AutopilotVersion{}
	case 149:
		return &LandingTarget{}
	case 230:
		return &EstimatorStatus{}
	case 231:
		return &WindCov{}
	case 232:
		return &GpsInput{}
	case 233:
		return &GpsRtcmData{}
	case 234:
		return &HighLatency{}
	case 235:
		return &HighLatency2{}
	case 241:
		return &Vibration{}
	case 242:
		return &HomePosition{}
	case 243:
		return &SetHomePosition{}
	case 244:
		return &MessageInterval{}
	case 245:
		return &ExtendedSysState{}
	case 246:
		return &AdsbVehicle{}
	case 247:
		return &Collision{}
	case 248:
		return &V2Extension{}
	case 249:
		return &MemoryVect{}
	case 250:
		return &DebugVect{}
	case 251:
		return &NamedValueFloat{}
	case 252:
		return &NamedValueInt{}
	case 253:
		return &Statustext{}
	case 254:
		return &Debug{}
	case 256:
		return &SetupSigning{}
	case 257:
		return &ButtonChange{}
	case 258:
		return &PlayTune{}
	case 259:
		return &CameraInformation{}
	case 260:
		return &CameraSettings{}
	case 261:
		return &StorageInformation{}
	case 262:
		return &CameraCaptureStatus{}
	case 263:
		return &CameraImageCaptured{}
	case 264:
		return &FlightInformation{}
	case 265:
		return &MountOrientation{}
	case 266:
		return &LoggingData{}
	case 267:
		return &LoggingDataAcked{}
	case 268:
		return &LoggingAck{}
	case 269:
		return &VideoStreamInformation{}
	case 270:
		return &VideoStreamStatus{}
	case 299:
		return &WifiConfigAp{}
	case 300:
		return &ProtocolVersion{}
	case 310:
		return &UavcanNodeStatus{}
	case 311:
		return &UavcanNodeInfo{}
	case 320:
		return &ParamExtRequestRead{}
	case 321:
		return &ParamExtRequestList{}
	case 322:
		return &ParamExtValue{}
	case 323:
		return &ParamExtSet{}
	case 324:
		return &ParamExtAck{}
	case 330:
		return &ObstacleDistance{}
	case 331:
		return &Odometry{}
	case 332:
		return &TrajectoryRepresentationWaypoints{}
	case 333:
		return &TrajectoryRepresentationBezier{}
	case 334:
		return &CellularStatus{}
	case 340:
		return &UtmGlobalPosition{}
	case 350:
		return &DebugFloatArray{}
	case 360:
		return &OrbitExecutionStatus{}
	case 365:
		return &StatustextLong{}
	case 370:
		return &SmartBatteryInfo{}
	case 371:
		return &SmartBatteryStatus{}
	case 380:
		return &TimeEstimateToTarget{}
	case 9000:
		return &WheelDistance{}
	}
	return nil
}

/* Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter) */
type UavionixAdsbOutCfg struct {
	/* Vehicle address (24 bit) */
	Icao uint32

	/* Aircraft stall speed in cm/s */
	Stallspeed uint16

	/* Vehicle identifier (8 characters, null terminated, valid characters are A-Z, 0-9, " " only) */
	Callsign [9]byte

	/* Transmitting vehicle type. See ADSB_EMITTER_TYPE enum */
	Emittertype AdsbEmitterType // byte

	/* Aircraft length and width encoding (table 2-35 of DO-282B) */
	Aircraftsize UavionixAdsbOutCfgAircraftSize // byte

	/* GPS antenna lateral offset (table 2-36 of DO-282B) */
	Gpsoffsetlat UavionixAdsbOutCfgGpsOffsetLat // byte

	/* GPS antenna longitudinal offset from nose [if non-zero, take position (in meters) divide by 2 and add one] (table 2-37 DO-282B) */
	Gpsoffsetlon UavionixAdsbOutCfgGpsOffsetLon // byte

	/* ADS-B transponder reciever and transmit enable flags */
	Rfselect UavionixAdsbOutRfSelect // byte

}

func (m *UavionixAdsbOutCfg) ID() int        { return 10001 }
func (m *UavionixAdsbOutCfg) CRCExtra() byte { return 209 }

func (m *UavionixAdsbOutCfg) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Icao))
	buf = marshalUint16(buf, (m.Stallspeed))
	for _, v := range m.Callsign {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.Emittertype))
	buf = marshalByte(buf, byte(m.Aircraftsize))
	buf = marshalByte(buf, byte(m.Gpsoffsetlat))
	buf = marshalByte(buf, byte(m.Gpsoffsetlon))
	buf = marshalByte(buf, byte(m.Rfselect))

	return buf
}

func (m *UavionixAdsbOutCfg) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *UavionixAdsbOutCfg) UnmarshalV1(buf []byte) []byte {
	buf, m.Icao = unmarshalUint32(buf)
	buf, m.Stallspeed = unmarshalUint16(buf)
	for i, _ := range m.Callsign {
		buf, m.Callsign[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Emittertype = AdsbEmitterType(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Aircraftsize = UavionixAdsbOutCfgAircraftSize(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Gpsoffsetlat = UavionixAdsbOutCfgGpsOffsetLat(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Gpsoffsetlon = UavionixAdsbOutCfgGpsOffsetLon(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Rfselect = UavionixAdsbOutRfSelect(v)
	}

	return buf
}

func (m *UavionixAdsbOutCfg) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Dynamic data used to generate ADS-B out transponder data (send at 5Hz) */
type UavionixAdsbOutDynamic struct {
	/* UTC time in seconds since GPS epoch (Jan 6, 1980). If unknown set to UINT32_MAX */
	Utctime uint32

	/* Latitude WGS84 (deg * 1E7). If unknown set to INT32_MAX */
	Gpslat int32

	/* Longitude WGS84 (deg * 1E7). If unknown set to INT32_MAX */
	Gpslon int32

	/* Altitude (WGS84). UP +ve. If unknown set to INT32_MAX */
	Gpsalt int32

	/* Barometric pressure altitude (MSL) relative to a standard atmosphere of 1013.2 mBar and NOT bar corrected altitude (m * 1E-3). (up +ve). If unknown set to INT32_MAX */
	Baroaltmsl int32

	/* Horizontal accuracy in mm (m * 1E-3). If unknown set to UINT32_MAX */
	Accuracyhor uint32

	/* Vertical accuracy in cm. If unknown set to UINT16_MAX */
	Accuracyvert uint16

	/* Velocity accuracy in mm/s (m * 1E-3). If unknown set to UINT16_MAX */
	Accuracyvel uint16

	/* GPS vertical speed in cm/s. If unknown set to INT16_MAX */
	Velvert int16

	/* North-South velocity over ground in cm/s North +ve. If unknown set to INT16_MAX */
	Velns int16

	/* East-West velocity over ground in cm/s East +ve. If unknown set to INT16_MAX */
	Velew int16

	/* ADS-B transponder dynamic input state flags */
	State UavionixAdsbOutDynamicState // uint16

	/* Mode A code (typically 1200 [0x04B0] for VFR) */
	Squawk uint16

	/* 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK */
	Gpsfix UavionixAdsbOutDynamicGpsFix // byte

	/* Number of satellites visible. If unknown set to UINT8_MAX */
	Numsats byte

	/* Emergency status */
	Emergencystatus UavionixAdsbEmergencyStatus // byte

}

func (m *UavionixAdsbOutDynamic) ID() int        { return 10002 }
func (m *UavionixAdsbOutDynamic) CRCExtra() byte { return 186 }

func (m *UavionixAdsbOutDynamic) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Utctime))
	buf = marshalInt32(buf, (m.Gpslat))
	buf = marshalInt32(buf, (m.Gpslon))
	buf = marshalInt32(buf, (m.Gpsalt))
	buf = marshalInt32(buf, (m.Baroaltmsl))
	buf = marshalUint32(buf, (m.Accuracyhor))
	buf = marshalUint16(buf, (m.Accuracyvert))
	buf = marshalUint16(buf, (m.Accuracyvel))
	buf = marshalInt16(buf, (m.Velvert))
	buf = marshalInt16(buf, (m.Velns))
	buf = marshalInt16(buf, (m.Velew))
	buf = marshalUint16(buf, uint16(m.State))
	buf = marshalUint16(buf, (m.Squawk))
	buf = marshalByte(buf, byte(m.Gpsfix))
	buf = marshalByte(buf, (m.Numsats))
	buf = marshalByte(buf, byte(m.Emergencystatus))

	return buf
}

func (m *UavionixAdsbOutDynamic) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *UavionixAdsbOutDynamic) UnmarshalV1(buf []byte) []byte {
	buf, m.Utctime = unmarshalUint32(buf)
	buf, m.Gpslat = unmarshalInt32(buf)
	buf, m.Gpslon = unmarshalInt32(buf)
	buf, m.Gpsalt = unmarshalInt32(buf)
	buf, m.Baroaltmsl = unmarshalInt32(buf)
	buf, m.Accuracyhor = unmarshalUint32(buf)
	buf, m.Accuracyvert = unmarshalUint16(buf)
	buf, m.Accuracyvel = unmarshalUint16(buf)
	buf, m.Velvert = unmarshalInt16(buf)
	buf, m.Velns = unmarshalInt16(buf)
	buf, m.Velew = unmarshalInt16(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.State = UavionixAdsbOutDynamicState(v)
	}
	buf, m.Squawk = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Gpsfix = UavionixAdsbOutDynamicGpsFix(v)
	}
	buf, m.Numsats = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Emergencystatus = UavionixAdsbEmergencyStatus(v)
	}

	return buf
}

func (m *UavionixAdsbOutDynamic) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Transceiver heartbeat with health report (updated every 10s) */
type UavionixAdsbTransceiverHealthReport struct {
	/* ADS-B transponder messages */
	Rfhealth UavionixAdsbRfHealth // byte

}

func (m *UavionixAdsbTransceiverHealthReport) ID() int        { return 10003 }
func (m *UavionixAdsbTransceiverHealthReport) CRCExtra() byte { return 4 }

func (m *UavionixAdsbTransceiverHealthReport) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, byte(m.Rfhealth))

	return buf
}

func (m *UavionixAdsbTransceiverHealthReport) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *UavionixAdsbTransceiverHealthReport) UnmarshalV1(buf []byte) []byte {
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Rfhealth = UavionixAdsbRfHealth(v)
	}

	return buf
}

func (m *UavionixAdsbTransceiverHealthReport) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The heartbeat message shows that a system or component is present and responding. The type and autopilot fields (along with the message component id), allow the receiving system to treat further messages from this system appropriately (e.g. by laying out the user interface based on the autopilot). This microservice is documented at https://mavlink.io/en/services/heartbeat.html */
type Heartbeat struct {
	/* A bitfield for use for autopilot-specific flags */
	CustomMode uint32

	/* Type of the system (quadrotor, helicopter, etc.). Components use the same type as their associated system. */
	Type MavType // byte

	/* Autopilot type / class. */
	Autopilot MavAutopilot // byte

	/* System mode bitmap. */
	BaseMode MavModeFlag // byte

	/* System status flag. */
	SystemStatus MavState // byte

	/* MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version */
	MavlinkVersion byte
}

func (m *Heartbeat) ID() int        { return 0 }
func (m *Heartbeat) CRCExtra() byte { return 50 }

func (m *Heartbeat) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.CustomMode))
	buf = marshalByte(buf, byte(m.Type))
	buf = marshalByte(buf, byte(m.Autopilot))
	buf = marshalByte(buf, byte(m.BaseMode))
	buf = marshalByte(buf, byte(m.SystemStatus))
	buf = marshalByte(buf, (m.MavlinkVersion))

	return buf
}

func (m *Heartbeat) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Heartbeat) UnmarshalV1(buf []byte) []byte {
	buf, m.CustomMode = unmarshalUint32(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = MavType(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Autopilot = MavAutopilot(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.BaseMode = MavModeFlag(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.SystemStatus = MavState(v)
	}
	buf, m.MavlinkVersion = unmarshalByte(buf)

	return buf
}

func (m *Heartbeat) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows whether the system is currently active or not and if an emergency occurred. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occurred it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout. */
type SysStatus struct {
	/* Bitmap showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. */
	OnboardControlSensorsPresent MavSysStatusSensor // uint32

	/* Bitmap showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. */
	OnboardControlSensorsEnabled MavSysStatusSensor // uint32

	/* Bitmap showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. */
	OnboardControlSensorsHealth MavSysStatusSensor // uint32

	/* Maximum usage in percent of the mainloop time. Values: [0-1000] - should always be below 1000 */
	Load uint16

	/* Battery voltage */
	VoltageBattery uint16

	/* Battery current, -1: autopilot does not measure the current */
	CurrentBattery int16

	/* Communication drop rate, (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV) */
	DropRateComm uint16

	/* Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV) */
	ErrorsComm uint16

	/* Autopilot-specific errors */
	ErrorsCount1 uint16

	/* Autopilot-specific errors */
	ErrorsCount2 uint16

	/* Autopilot-specific errors */
	ErrorsCount3 uint16

	/* Autopilot-specific errors */
	ErrorsCount4 uint16

	/* Remaining battery energy, -1: autopilot estimate the remaining battery */
	BatteryRemaining int8
}

func (m *SysStatus) ID() int        { return 1 }
func (m *SysStatus) CRCExtra() byte { return 124 }

func (m *SysStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, uint32(m.OnboardControlSensorsPresent))
	buf = marshalUint32(buf, uint32(m.OnboardControlSensorsEnabled))
	buf = marshalUint32(buf, uint32(m.OnboardControlSensorsHealth))
	buf = marshalUint16(buf, (m.Load))
	buf = marshalUint16(buf, (m.VoltageBattery))
	buf = marshalInt16(buf, (m.CurrentBattery))
	buf = marshalUint16(buf, (m.DropRateComm))
	buf = marshalUint16(buf, (m.ErrorsComm))
	buf = marshalUint16(buf, (m.ErrorsCount1))
	buf = marshalUint16(buf, (m.ErrorsCount2))
	buf = marshalUint16(buf, (m.ErrorsCount3))
	buf = marshalUint16(buf, (m.ErrorsCount4))
	buf = marshalInt8(buf, (m.BatteryRemaining))

	return buf
}

func (m *SysStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SysStatus) UnmarshalV1(buf []byte) []byte {
	{
		var v uint32
		buf, v = unmarshalUint32(buf)
		m.OnboardControlSensorsPresent = MavSysStatusSensor(v)
	}
	{
		var v uint32
		buf, v = unmarshalUint32(buf)
		m.OnboardControlSensorsEnabled = MavSysStatusSensor(v)
	}
	{
		var v uint32
		buf, v = unmarshalUint32(buf)
		m.OnboardControlSensorsHealth = MavSysStatusSensor(v)
	}
	buf, m.Load = unmarshalUint16(buf)
	buf, m.VoltageBattery = unmarshalUint16(buf)
	buf, m.CurrentBattery = unmarshalInt16(buf)
	buf, m.DropRateComm = unmarshalUint16(buf)
	buf, m.ErrorsComm = unmarshalUint16(buf)
	buf, m.ErrorsCount1 = unmarshalUint16(buf)
	buf, m.ErrorsCount2 = unmarshalUint16(buf)
	buf, m.ErrorsCount3 = unmarshalUint16(buf)
	buf, m.ErrorsCount4 = unmarshalUint16(buf)
	buf, m.BatteryRemaining = unmarshalInt8(buf)

	return buf
}

func (m *SysStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The system time is the time of the master clock, typically the computer clock of the main onboard computer. */
type SystemTime struct {
	/* Timestamp (UNIX epoch time). */
	TimeUnixUsec uint64

	/* Timestamp (time since system boot). */
	TimeBootMs uint32
}

func (m *SystemTime) ID() int        { return 2 }
func (m *SystemTime) CRCExtra() byte { return 137 }

func (m *SystemTime) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUnixUsec))
	buf = marshalUint32(buf, (m.TimeBootMs))

	return buf
}

func (m *SystemTime) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SystemTime) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUnixUsec = unmarshalUint64(buf)
	buf, m.TimeBootMs = unmarshalUint32(buf)

	return buf
}

func (m *SystemTime) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at https://mavlink.io/en/services/ping.html */
type Ping struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* PING sequence */
	Seq uint32

	/* 0: request ping from all receiving systems. If greater than 0: message is a ping response and number is the system id of the requesting system */
	TargetSystem byte

	/* 0: request ping from all receiving components. If greater than 0: message is a ping response and number is the component id of the requesting component. */
	TargetComponent byte
}

func (m *Ping) ID() int        { return 4 }
func (m *Ping) CRCExtra() byte { return 237 }

func (m *Ping) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint32(buf, (m.Seq))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *Ping) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Ping) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Seq = unmarshalUint32(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *Ping) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request to control this MAV */
type ChangeOperatorControl struct {
	/* System the GCS requests control for */
	TargetSystem byte

	/* 0: request control of this MAV, 1: Release control of this MAV */
	ControlRequest byte

	/* 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch. */
	Version byte

	/* Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and "!?,.-" */
	Passkey [25]byte
}

func (m *ChangeOperatorControl) ID() int        { return 5 }
func (m *ChangeOperatorControl) CRCExtra() byte { return 217 }

func (m *ChangeOperatorControl) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.ControlRequest))
	buf = marshalByte(buf, (m.Version))
	for _, v := range m.Passkey {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *ChangeOperatorControl) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ChangeOperatorControl) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.ControlRequest = unmarshalByte(buf)
	buf, m.Version = unmarshalByte(buf)
	for i, _ := range m.Passkey {
		buf, m.Passkey[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *ChangeOperatorControl) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Accept / deny control of this MAV */
type ChangeOperatorControlAck struct {
	/* ID of the GCS this message  */
	GcsSystemId byte

	/* 0: request control of this MAV, 1: Release control of this MAV */
	ControlRequest byte

	/* 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control */
	Ack byte
}

func (m *ChangeOperatorControlAck) ID() int        { return 6 }
func (m *ChangeOperatorControlAck) CRCExtra() byte { return 104 }

func (m *ChangeOperatorControlAck) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.GcsSystemId))
	buf = marshalByte(buf, (m.ControlRequest))
	buf = marshalByte(buf, (m.Ack))

	return buf
}

func (m *ChangeOperatorControlAck) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ChangeOperatorControlAck) UnmarshalV1(buf []byte) []byte {
	buf, m.GcsSystemId = unmarshalByte(buf)
	buf, m.ControlRequest = unmarshalByte(buf)
	buf, m.Ack = unmarshalByte(buf)

	return buf
}

func (m *ChangeOperatorControlAck) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety. */
type AuthKey struct {
	/* key */
	Key [32]byte
}

func (m *AuthKey) ID() int        { return 7 }
func (m *AuthKey) CRCExtra() byte { return 119 }

func (m *AuthKey) MarshalV1(buf []byte) []byte {
	for _, v := range m.Key {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *AuthKey) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *AuthKey) UnmarshalV1(buf []byte) []byte {
	for i, _ := range m.Key {
		buf, m.Key[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *AuthKey) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component. */
type SetMode struct {
	/* The new autopilot-specific mode. This field can be ignored by an autopilot. */
	CustomMode uint32

	/* The system setting the mode */
	TargetSystem byte

	/* The new base mode. */
	BaseMode MavMode // byte

}

func (m *SetMode) ID() int        { return 11 }
func (m *SetMode) CRCExtra() byte { return 89 }

func (m *SetMode) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.CustomMode))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, byte(m.BaseMode))

	return buf
}

func (m *SetMode) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SetMode) UnmarshalV1(buf []byte) []byte {
	buf, m.CustomMode = unmarshalUint32(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.BaseMode = MavMode(v)
	}

	return buf
}

func (m *SetMode) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also https://mavlink.io/en/services/parameter.html for a full documentation of QGroundControl and IMU code. */
type ParamRequestRead struct {
	/* Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored) */
	ParamIndex int16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte
}

func (m *ParamRequestRead) ID() int        { return 20 }
func (m *ParamRequestRead) CRCExtra() byte { return 214 }

func (m *ParamRequestRead) MarshalV1(buf []byte) []byte {
	buf = marshalInt16(buf, (m.ParamIndex))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *ParamRequestRead) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamRequestRead) UnmarshalV1(buf []byte) []byte {
	buf, m.ParamIndex = unmarshalInt16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *ParamRequestRead) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request all parameters of this component. After this request, all parameters are emitted. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html */
type ParamRequestList struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *ParamRequestList) ID() int        { return 21 }
func (m *ParamRequestList) CRCExtra() byte { return 159 }

func (m *ParamRequestList) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *ParamRequestList) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamRequestList) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *ParamRequestList) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html */
type ParamValue struct {
	/* Onboard parameter value */
	ParamValue float32

	/* Total number of onboard parameters */
	ParamCount uint16

	/* Index of this onboard parameter */
	ParamIndex uint16

	/* Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte

	/* Onboard parameter type. */
	ParamType MavParamType // byte

}

func (m *ParamValue) ID() int        { return 22 }
func (m *ParamValue) CRCExtra() byte { return 220 }

func (m *ParamValue) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.ParamValue))
	buf = marshalUint16(buf, (m.ParamCount))
	buf = marshalUint16(buf, (m.ParamIndex))
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.ParamType))

	return buf
}

func (m *ParamValue) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamValue) UnmarshalV1(buf []byte) []byte {
	buf, m.ParamValue = unmarshalFloat32(buf)
	buf, m.ParamCount = unmarshalUint16(buf)
	buf, m.ParamIndex = unmarshalUint16(buf)
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ParamType = MavParamType(v)
	}

	return buf
}

func (m *ParamValue) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Set a parameter value (write new value to permanent storage). IMPORTANT: The receiving component should acknowledge the new parameter value by sending a PARAM_VALUE message to all communication partners. This will also ensure that multiple GCS all have an up-to-date list of all parameters. If the sending GCS did not receive a PARAM_VALUE message within its timeout time, it should re-send the PARAM_SET message. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html */
type ParamSet struct {
	/* Onboard parameter value */
	ParamValue float32

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte

	/* Onboard parameter type. */
	ParamType MavParamType // byte

}

func (m *ParamSet) ID() int        { return 23 }
func (m *ParamSet) CRCExtra() byte { return 168 }

func (m *ParamSet) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.ParamValue))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.ParamType))

	return buf
}

func (m *ParamSet) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamSet) UnmarshalV1(buf []byte) []byte {
	buf, m.ParamValue = unmarshalFloat32(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ParamType = MavParamType(v)
	}

	return buf
}

func (m *ParamSet) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The global position, as returned by the Global Positioning System (GPS). This is                 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. */
type GpsRawInt struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Latitude (WGS84, EGM96 ellipsoid) */
	Lat int32

	/* Longitude (WGS84, EGM96 ellipsoid) */
	Lon int32

	/* Altitude (MSL). Positive for up. Note that virtually all GPS modules provide the MSL altitude in addition to the WGS84 altitude. */
	Alt int32

	/* GPS HDOP horizontal dilution of position (unitless). If unknown, set to: UINT16_MAX */
	Eph uint16

	/* GPS VDOP vertical dilution of position (unitless). If unknown, set to: UINT16_MAX */
	Epv uint16

	/* GPS ground speed. If unknown, set to: UINT16_MAX */
	Vel uint16

	/* Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX */
	Cog uint16

	/* GPS fix type. */
	FixType GpsFixType // byte

	/* Number of satellites visible. If unknown, set to 255 */
	SatellitesVisible byte

	/* Altitude (above WGS84, EGM96 ellipsoid). Positive for up. */
	AltEllipsoid int32 /*EXTENSION*/

	/* Position uncertainty. Positive for up. */
	HAcc uint32 /*EXTENSION*/

	/* Altitude uncertainty. Positive for up. */
	VAcc uint32 /*EXTENSION*/

	/* Speed uncertainty. Positive for up. */
	VelAcc uint32 /*EXTENSION*/

	/* Heading / track uncertainty */
	HdgAcc uint32 /*EXTENSION*/

}

func (m *GpsRawInt) ID() int        { return 24 }
func (m *GpsRawInt) CRCExtra() byte { return 24 }

func (m *GpsRawInt) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalUint16(buf, (m.Eph))
	buf = marshalUint16(buf, (m.Epv))
	buf = marshalUint16(buf, (m.Vel))
	buf = marshalUint16(buf, (m.Cog))
	buf = marshalByte(buf, byte(m.FixType))
	buf = marshalByte(buf, (m.SatellitesVisible))

	return buf
}

func (m *GpsRawInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalInt32(buf, (m.AltEllipsoid))
	buf = marshalUint32(buf, (m.HAcc))
	buf = marshalUint32(buf, (m.VAcc))
	buf = marshalUint32(buf, (m.VelAcc))
	buf = marshalUint32(buf, (m.HdgAcc))

	return buf
}

func (m *GpsRawInt) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.Eph = unmarshalUint16(buf)
	buf, m.Epv = unmarshalUint16(buf)
	buf, m.Vel = unmarshalUint16(buf)
	buf, m.Cog = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.FixType = GpsFixType(v)
	}
	buf, m.SatellitesVisible = unmarshalByte(buf)

	return buf
}

func (m *GpsRawInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.AltEllipsoid = unmarshalInt32(buf)
	buf, m.HAcc = unmarshalUint32(buf)
	buf, m.VAcc = unmarshalUint32(buf)
	buf, m.VelAcc = unmarshalUint32(buf)
	buf, m.HdgAcc = unmarshalUint32(buf)

	return buf
}

/* The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate. This message can contain information for up to 20 satellites. */
type GpsStatus struct {
	/* Number of satellites visible */
	SatellitesVisible byte

	/* Global satellite ID */
	SatellitePrn [20]byte

	/* 0: Satellite not used, 1: used for localization */
	SatelliteUsed [20]byte

	/* Elevation (0: right on top of receiver, 90: on the horizon) of satellite */
	SatelliteElevation [20]byte

	/* Direction of satellite, 0: 0 deg, 255: 360 deg. */
	SatelliteAzimuth [20]byte

	/* Signal to noise ratio of satellite */
	SatelliteSnr [20]byte
}

func (m *GpsStatus) ID() int        { return 25 }
func (m *GpsStatus) CRCExtra() byte { return 23 }

func (m *GpsStatus) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.SatellitesVisible))
	for _, v := range m.SatellitePrn {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.SatelliteUsed {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.SatelliteElevation {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.SatelliteAzimuth {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.SatelliteSnr {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *GpsStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *GpsStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.SatellitesVisible = unmarshalByte(buf)
	for i, _ := range m.SatellitePrn {
		buf, m.SatellitePrn[i] = unmarshalByte(buf)
	}
	for i, _ := range m.SatelliteUsed {
		buf, m.SatelliteUsed[i] = unmarshalByte(buf)
	}
	for i, _ := range m.SatelliteElevation {
		buf, m.SatelliteElevation[i] = unmarshalByte(buf)
	}
	for i, _ := range m.SatelliteAzimuth {
		buf, m.SatelliteAzimuth[i] = unmarshalByte(buf)
	}
	for i, _ := range m.SatelliteSnr {
		buf, m.SatelliteSnr[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *GpsStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units */
type ScaledImu struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* X acceleration */
	Xacc int16

	/* Y acceleration */
	Yacc int16

	/* Z acceleration */
	Zacc int16

	/* Angular speed around X axis */
	Xgyro int16

	/* Angular speed around Y axis */
	Ygyro int16

	/* Angular speed around Z axis */
	Zgyro int16

	/* X Magnetic field */
	Xmag int16

	/* Y Magnetic field */
	Ymag int16

	/* Z Magnetic field */
	Zmag int16
}

func (m *ScaledImu) ID() int        { return 26 }
func (m *ScaledImu) CRCExtra() byte { return 170 }

func (m *ScaledImu) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt16(buf, (m.Xacc))
	buf = marshalInt16(buf, (m.Yacc))
	buf = marshalInt16(buf, (m.Zacc))
	buf = marshalInt16(buf, (m.Xgyro))
	buf = marshalInt16(buf, (m.Ygyro))
	buf = marshalInt16(buf, (m.Zgyro))
	buf = marshalInt16(buf, (m.Xmag))
	buf = marshalInt16(buf, (m.Ymag))
	buf = marshalInt16(buf, (m.Zmag))

	return buf
}

func (m *ScaledImu) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ScaledImu) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Xacc = unmarshalInt16(buf)
	buf, m.Yacc = unmarshalInt16(buf)
	buf, m.Zacc = unmarshalInt16(buf)
	buf, m.Xgyro = unmarshalInt16(buf)
	buf, m.Ygyro = unmarshalInt16(buf)
	buf, m.Zgyro = unmarshalInt16(buf)
	buf, m.Xmag = unmarshalInt16(buf)
	buf, m.Ymag = unmarshalInt16(buf)
	buf, m.Zmag = unmarshalInt16(buf)

	return buf
}

func (m *ScaledImu) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW IMU readings for the usual 9DOF sensor setup. This message should always contain the true raw values without any scaling to allow data capture and system debugging. */
type RawImu struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X acceleration (raw) */
	Xacc int16

	/* Y acceleration (raw) */
	Yacc int16

	/* Z acceleration (raw) */
	Zacc int16

	/* Angular speed around X axis (raw) */
	Xgyro int16

	/* Angular speed around Y axis (raw) */
	Ygyro int16

	/* Angular speed around Z axis (raw) */
	Zgyro int16

	/* X Magnetic field (raw) */
	Xmag int16

	/* Y Magnetic field (raw) */
	Ymag int16

	/* Z Magnetic field (raw) */
	Zmag int16
}

func (m *RawImu) ID() int        { return 27 }
func (m *RawImu) CRCExtra() byte { return 144 }

func (m *RawImu) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalInt16(buf, (m.Xacc))
	buf = marshalInt16(buf, (m.Yacc))
	buf = marshalInt16(buf, (m.Zacc))
	buf = marshalInt16(buf, (m.Xgyro))
	buf = marshalInt16(buf, (m.Ygyro))
	buf = marshalInt16(buf, (m.Zgyro))
	buf = marshalInt16(buf, (m.Xmag))
	buf = marshalInt16(buf, (m.Ymag))
	buf = marshalInt16(buf, (m.Zmag))

	return buf
}

func (m *RawImu) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *RawImu) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Xacc = unmarshalInt16(buf)
	buf, m.Yacc = unmarshalInt16(buf)
	buf, m.Zacc = unmarshalInt16(buf)
	buf, m.Xgyro = unmarshalInt16(buf)
	buf, m.Ygyro = unmarshalInt16(buf)
	buf, m.Zgyro = unmarshalInt16(buf)
	buf, m.Xmag = unmarshalInt16(buf)
	buf, m.Ymag = unmarshalInt16(buf)
	buf, m.Zmag = unmarshalInt16(buf)

	return buf
}

func (m *RawImu) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values. */
type RawPressure struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Absolute pressure (raw) */
	PressAbs int16

	/* Differential pressure 1 (raw, 0 if nonexistent) */
	PressDiff1 int16

	/* Differential pressure 2 (raw, 0 if nonexistent) */
	PressDiff2 int16

	/* Raw Temperature measurement (raw) */
	Temperature int16
}

func (m *RawPressure) ID() int        { return 28 }
func (m *RawPressure) CRCExtra() byte { return 67 }

func (m *RawPressure) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalInt16(buf, (m.PressAbs))
	buf = marshalInt16(buf, (m.PressDiff1))
	buf = marshalInt16(buf, (m.PressDiff2))
	buf = marshalInt16(buf, (m.Temperature))

	return buf
}

func (m *RawPressure) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *RawPressure) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.PressAbs = unmarshalInt16(buf)
	buf, m.PressDiff1 = unmarshalInt16(buf)
	buf, m.PressDiff2 = unmarshalInt16(buf)
	buf, m.Temperature = unmarshalInt16(buf)

	return buf
}

func (m *RawPressure) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field. */
type ScaledPressure struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Absolute pressure */
	PressAbs float32

	/* Differential pressure 1 */
	PressDiff float32

	/* Temperature */
	Temperature int16
}

func (m *ScaledPressure) ID() int        { return 29 }
func (m *ScaledPressure) CRCExtra() byte { return 115 }

func (m *ScaledPressure) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.PressAbs))
	buf = marshalFloat32(buf, (m.PressDiff))
	buf = marshalInt16(buf, (m.Temperature))

	return buf
}

func (m *ScaledPressure) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ScaledPressure) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.PressAbs = unmarshalFloat32(buf)
	buf, m.PressDiff = unmarshalFloat32(buf)
	buf, m.Temperature = unmarshalInt16(buf)

	return buf
}

func (m *ScaledPressure) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right). */
type Attitude struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Roll angle (-pi..+pi) */
	Roll float32

	/* Pitch angle (-pi..+pi) */
	Pitch float32

	/* Yaw angle (-pi..+pi) */
	Yaw float32

	/* Roll angular speed */
	Rollspeed float32

	/* Pitch angular speed */
	Pitchspeed float32

	/* Yaw angular speed */
	Yawspeed float32
}

func (m *Attitude) ID() int        { return 30 }
func (m *Attitude) CRCExtra() byte { return 39 }

func (m *Attitude) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.Rollspeed))
	buf = marshalFloat32(buf, (m.Pitchspeed))
	buf = marshalFloat32(buf, (m.Yawspeed))

	return buf
}

func (m *Attitude) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Attitude) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.Rollspeed = unmarshalFloat32(buf)
	buf, m.Pitchspeed = unmarshalFloat32(buf)
	buf, m.Yawspeed = unmarshalFloat32(buf)

	return buf
}

func (m *Attitude) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0). */
type AttitudeQuaternion struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Quaternion component 1, w (1 in null-rotation) */
	Q1 float32

	/* Quaternion component 2, x (0 in null-rotation) */
	Q2 float32

	/* Quaternion component 3, y (0 in null-rotation) */
	Q3 float32

	/* Quaternion component 4, z (0 in null-rotation) */
	Q4 float32

	/* Roll angular speed */
	Rollspeed float32

	/* Pitch angular speed */
	Pitchspeed float32

	/* Yaw angular speed */
	Yawspeed float32
}

func (m *AttitudeQuaternion) ID() int        { return 31 }
func (m *AttitudeQuaternion) CRCExtra() byte { return 246 }

func (m *AttitudeQuaternion) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.Q1))
	buf = marshalFloat32(buf, (m.Q2))
	buf = marshalFloat32(buf, (m.Q3))
	buf = marshalFloat32(buf, (m.Q4))
	buf = marshalFloat32(buf, (m.Rollspeed))
	buf = marshalFloat32(buf, (m.Pitchspeed))
	buf = marshalFloat32(buf, (m.Yawspeed))

	return buf
}

func (m *AttitudeQuaternion) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *AttitudeQuaternion) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Q1 = unmarshalFloat32(buf)
	buf, m.Q2 = unmarshalFloat32(buf)
	buf, m.Q3 = unmarshalFloat32(buf)
	buf, m.Q4 = unmarshalFloat32(buf)
	buf, m.Rollspeed = unmarshalFloat32(buf)
	buf, m.Pitchspeed = unmarshalFloat32(buf)
	buf, m.Yawspeed = unmarshalFloat32(buf)

	return buf
}

func (m *AttitudeQuaternion) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention) */
type LocalPositionNed struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* X Position */
	X float32

	/* Y Position */
	Y float32

	/* Z Position */
	Z float32

	/* X Speed */
	Vx float32

	/* Y Speed */
	Vy float32

	/* Z Speed */
	Vz float32
}

func (m *LocalPositionNed) ID() int        { return 32 }
func (m *LocalPositionNed) CRCExtra() byte { return 185 }

func (m *LocalPositionNed) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))

	return buf
}

func (m *LocalPositionNed) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LocalPositionNed) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)

	return buf
}

func (m *LocalPositionNed) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It                is designed as scaled integer message since the resolution of float is not sufficient. */
type GlobalPositionInt struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Latitude, expressed */
	Lat int32

	/* Longitude, expressed */
	Lon int32

	/* Altitude (MSL). Note that virtually all GPS modules provide both WGS84 and MSL. */
	Alt int32

	/* Altitude above ground */
	RelativeAlt int32

	/* Ground X Speed (Latitude, positive north) */
	Vx int16

	/* Ground Y Speed (Longitude, positive east) */
	Vy int16

	/* Ground Z Speed (Altitude, positive down) */
	Vz int16

	/* Vehicle heading (yaw angle), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX */
	Hdg uint16
}

func (m *GlobalPositionInt) ID() int        { return 33 }
func (m *GlobalPositionInt) CRCExtra() byte { return 104 }

func (m *GlobalPositionInt) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalInt32(buf, (m.RelativeAlt))
	buf = marshalInt16(buf, (m.Vx))
	buf = marshalInt16(buf, (m.Vy))
	buf = marshalInt16(buf, (m.Vz))
	buf = marshalUint16(buf, (m.Hdg))

	return buf
}

func (m *GlobalPositionInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *GlobalPositionInt) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.RelativeAlt = unmarshalInt32(buf)
	buf, m.Vx = unmarshalInt16(buf)
	buf, m.Vy = unmarshalInt16(buf)
	buf, m.Vz = unmarshalInt16(buf)
	buf, m.Hdg = unmarshalUint16(buf)

	return buf
}

func (m *GlobalPositionInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The scaled values of the RC channels received: (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to UINT16_MAX. */
type RcChannelsScaled struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* RC channel 1 value scaled. */
	Chan1Scaled int16

	/* RC channel 2 value scaled. */
	Chan2Scaled int16

	/* RC channel 3 value scaled. */
	Chan3Scaled int16

	/* RC channel 4 value scaled. */
	Chan4Scaled int16

	/* RC channel 5 value scaled. */
	Chan5Scaled int16

	/* RC channel 6 value scaled. */
	Chan6Scaled int16

	/* RC channel 7 value scaled. */
	Chan7Scaled int16

	/* RC channel 8 value scaled. */
	Chan8Scaled int16

	/* Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX. */
	Port byte

	/* Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown. */
	Rssi byte
}

func (m *RcChannelsScaled) ID() int        { return 34 }
func (m *RcChannelsScaled) CRCExtra() byte { return 237 }

func (m *RcChannelsScaled) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt16(buf, (m.Chan1Scaled))
	buf = marshalInt16(buf, (m.Chan2Scaled))
	buf = marshalInt16(buf, (m.Chan3Scaled))
	buf = marshalInt16(buf, (m.Chan4Scaled))
	buf = marshalInt16(buf, (m.Chan5Scaled))
	buf = marshalInt16(buf, (m.Chan6Scaled))
	buf = marshalInt16(buf, (m.Chan7Scaled))
	buf = marshalInt16(buf, (m.Chan8Scaled))
	buf = marshalByte(buf, (m.Port))
	buf = marshalByte(buf, (m.Rssi))

	return buf
}

func (m *RcChannelsScaled) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *RcChannelsScaled) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Chan1Scaled = unmarshalInt16(buf)
	buf, m.Chan2Scaled = unmarshalInt16(buf)
	buf, m.Chan3Scaled = unmarshalInt16(buf)
	buf, m.Chan4Scaled = unmarshalInt16(buf)
	buf, m.Chan5Scaled = unmarshalInt16(buf)
	buf, m.Chan6Scaled = unmarshalInt16(buf)
	buf, m.Chan7Scaled = unmarshalInt16(buf)
	buf, m.Chan8Scaled = unmarshalInt16(buf)
	buf, m.Port = unmarshalByte(buf)
	buf, m.Rssi = unmarshalByte(buf)

	return buf
}

func (m *RcChannelsScaled) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification. */
type RcChannelsRaw struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* RC channel 1 value. */
	Chan1Raw uint16

	/* RC channel 2 value. */
	Chan2Raw uint16

	/* RC channel 3 value. */
	Chan3Raw uint16

	/* RC channel 4 value. */
	Chan4Raw uint16

	/* RC channel 5 value. */
	Chan5Raw uint16

	/* RC channel 6 value. */
	Chan6Raw uint16

	/* RC channel 7 value. */
	Chan7Raw uint16

	/* RC channel 8 value. */
	Chan8Raw uint16

	/* Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX. */
	Port byte

	/* Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown. */
	Rssi byte
}

func (m *RcChannelsRaw) ID() int        { return 35 }
func (m *RcChannelsRaw) CRCExtra() byte { return 244 }

func (m *RcChannelsRaw) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalUint16(buf, (m.Chan1Raw))
	buf = marshalUint16(buf, (m.Chan2Raw))
	buf = marshalUint16(buf, (m.Chan3Raw))
	buf = marshalUint16(buf, (m.Chan4Raw))
	buf = marshalUint16(buf, (m.Chan5Raw))
	buf = marshalUint16(buf, (m.Chan6Raw))
	buf = marshalUint16(buf, (m.Chan7Raw))
	buf = marshalUint16(buf, (m.Chan8Raw))
	buf = marshalByte(buf, (m.Port))
	buf = marshalByte(buf, (m.Rssi))

	return buf
}

func (m *RcChannelsRaw) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *RcChannelsRaw) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Chan1Raw = unmarshalUint16(buf)
	buf, m.Chan2Raw = unmarshalUint16(buf)
	buf, m.Chan3Raw = unmarshalUint16(buf)
	buf, m.Chan4Raw = unmarshalUint16(buf)
	buf, m.Chan5Raw = unmarshalUint16(buf)
	buf, m.Chan6Raw = unmarshalUint16(buf)
	buf, m.Chan7Raw = unmarshalUint16(buf)
	buf, m.Chan8Raw = unmarshalUint16(buf)
	buf, m.Port = unmarshalByte(buf)
	buf, m.Rssi = unmarshalByte(buf)

	return buf
}

func (m *RcChannelsRaw) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. */
type ServoOutputRaw struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint32

	/* Servo output 1 value */
	Servo1Raw uint16

	/* Servo output 2 value */
	Servo2Raw uint16

	/* Servo output 3 value */
	Servo3Raw uint16

	/* Servo output 4 value */
	Servo4Raw uint16

	/* Servo output 5 value */
	Servo5Raw uint16

	/* Servo output 6 value */
	Servo6Raw uint16

	/* Servo output 7 value */
	Servo7Raw uint16

	/* Servo output 8 value */
	Servo8Raw uint16

	/* Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX. */
	Port byte

	/* Servo output 9 value */
	Servo9Raw uint16 /*EXTENSION*/

	/* Servo output 10 value */
	Servo10Raw uint16 /*EXTENSION*/

	/* Servo output 11 value */
	Servo11Raw uint16 /*EXTENSION*/

	/* Servo output 12 value */
	Servo12Raw uint16 /*EXTENSION*/

	/* Servo output 13 value */
	Servo13Raw uint16 /*EXTENSION*/

	/* Servo output 14 value */
	Servo14Raw uint16 /*EXTENSION*/

	/* Servo output 15 value */
	Servo15Raw uint16 /*EXTENSION*/

	/* Servo output 16 value */
	Servo16Raw uint16 /*EXTENSION*/

}

func (m *ServoOutputRaw) ID() int        { return 36 }
func (m *ServoOutputRaw) CRCExtra() byte { return 222 }

func (m *ServoOutputRaw) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeUsec))
	buf = marshalUint16(buf, (m.Servo1Raw))
	buf = marshalUint16(buf, (m.Servo2Raw))
	buf = marshalUint16(buf, (m.Servo3Raw))
	buf = marshalUint16(buf, (m.Servo4Raw))
	buf = marshalUint16(buf, (m.Servo5Raw))
	buf = marshalUint16(buf, (m.Servo6Raw))
	buf = marshalUint16(buf, (m.Servo7Raw))
	buf = marshalUint16(buf, (m.Servo8Raw))
	buf = marshalByte(buf, (m.Port))

	return buf
}

func (m *ServoOutputRaw) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalUint16(buf, (m.Servo9Raw))
	buf = marshalUint16(buf, (m.Servo10Raw))
	buf = marshalUint16(buf, (m.Servo11Raw))
	buf = marshalUint16(buf, (m.Servo12Raw))
	buf = marshalUint16(buf, (m.Servo13Raw))
	buf = marshalUint16(buf, (m.Servo14Raw))
	buf = marshalUint16(buf, (m.Servo15Raw))
	buf = marshalUint16(buf, (m.Servo16Raw))

	return buf
}

func (m *ServoOutputRaw) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint32(buf)
	buf, m.Servo1Raw = unmarshalUint16(buf)
	buf, m.Servo2Raw = unmarshalUint16(buf)
	buf, m.Servo3Raw = unmarshalUint16(buf)
	buf, m.Servo4Raw = unmarshalUint16(buf)
	buf, m.Servo5Raw = unmarshalUint16(buf)
	buf, m.Servo6Raw = unmarshalUint16(buf)
	buf, m.Servo7Raw = unmarshalUint16(buf)
	buf, m.Servo8Raw = unmarshalUint16(buf)
	buf, m.Port = unmarshalByte(buf)

	return buf
}

func (m *ServoOutputRaw) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.Servo9Raw = unmarshalUint16(buf)
	buf, m.Servo10Raw = unmarshalUint16(buf)
	buf, m.Servo11Raw = unmarshalUint16(buf)
	buf, m.Servo12Raw = unmarshalUint16(buf)
	buf, m.Servo13Raw = unmarshalUint16(buf)
	buf, m.Servo14Raw = unmarshalUint16(buf)
	buf, m.Servo15Raw = unmarshalUint16(buf)
	buf, m.Servo16Raw = unmarshalUint16(buf)

	return buf
}

/* Request a partial list of mission items from the system/component. https://mavlink.io/en/services/mission.html. If start and end index are the same, just send one waypoint. */
type MissionRequestPartialList struct {
	/* Start index */
	StartIndex int16

	/* End index, -1 by default (-1: send list to end). Else a valid index of the list */
	EndIndex int16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionRequestPartialList) ID() int        { return 37 }
func (m *MissionRequestPartialList) CRCExtra() byte { return 212 }

func (m *MissionRequestPartialList) MarshalV1(buf []byte) []byte {
	buf = marshalInt16(buf, (m.StartIndex))
	buf = marshalInt16(buf, (m.EndIndex))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionRequestPartialList) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionRequestPartialList) UnmarshalV1(buf []byte) []byte {
	buf, m.StartIndex = unmarshalInt16(buf)
	buf, m.EndIndex = unmarshalInt16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionRequestPartialList) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED! */
type MissionWritePartialList struct {
	/* Start index. Must be smaller / equal to the largest index of the current onboard list. */
	StartIndex int16

	/* End index, equal or greater than start index. */
	EndIndex int16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionWritePartialList) ID() int        { return 38 }
func (m *MissionWritePartialList) CRCExtra() byte { return 9 }

func (m *MissionWritePartialList) MarshalV1(buf []byte) []byte {
	buf = marshalInt16(buf, (m.StartIndex))
	buf = marshalInt16(buf, (m.EndIndex))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionWritePartialList) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionWritePartialList) UnmarshalV1(buf []byte) []byte {
	buf, m.StartIndex = unmarshalInt16(buf)
	buf, m.EndIndex = unmarshalInt16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionWritePartialList) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See also https://mavlink.io/en/services/mission.html. */
type MissionItem struct {
	/* PARAM1, see MAV_CMD enum */
	Param1 float32

	/* PARAM2, see MAV_CMD enum */
	Param2 float32

	/* PARAM3, see MAV_CMD enum */
	Param3 float32

	/* PARAM4, see MAV_CMD enum */
	Param4 float32

	/* PARAM5 / local: X coordinate, global: latitude */
	X float32

	/* PARAM6 / local: Y coordinate, global: longitude */
	Y float32

	/* PARAM7 / local: Z coordinate, global: altitude (relative or absolute, depending on frame). */
	Z float32

	/* Sequence */
	Seq uint16

	/* The scheduled action for the waypoint. */
	Command MavCmd // uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* The coordinate system of the waypoint. */
	Frame MavFrame // byte

	/* false:0, true:1 */
	Current byte

	/* Autocontinue to next waypoint */
	Autocontinue byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionItem) ID() int        { return 39 }
func (m *MissionItem) CRCExtra() byte { return 254 }

func (m *MissionItem) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Param1))
	buf = marshalFloat32(buf, (m.Param2))
	buf = marshalFloat32(buf, (m.Param3))
	buf = marshalFloat32(buf, (m.Param4))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalUint16(buf, (m.Seq))
	buf = marshalUint16(buf, uint16(m.Command))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, byte(m.Frame))
	buf = marshalByte(buf, (m.Current))
	buf = marshalByte(buf, (m.Autocontinue))

	return buf
}

func (m *MissionItem) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionItem) UnmarshalV1(buf []byte) []byte {
	buf, m.Param1 = unmarshalFloat32(buf)
	buf, m.Param2 = unmarshalFloat32(buf)
	buf, m.Param3 = unmarshalFloat32(buf)
	buf, m.Param4 = unmarshalFloat32(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Seq = unmarshalUint16(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Command = MavCmd(v)
	}
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Frame = MavFrame(v)
	}
	buf, m.Current = unmarshalByte(buf)
	buf, m.Autocontinue = unmarshalByte(buf)

	return buf
}

func (m *MissionItem) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. https://mavlink.io/en/services/mission.html */
type MissionRequest struct {
	/* Sequence */
	Seq uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionRequest) ID() int        { return 40 }
func (m *MissionRequest) CRCExtra() byte { return 230 }

func (m *MissionRequest) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Seq))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionRequest) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionRequest) UnmarshalV1(buf []byte) []byte {
	buf, m.Seq = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionRequest) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between). */
type MissionSetCurrent struct {
	/* Sequence */
	Seq uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *MissionSetCurrent) ID() int        { return 41 }
func (m *MissionSetCurrent) CRCExtra() byte { return 28 }

func (m *MissionSetCurrent) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Seq))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionSetCurrent) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *MissionSetCurrent) UnmarshalV1(buf []byte) []byte {
	buf, m.Seq = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionSetCurrent) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Message that announces the sequence number of the current active mission item. The MAV will fly towards this mission item. */
type MissionCurrent struct {
	/* Sequence */
	Seq uint16
}

func (m *MissionCurrent) ID() int        { return 42 }
func (m *MissionCurrent) CRCExtra() byte { return 28 }

func (m *MissionCurrent) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Seq))

	return buf
}

func (m *MissionCurrent) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *MissionCurrent) UnmarshalV1(buf []byte) []byte {
	buf, m.Seq = unmarshalUint16(buf)

	return buf
}

func (m *MissionCurrent) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request the overall list of mission items from the system/component. */
type MissionRequestList struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionRequestList) ID() int        { return 43 }
func (m *MissionRequestList) CRCExtra() byte { return 132 }

func (m *MissionRequestList) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionRequestList) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionRequestList) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionRequestList) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of waypoints. */
type MissionCount struct {
	/* Number of mission items in the sequence */
	Count uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionCount) ID() int        { return 44 }
func (m *MissionCount) CRCExtra() byte { return 221 }

func (m *MissionCount) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Count))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionCount) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionCount) UnmarshalV1(buf []byte) []byte {
	buf, m.Count = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionCount) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* Delete all mission items at once. */
type MissionClearAll struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionClearAll) ID() int        { return 45 }
func (m *MissionClearAll) CRCExtra() byte { return 232 }

func (m *MissionClearAll) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionClearAll) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionClearAll) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionClearAll) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next waypoint. */
type MissionItemReached struct {
	/* Sequence */
	Seq uint16
}

func (m *MissionItemReached) ID() int        { return 46 }
func (m *MissionItemReached) CRCExtra() byte { return 11 }

func (m *MissionItemReached) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Seq))

	return buf
}

func (m *MissionItemReached) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *MissionItemReached) UnmarshalV1(buf []byte) []byte {
	buf, m.Seq = unmarshalUint16(buf)

	return buf
}

func (m *MissionItemReached) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Acknowledgment message during waypoint handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero). */
type MissionAck struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission result. */
	Type MavMissionResult // byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionAck) ID() int        { return 47 }
func (m *MissionAck) CRCExtra() byte { return 153 }

func (m *MissionAck) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, byte(m.Type))

	return buf
}

func (m *MissionAck) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionAck) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = MavMissionResult(v)
	}

	return buf
}

func (m *MissionAck) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* As local waypoints exist, the global waypoint reference allows to transform between the local coordinate frame and the global (GPS) coordinate frame. This can be necessary when e.g. in- and outdoor settings are connected and the MAV should move from in- to outdoor. */
type SetGpsGlobalOrigin struct {
	/* Latitude (WGS84) */
	Latitude int32

	/* Longitude (WGS84) */
	Longitude int32

	/* Altitude (MSL). Positive for up. */
	Altitude int32

	/* System ID */
	TargetSystem byte

	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64 /*EXTENSION*/

}

func (m *SetGpsGlobalOrigin) ID() int        { return 48 }
func (m *SetGpsGlobalOrigin) CRCExtra() byte { return 41 }

func (m *SetGpsGlobalOrigin) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.Latitude))
	buf = marshalInt32(buf, (m.Longitude))
	buf = marshalInt32(buf, (m.Altitude))
	buf = marshalByte(buf, (m.TargetSystem))

	return buf
}

func (m *SetGpsGlobalOrigin) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalUint64(buf, (m.TimeUsec))

	return buf
}

func (m *SetGpsGlobalOrigin) UnmarshalV1(buf []byte) []byte {
	buf, m.Latitude = unmarshalInt32(buf)
	buf, m.Longitude = unmarshalInt32(buf)
	buf, m.Altitude = unmarshalInt32(buf)
	buf, m.TargetSystem = unmarshalByte(buf)

	return buf
}

func (m *SetGpsGlobalOrigin) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.TimeUsec = unmarshalUint64(buf)

	return buf
}

/* Once the MAV sets a new GPS-Local correspondence, this message announces the origin (0,0,0) position */
type GpsGlobalOrigin struct {
	/* Latitude (WGS84) */
	Latitude int32

	/* Longitude (WGS84) */
	Longitude int32

	/* Altitude (MSL). Positive for up. */
	Altitude int32

	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64 /*EXTENSION*/

}

func (m *GpsGlobalOrigin) ID() int        { return 49 }
func (m *GpsGlobalOrigin) CRCExtra() byte { return 39 }

func (m *GpsGlobalOrigin) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.Latitude))
	buf = marshalInt32(buf, (m.Longitude))
	buf = marshalInt32(buf, (m.Altitude))

	return buf
}

func (m *GpsGlobalOrigin) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalUint64(buf, (m.TimeUsec))

	return buf
}

func (m *GpsGlobalOrigin) UnmarshalV1(buf []byte) []byte {
	buf, m.Latitude = unmarshalInt32(buf)
	buf, m.Longitude = unmarshalInt32(buf)
	buf, m.Altitude = unmarshalInt32(buf)

	return buf
}

func (m *GpsGlobalOrigin) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.TimeUsec = unmarshalUint64(buf)

	return buf
}

/* Bind a RC channel to a parameter. The parameter should change according to the RC channel value. */
type ParamMapRc struct {
	/* Initial parameter value */
	ParamValue0 float32

	/* Scale, maps the RC range [-1, 1] to a parameter value */
	Scale float32

	/* Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation) */
	ParamValueMin float32

	/* Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation) */
	ParamValueMax float32

	/* Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index. */
	ParamIndex int16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte

	/* Index of parameter RC channel. Not equal to the RC channel id. Typically corresponds to a potentiometer-knob on the RC. */
	ParameterRcChannelIndex byte
}

func (m *ParamMapRc) ID() int        { return 50 }
func (m *ParamMapRc) CRCExtra() byte { return 78 }

func (m *ParamMapRc) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.ParamValue0))
	buf = marshalFloat32(buf, (m.Scale))
	buf = marshalFloat32(buf, (m.ParamValueMin))
	buf = marshalFloat32(buf, (m.ParamValueMax))
	buf = marshalInt16(buf, (m.ParamIndex))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, (m.ParameterRcChannelIndex))

	return buf
}

func (m *ParamMapRc) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamMapRc) UnmarshalV1(buf []byte) []byte {
	buf, m.ParamValue0 = unmarshalFloat32(buf)
	buf, m.Scale = unmarshalFloat32(buf)
	buf, m.ParamValueMin = unmarshalFloat32(buf)
	buf, m.ParamValueMax = unmarshalFloat32(buf)
	buf, m.ParamIndex = unmarshalInt16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}
	buf, m.ParameterRcChannelIndex = unmarshalByte(buf)

	return buf
}

func (m *ParamMapRc) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. https://mavlink.io/en/services/mission.html */
type MissionRequestInt struct {
	/* Sequence */
	Seq uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionRequestInt) ID() int        { return 51 }
func (m *MissionRequestInt) CRCExtra() byte { return 196 }

func (m *MissionRequestInt) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Seq))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *MissionRequestInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionRequestInt) UnmarshalV1(buf []byte) []byte {
	buf, m.Seq = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *MissionRequestInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national or competition regulations. */
type SafetySetAllowedArea struct {
	/* x position 1 / Latitude 1 */
	P1x float32

	/* y position 1 / Longitude 1 */
	P1y float32

	/* z position 1 / Altitude 1 */
	P1z float32

	/* x position 2 / Latitude 2 */
	P2x float32

	/* y position 2 / Longitude 2 */
	P2y float32

	/* z position 2 / Altitude 2 */
	P2z float32

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down. */
	Frame MavFrame // byte

}

func (m *SafetySetAllowedArea) ID() int        { return 54 }
func (m *SafetySetAllowedArea) CRCExtra() byte { return 15 }

func (m *SafetySetAllowedArea) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.P1x))
	buf = marshalFloat32(buf, (m.P1y))
	buf = marshalFloat32(buf, (m.P1z))
	buf = marshalFloat32(buf, (m.P2x))
	buf = marshalFloat32(buf, (m.P2y))
	buf = marshalFloat32(buf, (m.P2z))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, byte(m.Frame))

	return buf
}

func (m *SafetySetAllowedArea) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SafetySetAllowedArea) UnmarshalV1(buf []byte) []byte {
	buf, m.P1x = unmarshalFloat32(buf)
	buf, m.P1y = unmarshalFloat32(buf)
	buf, m.P1z = unmarshalFloat32(buf)
	buf, m.P2x = unmarshalFloat32(buf)
	buf, m.P2y = unmarshalFloat32(buf)
	buf, m.P2z = unmarshalFloat32(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Frame = MavFrame(v)
	}

	return buf
}

func (m *SafetySetAllowedArea) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Read out the safety zone the MAV currently assumes. */
type SafetyAllowedArea struct {
	/* x position 1 / Latitude 1 */
	P1x float32

	/* y position 1 / Longitude 1 */
	P1y float32

	/* z position 1 / Altitude 1 */
	P1z float32

	/* x position 2 / Latitude 2 */
	P2x float32

	/* y position 2 / Longitude 2 */
	P2y float32

	/* z position 2 / Altitude 2 */
	P2z float32

	/* Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down. */
	Frame MavFrame // byte

}

func (m *SafetyAllowedArea) ID() int        { return 55 }
func (m *SafetyAllowedArea) CRCExtra() byte { return 3 }

func (m *SafetyAllowedArea) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.P1x))
	buf = marshalFloat32(buf, (m.P1y))
	buf = marshalFloat32(buf, (m.P1z))
	buf = marshalFloat32(buf, (m.P2x))
	buf = marshalFloat32(buf, (m.P2y))
	buf = marshalFloat32(buf, (m.P2z))
	buf = marshalByte(buf, byte(m.Frame))

	return buf
}

func (m *SafetyAllowedArea) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SafetyAllowedArea) UnmarshalV1(buf []byte) []byte {
	buf, m.P1x = unmarshalFloat32(buf)
	buf, m.P1y = unmarshalFloat32(buf)
	buf, m.P1z = unmarshalFloat32(buf)
	buf, m.P2x = unmarshalFloat32(buf)
	buf, m.P2y = unmarshalFloat32(buf)
	buf, m.P2z = unmarshalFloat32(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Frame = MavFrame(v)
	}

	return buf
}

func (m *SafetyAllowedArea) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0). */
type AttitudeQuaternionCov struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation) */
	Q [4]float32

	/* Roll angular speed */
	Rollspeed float32

	/* Pitch angular speed */
	Pitchspeed float32

	/* Yaw angular speed */
	Yawspeed float32

	/* Row-major representation of a 3x3 attitude covariance matrix (states: roll, pitch, yaw; first three entries are the first ROW, next three entries are the second row, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [9]float32
}

func (m *AttitudeQuaternionCov) ID() int        { return 61 }
func (m *AttitudeQuaternionCov) CRCExtra() byte { return 167 }

func (m *AttitudeQuaternionCov) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.Rollspeed))
	buf = marshalFloat32(buf, (m.Pitchspeed))
	buf = marshalFloat32(buf, (m.Yawspeed))
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}

	return buf
}

func (m *AttitudeQuaternionCov) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *AttitudeQuaternionCov) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.Rollspeed = unmarshalFloat32(buf)
	buf, m.Pitchspeed = unmarshalFloat32(buf)
	buf, m.Yawspeed = unmarshalFloat32(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}

	return buf
}

func (m *AttitudeQuaternionCov) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The state of the fixed wing navigation and position controller. */
type NavControllerOutput struct {
	/* Current desired roll */
	NavRoll float32

	/* Current desired pitch */
	NavPitch float32

	/* Current altitude error */
	AltError float32

	/* Current airspeed error */
	AspdError float32

	/* Current crosstrack error on x-y plane */
	XtrackError float32

	/* Current desired heading */
	NavBearing int16

	/* Bearing to current waypoint/target */
	TargetBearing int16

	/* Distance to active waypoint */
	WpDist uint16
}

func (m *NavControllerOutput) ID() int        { return 62 }
func (m *NavControllerOutput) CRCExtra() byte { return 183 }

func (m *NavControllerOutput) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.NavRoll))
	buf = marshalFloat32(buf, (m.NavPitch))
	buf = marshalFloat32(buf, (m.AltError))
	buf = marshalFloat32(buf, (m.AspdError))
	buf = marshalFloat32(buf, (m.XtrackError))
	buf = marshalInt16(buf, (m.NavBearing))
	buf = marshalInt16(buf, (m.TargetBearing))
	buf = marshalUint16(buf, (m.WpDist))

	return buf
}

func (m *NavControllerOutput) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *NavControllerOutput) UnmarshalV1(buf []byte) []byte {
	buf, m.NavRoll = unmarshalFloat32(buf)
	buf, m.NavPitch = unmarshalFloat32(buf)
	buf, m.AltError = unmarshalFloat32(buf)
	buf, m.AspdError = unmarshalFloat32(buf)
	buf, m.XtrackError = unmarshalFloat32(buf)
	buf, m.NavBearing = unmarshalInt16(buf)
	buf, m.TargetBearing = unmarshalInt16(buf)
	buf, m.WpDist = unmarshalUint16(buf)

	return buf
}

func (m *NavControllerOutput) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset. */
type GlobalPositionIntCov struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Latitude */
	Lat int32

	/* Longitude */
	Lon int32

	/* Altitude in meters above MSL */
	Alt int32

	/* Altitude above ground */
	RelativeAlt int32

	/* Ground X Speed (Latitude) */
	Vx float32

	/* Ground Y Speed (Longitude) */
	Vy float32

	/* Ground Z Speed (Altitude) */
	Vz float32

	/* Row-major representation of a 6x6 position and velocity 6x6 cross-covariance matrix (states: lat, lon, alt, vx, vy, vz; first six entries are the first ROW, next six entries are the second row, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [36]float32

	/* Class id of the estimator this estimate originated from. */
	EstimatorType MavEstimatorType // byte

}

func (m *GlobalPositionIntCov) ID() int        { return 63 }
func (m *GlobalPositionIntCov) CRCExtra() byte { return 119 }

func (m *GlobalPositionIntCov) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalInt32(buf, (m.RelativeAlt))
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, byte(m.EstimatorType))

	return buf
}

func (m *GlobalPositionIntCov) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *GlobalPositionIntCov) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.RelativeAlt = unmarshalInt32(buf)
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.EstimatorType = MavEstimatorType(v)
	}

	return buf
}

func (m *GlobalPositionIntCov) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention) */
type LocalPositionNedCov struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X Position */
	X float32

	/* Y Position */
	Y float32

	/* Z Position */
	Z float32

	/* X Speed */
	Vx float32

	/* Y Speed */
	Vy float32

	/* Z Speed */
	Vz float32

	/* X Acceleration */
	Ax float32

	/* Y Acceleration */
	Ay float32

	/* Z Acceleration */
	Az float32

	/* Row-major representation of position, velocity and acceleration 9x9 cross-covariance matrix upper right triangle (states: x, y, z, vx, vy, vz, ax, ay, az; first nine entries are the first ROW, next eight entries are the second row, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [45]float32

	/* Class id of the estimator this estimate originated from. */
	EstimatorType MavEstimatorType // byte

}

func (m *LocalPositionNedCov) ID() int        { return 64 }
func (m *LocalPositionNedCov) CRCExtra() byte { return 191 }

func (m *LocalPositionNedCov) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))
	buf = marshalFloat32(buf, (m.Ax))
	buf = marshalFloat32(buf, (m.Ay))
	buf = marshalFloat32(buf, (m.Az))
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, byte(m.EstimatorType))

	return buf
}

func (m *LocalPositionNedCov) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LocalPositionNedCov) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)
	buf, m.Ax = unmarshalFloat32(buf)
	buf, m.Ay = unmarshalFloat32(buf)
	buf, m.Az = unmarshalFloat32(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.EstimatorType = MavEstimatorType(v)
	}

	return buf
}

func (m *LocalPositionNedCov) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.  A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification. */
type RcChannels struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* RC channel 1 value. */
	Chan1Raw uint16

	/* RC channel 2 value. */
	Chan2Raw uint16

	/* RC channel 3 value. */
	Chan3Raw uint16

	/* RC channel 4 value. */
	Chan4Raw uint16

	/* RC channel 5 value. */
	Chan5Raw uint16

	/* RC channel 6 value. */
	Chan6Raw uint16

	/* RC channel 7 value. */
	Chan7Raw uint16

	/* RC channel 8 value. */
	Chan8Raw uint16

	/* RC channel 9 value. */
	Chan9Raw uint16

	/* RC channel 10 value. */
	Chan10Raw uint16

	/* RC channel 11 value. */
	Chan11Raw uint16

	/* RC channel 12 value. */
	Chan12Raw uint16

	/* RC channel 13 value. */
	Chan13Raw uint16

	/* RC channel 14 value. */
	Chan14Raw uint16

	/* RC channel 15 value. */
	Chan15Raw uint16

	/* RC channel 16 value. */
	Chan16Raw uint16

	/* RC channel 17 value. */
	Chan17Raw uint16

	/* RC channel 18 value. */
	Chan18Raw uint16

	/* Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available. */
	Chancount byte

	/* Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown. */
	Rssi byte
}

func (m *RcChannels) ID() int        { return 65 }
func (m *RcChannels) CRCExtra() byte { return 118 }

func (m *RcChannels) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalUint16(buf, (m.Chan1Raw))
	buf = marshalUint16(buf, (m.Chan2Raw))
	buf = marshalUint16(buf, (m.Chan3Raw))
	buf = marshalUint16(buf, (m.Chan4Raw))
	buf = marshalUint16(buf, (m.Chan5Raw))
	buf = marshalUint16(buf, (m.Chan6Raw))
	buf = marshalUint16(buf, (m.Chan7Raw))
	buf = marshalUint16(buf, (m.Chan8Raw))
	buf = marshalUint16(buf, (m.Chan9Raw))
	buf = marshalUint16(buf, (m.Chan10Raw))
	buf = marshalUint16(buf, (m.Chan11Raw))
	buf = marshalUint16(buf, (m.Chan12Raw))
	buf = marshalUint16(buf, (m.Chan13Raw))
	buf = marshalUint16(buf, (m.Chan14Raw))
	buf = marshalUint16(buf, (m.Chan15Raw))
	buf = marshalUint16(buf, (m.Chan16Raw))
	buf = marshalUint16(buf, (m.Chan17Raw))
	buf = marshalUint16(buf, (m.Chan18Raw))
	buf = marshalByte(buf, (m.Chancount))
	buf = marshalByte(buf, (m.Rssi))

	return buf
}

func (m *RcChannels) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *RcChannels) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Chan1Raw = unmarshalUint16(buf)
	buf, m.Chan2Raw = unmarshalUint16(buf)
	buf, m.Chan3Raw = unmarshalUint16(buf)
	buf, m.Chan4Raw = unmarshalUint16(buf)
	buf, m.Chan5Raw = unmarshalUint16(buf)
	buf, m.Chan6Raw = unmarshalUint16(buf)
	buf, m.Chan7Raw = unmarshalUint16(buf)
	buf, m.Chan8Raw = unmarshalUint16(buf)
	buf, m.Chan9Raw = unmarshalUint16(buf)
	buf, m.Chan10Raw = unmarshalUint16(buf)
	buf, m.Chan11Raw = unmarshalUint16(buf)
	buf, m.Chan12Raw = unmarshalUint16(buf)
	buf, m.Chan13Raw = unmarshalUint16(buf)
	buf, m.Chan14Raw = unmarshalUint16(buf)
	buf, m.Chan15Raw = unmarshalUint16(buf)
	buf, m.Chan16Raw = unmarshalUint16(buf)
	buf, m.Chan17Raw = unmarshalUint16(buf)
	buf, m.Chan18Raw = unmarshalUint16(buf)
	buf, m.Chancount = unmarshalByte(buf)
	buf, m.Rssi = unmarshalByte(buf)

	return buf
}

func (m *RcChannels) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request a data stream. */
type RequestDataStream struct {
	/* The requested message rate */
	ReqMessageRate uint16

	/* The target requested to send the message stream. */
	TargetSystem byte

	/* The target requested to send the message stream. */
	TargetComponent byte

	/* The ID of the requested data stream */
	ReqStreamId byte

	/* 1 to start sending, 0 to stop sending. */
	StartStop byte
}

func (m *RequestDataStream) ID() int        { return 66 }
func (m *RequestDataStream) CRCExtra() byte { return 148 }

func (m *RequestDataStream) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.ReqMessageRate))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, (m.ReqStreamId))
	buf = marshalByte(buf, (m.StartStop))

	return buf
}

func (m *RequestDataStream) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *RequestDataStream) UnmarshalV1(buf []byte) []byte {
	buf, m.ReqMessageRate = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	buf, m.ReqStreamId = unmarshalByte(buf)
	buf, m.StartStop = unmarshalByte(buf)

	return buf
}

func (m *RequestDataStream) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Data stream status information. */
type DataStream struct {
	/* The message rate */
	MessageRate uint16

	/* The ID of the requested data stream */
	StreamId byte

	/* 1 stream is enabled, 0 stream is stopped. */
	OnOff byte
}

func (m *DataStream) ID() int        { return 67 }
func (m *DataStream) CRCExtra() byte { return 21 }

func (m *DataStream) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.MessageRate))
	buf = marshalByte(buf, (m.StreamId))
	buf = marshalByte(buf, (m.OnOff))

	return buf
}

func (m *DataStream) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *DataStream) UnmarshalV1(buf []byte) []byte {
	buf, m.MessageRate = unmarshalUint16(buf)
	buf, m.StreamId = unmarshalByte(buf)
	buf, m.OnOff = unmarshalByte(buf)

	return buf
}

func (m *DataStream) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled an buttons are also transmit as boolean values of their  */
type ManualControl struct {
	/* X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle. */
	X int16

	/* Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle. */
	Y int16

	/* Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust. */
	Z int16

	/* R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle. */
	R int16

	/* A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1. */
	Buttons uint16

	/* The system to be controlled. */
	Target byte
}

func (m *ManualControl) ID() int        { return 69 }
func (m *ManualControl) CRCExtra() byte { return 243 }

func (m *ManualControl) MarshalV1(buf []byte) []byte {
	buf = marshalInt16(buf, (m.X))
	buf = marshalInt16(buf, (m.Y))
	buf = marshalInt16(buf, (m.Z))
	buf = marshalInt16(buf, (m.R))
	buf = marshalUint16(buf, (m.Buttons))
	buf = marshalByte(buf, (m.Target))

	return buf
}

func (m *ManualControl) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ManualControl) UnmarshalV1(buf []byte) []byte {
	buf, m.X = unmarshalInt16(buf)
	buf, m.Y = unmarshalInt16(buf)
	buf, m.Z = unmarshalInt16(buf)
	buf, m.R = unmarshalInt16(buf)
	buf, m.Buttons = unmarshalUint16(buf)
	buf, m.Target = unmarshalByte(buf)

	return buf
}

func (m *ManualControl) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW values of the RC channels sent to the MAV to override info received from the RC radio. A value of UINT16_MAX means no change to that channel. A value of 0 means control of that channel should be released back to the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification. */
type RcChannelsOverride struct {
	/* RC channel 1 value. A value of UINT16_MAX means to ignore this field. */
	Chan1Raw uint16

	/* RC channel 2 value. A value of UINT16_MAX means to ignore this field. */
	Chan2Raw uint16

	/* RC channel 3 value. A value of UINT16_MAX means to ignore this field. */
	Chan3Raw uint16

	/* RC channel 4 value. A value of UINT16_MAX means to ignore this field. */
	Chan4Raw uint16

	/* RC channel 5 value. A value of UINT16_MAX means to ignore this field. */
	Chan5Raw uint16

	/* RC channel 6 value. A value of UINT16_MAX means to ignore this field. */
	Chan6Raw uint16

	/* RC channel 7 value. A value of UINT16_MAX means to ignore this field. */
	Chan7Raw uint16

	/* RC channel 8 value. A value of UINT16_MAX means to ignore this field. */
	Chan8Raw uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* RC channel 9 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan9Raw uint16 /*EXTENSION*/

	/* RC channel 10 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan10Raw uint16 /*EXTENSION*/

	/* RC channel 11 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan11Raw uint16 /*EXTENSION*/

	/* RC channel 12 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan12Raw uint16 /*EXTENSION*/

	/* RC channel 13 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan13Raw uint16 /*EXTENSION*/

	/* RC channel 14 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan14Raw uint16 /*EXTENSION*/

	/* RC channel 15 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan15Raw uint16 /*EXTENSION*/

	/* RC channel 16 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan16Raw uint16 /*EXTENSION*/

	/* RC channel 17 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan17Raw uint16 /*EXTENSION*/

	/* RC channel 18 value. A value of 0 or UINT16_MAX means to ignore this field. */
	Chan18Raw uint16 /*EXTENSION*/

}

func (m *RcChannelsOverride) ID() int        { return 70 }
func (m *RcChannelsOverride) CRCExtra() byte { return 124 }

func (m *RcChannelsOverride) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Chan1Raw))
	buf = marshalUint16(buf, (m.Chan2Raw))
	buf = marshalUint16(buf, (m.Chan3Raw))
	buf = marshalUint16(buf, (m.Chan4Raw))
	buf = marshalUint16(buf, (m.Chan5Raw))
	buf = marshalUint16(buf, (m.Chan6Raw))
	buf = marshalUint16(buf, (m.Chan7Raw))
	buf = marshalUint16(buf, (m.Chan8Raw))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *RcChannelsOverride) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalUint16(buf, (m.Chan9Raw))
	buf = marshalUint16(buf, (m.Chan10Raw))
	buf = marshalUint16(buf, (m.Chan11Raw))
	buf = marshalUint16(buf, (m.Chan12Raw))
	buf = marshalUint16(buf, (m.Chan13Raw))
	buf = marshalUint16(buf, (m.Chan14Raw))
	buf = marshalUint16(buf, (m.Chan15Raw))
	buf = marshalUint16(buf, (m.Chan16Raw))
	buf = marshalUint16(buf, (m.Chan17Raw))
	buf = marshalUint16(buf, (m.Chan18Raw))

	return buf
}

func (m *RcChannelsOverride) UnmarshalV1(buf []byte) []byte {
	buf, m.Chan1Raw = unmarshalUint16(buf)
	buf, m.Chan2Raw = unmarshalUint16(buf)
	buf, m.Chan3Raw = unmarshalUint16(buf)
	buf, m.Chan4Raw = unmarshalUint16(buf)
	buf, m.Chan5Raw = unmarshalUint16(buf)
	buf, m.Chan6Raw = unmarshalUint16(buf)
	buf, m.Chan7Raw = unmarshalUint16(buf)
	buf, m.Chan8Raw = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *RcChannelsOverride) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.Chan9Raw = unmarshalUint16(buf)
	buf, m.Chan10Raw = unmarshalUint16(buf)
	buf, m.Chan11Raw = unmarshalUint16(buf)
	buf, m.Chan12Raw = unmarshalUint16(buf)
	buf, m.Chan13Raw = unmarshalUint16(buf)
	buf, m.Chan14Raw = unmarshalUint16(buf)
	buf, m.Chan15Raw = unmarshalUint16(buf)
	buf, m.Chan16Raw = unmarshalUint16(buf)
	buf, m.Chan17Raw = unmarshalUint16(buf)
	buf, m.Chan18Raw = unmarshalUint16(buf)

	return buf
}

/* Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See also https://mavlink.io/en/services/mission.html. */
type MissionItemInt struct {
	/* PARAM1, see MAV_CMD enum */
	Param1 float32

	/* PARAM2, see MAV_CMD enum */
	Param2 float32

	/* PARAM3, see MAV_CMD enum */
	Param3 float32

	/* PARAM4, see MAV_CMD enum */
	Param4 float32

	/* PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7 */
	X int32

	/* PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7 */
	Y int32

	/* PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame. */
	Z float32

	/* Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4). */
	Seq uint16

	/* The scheduled action for the waypoint. */
	Command MavCmd // uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* The coordinate system of the waypoint. */
	Frame MavFrame // byte

	/* false:0, true:1 */
	Current byte

	/* Autocontinue to next waypoint */
	Autocontinue byte

	/* Mission type. */
	MissionType MavMissionType // byte /*EXTENSION*/

}

func (m *MissionItemInt) ID() int        { return 73 }
func (m *MissionItemInt) CRCExtra() byte { return 38 }

func (m *MissionItemInt) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Param1))
	buf = marshalFloat32(buf, (m.Param2))
	buf = marshalFloat32(buf, (m.Param3))
	buf = marshalFloat32(buf, (m.Param4))
	buf = marshalInt32(buf, (m.X))
	buf = marshalInt32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalUint16(buf, (m.Seq))
	buf = marshalUint16(buf, uint16(m.Command))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, byte(m.Frame))
	buf = marshalByte(buf, (m.Current))
	buf = marshalByte(buf, (m.Autocontinue))

	return buf
}

func (m *MissionItemInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, byte(m.MissionType))

	return buf
}

func (m *MissionItemInt) UnmarshalV1(buf []byte) []byte {
	buf, m.Param1 = unmarshalFloat32(buf)
	buf, m.Param2 = unmarshalFloat32(buf)
	buf, m.Param3 = unmarshalFloat32(buf)
	buf, m.Param4 = unmarshalFloat32(buf)
	buf, m.X = unmarshalInt32(buf)
	buf, m.Y = unmarshalInt32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Seq = unmarshalUint16(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Command = MavCmd(v)
	}
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Frame = MavFrame(v)
	}
	buf, m.Current = unmarshalByte(buf)
	buf, m.Autocontinue = unmarshalByte(buf)

	return buf
}

func (m *MissionItemInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.MissionType = MavMissionType(v)
	}

	return buf
}

/* Metrics typically displayed on a HUD for fixed wing aircraft. */
type VfrHud struct {
	/* Current indicated airspeed (IAS). */
	Airspeed float32

	/* Current ground speed. */
	Groundspeed float32

	/* Current altitude (MSL). */
	Alt float32

	/* Current climb rate. */
	Climb float32

	/* Current heading in compass units (0-360, 0=north). */
	Heading int16

	/* Current throttle setting (0 to 100). */
	Throttle uint16
}

func (m *VfrHud) ID() int        { return 74 }
func (m *VfrHud) CRCExtra() byte { return 20 }

func (m *VfrHud) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Airspeed))
	buf = marshalFloat32(buf, (m.Groundspeed))
	buf = marshalFloat32(buf, (m.Alt))
	buf = marshalFloat32(buf, (m.Climb))
	buf = marshalInt16(buf, (m.Heading))
	buf = marshalUint16(buf, (m.Throttle))

	return buf
}

func (m *VfrHud) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *VfrHud) UnmarshalV1(buf []byte) []byte {
	buf, m.Airspeed = unmarshalFloat32(buf)
	buf, m.Groundspeed = unmarshalFloat32(buf)
	buf, m.Alt = unmarshalFloat32(buf)
	buf, m.Climb = unmarshalFloat32(buf)
	buf, m.Heading = unmarshalInt16(buf)
	buf, m.Throttle = unmarshalUint16(buf)

	return buf
}

func (m *VfrHud) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value. The command microservice is documented at https://mavlink.io/en/services/command.html */
type CommandInt struct {
	/* PARAM1, see MAV_CMD enum */
	Param1 float32

	/* PARAM2, see MAV_CMD enum */
	Param2 float32

	/* PARAM3, see MAV_CMD enum */
	Param3 float32

	/* PARAM4, see MAV_CMD enum */
	Param4 float32

	/* PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7 */
	X int32

	/* PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7 */
	Y int32

	/* PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame). */
	Z float32

	/* The scheduled action for the mission item. */
	Command MavCmd // uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* The coordinate system of the COMMAND. */
	Frame MavFrame // byte

	/* false:0, true:1 */
	Current byte

	/* autocontinue to next wp */
	Autocontinue byte
}

func (m *CommandInt) ID() int        { return 75 }
func (m *CommandInt) CRCExtra() byte { return 158 }

func (m *CommandInt) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Param1))
	buf = marshalFloat32(buf, (m.Param2))
	buf = marshalFloat32(buf, (m.Param3))
	buf = marshalFloat32(buf, (m.Param4))
	buf = marshalInt32(buf, (m.X))
	buf = marshalInt32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalUint16(buf, uint16(m.Command))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, byte(m.Frame))
	buf = marshalByte(buf, (m.Current))
	buf = marshalByte(buf, (m.Autocontinue))

	return buf
}

func (m *CommandInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *CommandInt) UnmarshalV1(buf []byte) []byte {
	buf, m.Param1 = unmarshalFloat32(buf)
	buf, m.Param2 = unmarshalFloat32(buf)
	buf, m.Param3 = unmarshalFloat32(buf)
	buf, m.Param4 = unmarshalFloat32(buf)
	buf, m.X = unmarshalInt32(buf)
	buf, m.Y = unmarshalInt32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Command = MavCmd(v)
	}
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Frame = MavFrame(v)
	}
	buf, m.Current = unmarshalByte(buf)
	buf, m.Autocontinue = unmarshalByte(buf)

	return buf
}

func (m *CommandInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Send a command with up to seven parameters to the MAV. The command microservice is documented at https://mavlink.io/en/services/command.html */
type CommandLong struct {
	/* Parameter 1 (for the specific command). */
	Param1 float32

	/* Parameter 2 (for the specific command). */
	Param2 float32

	/* Parameter 3 (for the specific command). */
	Param3 float32

	/* Parameter 4 (for the specific command). */
	Param4 float32

	/* Parameter 5 (for the specific command). */
	Param5 float32

	/* Parameter 6 (for the specific command). */
	Param6 float32

	/* Parameter 7 (for the specific command). */
	Param7 float32

	/* Command ID (of command to send). */
	Command MavCmd // uint16

	/* System which should execute the command */
	TargetSystem byte

	/* Component which should execute the command, 0 for all components */
	TargetComponent byte

	/* 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command) */
	Confirmation byte
}

func (m *CommandLong) ID() int        { return 76 }
func (m *CommandLong) CRCExtra() byte { return 152 }

func (m *CommandLong) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Param1))
	buf = marshalFloat32(buf, (m.Param2))
	buf = marshalFloat32(buf, (m.Param3))
	buf = marshalFloat32(buf, (m.Param4))
	buf = marshalFloat32(buf, (m.Param5))
	buf = marshalFloat32(buf, (m.Param6))
	buf = marshalFloat32(buf, (m.Param7))
	buf = marshalUint16(buf, uint16(m.Command))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, (m.Confirmation))

	return buf
}

func (m *CommandLong) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *CommandLong) UnmarshalV1(buf []byte) []byte {
	buf, m.Param1 = unmarshalFloat32(buf)
	buf, m.Param2 = unmarshalFloat32(buf)
	buf, m.Param3 = unmarshalFloat32(buf)
	buf, m.Param4 = unmarshalFloat32(buf)
	buf, m.Param5 = unmarshalFloat32(buf)
	buf, m.Param6 = unmarshalFloat32(buf)
	buf, m.Param7 = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Command = MavCmd(v)
	}
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	buf, m.Confirmation = unmarshalByte(buf)

	return buf
}

func (m *CommandLong) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Report status of a command. Includes feedback whether the command was executed. The command microservice is documented at https://mavlink.io/en/services/command.html */
type CommandAck struct {
	/* Command ID (of acknowledged command). */
	Command MavCmd // uint16

	/* Result of command. */
	Result MavResult // byte

	/* WIP: Additional parameter of the result, example: which parameter of MAV_CMD_NAV_WAYPOINT caused it to be denied. */
	ResultParam2 int32 /*EXTENSION*/

	/* WIP: Also used as result_param1, it can be set with a enum containing the errors reasons of why the command was denied or the progress percentage or 255 if unknown the progress when result is MAV_RESULT_IN_PROGRESS. */
	Progress byte /*EXTENSION*/

	/* WIP: System which requested the command to be executed */
	TargetSystem byte /*EXTENSION*/

	/* WIP: Component which requested the command to be executed */
	TargetComponent byte /*EXTENSION*/

}

func (m *CommandAck) ID() int        { return 77 }
func (m *CommandAck) CRCExtra() byte { return 143 }

func (m *CommandAck) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, uint16(m.Command))
	buf = marshalByte(buf, byte(m.Result))

	return buf
}

func (m *CommandAck) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalInt32(buf, (m.ResultParam2))
	buf = marshalByte(buf, (m.Progress))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *CommandAck) UnmarshalV1(buf []byte) []byte {
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Command = MavCmd(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Result = MavResult(v)
	}

	return buf
}

func (m *CommandAck) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.ResultParam2 = unmarshalInt32(buf)
	buf, m.Progress = unmarshalByte(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

/* Setpoint in roll, pitch, yaw and thrust from the operator */
type ManualSetpoint struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Desired roll rate */
	Roll float32

	/* Desired pitch rate */
	Pitch float32

	/* Desired yaw rate */
	Yaw float32

	/* Collective thrust, normalized to 0 .. 1 */
	Thrust float32

	/* Flight mode switch position, 0.. 255 */
	ModeSwitch byte

	/* Override mode switch position, 0.. 255 */
	ManualOverrideSwitch byte
}

func (m *ManualSetpoint) ID() int        { return 81 }
func (m *ManualSetpoint) CRCExtra() byte { return 106 }

func (m *ManualSetpoint) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.Thrust))
	buf = marshalByte(buf, (m.ModeSwitch))
	buf = marshalByte(buf, (m.ManualOverrideSwitch))

	return buf
}

func (m *ManualSetpoint) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ManualSetpoint) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.Thrust = unmarshalFloat32(buf)
	buf, m.ModeSwitch = unmarshalByte(buf)
	buf, m.ManualOverrideSwitch = unmarshalByte(buf)

	return buf
}

func (m *ManualSetpoint) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system). */
type SetAttitudeTarget struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) */
	Q [4]float32

	/* Body roll rate */
	BodyRollRate float32

	/* Body pitch rate */
	BodyPitchRate float32

	/* Body yaw rate */
	BodyYawRate float32

	/* Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) */
	Thrust float32

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude */
	TypeMask byte
}

func (m *SetAttitudeTarget) ID() int        { return 82 }
func (m *SetAttitudeTarget) CRCExtra() byte { return 49 }

func (m *SetAttitudeTarget) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.BodyRollRate))
	buf = marshalFloat32(buf, (m.BodyPitchRate))
	buf = marshalFloat32(buf, (m.BodyYawRate))
	buf = marshalFloat32(buf, (m.Thrust))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, (m.TypeMask))

	return buf
}

func (m *SetAttitudeTarget) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SetAttitudeTarget) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.BodyRollRate = unmarshalFloat32(buf)
	buf, m.BodyPitchRate = unmarshalFloat32(buf)
	buf, m.BodyYawRate = unmarshalFloat32(buf)
	buf, m.Thrust = unmarshalFloat32(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	buf, m.TypeMask = unmarshalByte(buf)

	return buf
}

func (m *SetAttitudeTarget) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way. */
type AttitudeTarget struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) */
	Q [4]float32

	/* Body roll rate */
	BodyRollRate float32

	/* Body pitch rate */
	BodyPitchRate float32

	/* Body yaw rate */
	BodyYawRate float32

	/* Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust) */
	Thrust float32

	/* Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude */
	TypeMask byte
}

func (m *AttitudeTarget) ID() int        { return 83 }
func (m *AttitudeTarget) CRCExtra() byte { return 22 }

func (m *AttitudeTarget) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.BodyRollRate))
	buf = marshalFloat32(buf, (m.BodyPitchRate))
	buf = marshalFloat32(buf, (m.BodyYawRate))
	buf = marshalFloat32(buf, (m.Thrust))
	buf = marshalByte(buf, (m.TypeMask))

	return buf
}

func (m *AttitudeTarget) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *AttitudeTarget) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.BodyRollRate = unmarshalFloat32(buf)
	buf, m.BodyPitchRate = unmarshalFloat32(buf)
	buf, m.BodyYawRate = unmarshalFloat32(buf)
	buf, m.Thrust = unmarshalFloat32(buf)
	buf, m.TypeMask = unmarshalByte(buf)

	return buf
}

func (m *AttitudeTarget) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system). */
type SetPositionTargetLocalNed struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* X Position in NED frame */
	X float32

	/* Y Position in NED frame */
	Y float32

	/* Z Position in NED frame (note, altitude is negative in NED) */
	Z float32

	/* X velocity in NED frame */
	Vx float32

	/* Y velocity in NED frame */
	Vy float32

	/* Z velocity in NED frame */
	Vz float32

	/* X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afx float32

	/* Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afy float32

	/* Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afz float32

	/* yaw setpoint */
	Yaw float32

	/* yaw rate setpoint */
	YawRate float32

	/* Bitmap to indicate which dimensions should be ignored by the vehicle. */
	TypeMask PositionTargetTypemask // uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9 */
	CoordinateFrame MavFrame // byte

}

func (m *SetPositionTargetLocalNed) ID() int        { return 84 }
func (m *SetPositionTargetLocalNed) CRCExtra() byte { return 143 }

func (m *SetPositionTargetLocalNed) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))
	buf = marshalFloat32(buf, (m.Afx))
	buf = marshalFloat32(buf, (m.Afy))
	buf = marshalFloat32(buf, (m.Afz))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.YawRate))
	buf = marshalUint16(buf, uint16(m.TypeMask))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, byte(m.CoordinateFrame))

	return buf
}

func (m *SetPositionTargetLocalNed) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SetPositionTargetLocalNed) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)
	buf, m.Afx = unmarshalFloat32(buf)
	buf, m.Afy = unmarshalFloat32(buf)
	buf, m.Afz = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.YawRate = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.TypeMask = PositionTargetTypemask(v)
	}
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.CoordinateFrame = MavFrame(v)
	}

	return buf
}

func (m *SetPositionTargetLocalNed) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way. */
type PositionTargetLocalNed struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* X Position in NED frame */
	X float32

	/* Y Position in NED frame */
	Y float32

	/* Z Position in NED frame (note, altitude is negative in NED) */
	Z float32

	/* X velocity in NED frame */
	Vx float32

	/* Y velocity in NED frame */
	Vy float32

	/* Z velocity in NED frame */
	Vz float32

	/* X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afx float32

	/* Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afy float32

	/* Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afz float32

	/* yaw setpoint */
	Yaw float32

	/* yaw rate setpoint */
	YawRate float32

	/* Bitmap to indicate which dimensions should be ignored by the vehicle. */
	TypeMask PositionTargetTypemask // uint16

	/* Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9 */
	CoordinateFrame MavFrame // byte

}

func (m *PositionTargetLocalNed) ID() int        { return 85 }
func (m *PositionTargetLocalNed) CRCExtra() byte { return 140 }

func (m *PositionTargetLocalNed) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))
	buf = marshalFloat32(buf, (m.Afx))
	buf = marshalFloat32(buf, (m.Afy))
	buf = marshalFloat32(buf, (m.Afz))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.YawRate))
	buf = marshalUint16(buf, uint16(m.TypeMask))
	buf = marshalByte(buf, byte(m.CoordinateFrame))

	return buf
}

func (m *PositionTargetLocalNed) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *PositionTargetLocalNed) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)
	buf, m.Afx = unmarshalFloat32(buf)
	buf, m.Afy = unmarshalFloat32(buf)
	buf, m.Afz = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.YawRate = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.TypeMask = PositionTargetTypemask(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.CoordinateFrame = MavFrame(v)
	}

	return buf
}

func (m *PositionTargetLocalNed) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system). */
type SetPositionTargetGlobalInt struct {
	/* Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency. */
	TimeBootMs uint32

	/* X Position in WGS84 frame */
	LatInt int32

	/* Y Position in WGS84 frame */
	LonInt int32

	/* Altitude (MSL, Relative to home, or AGL - depending on frame) */
	Alt float32

	/* X velocity in NED frame */
	Vx float32

	/* Y velocity in NED frame */
	Vy float32

	/* Z velocity in NED frame */
	Vz float32

	/* X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afx float32

	/* Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afy float32

	/* Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afz float32

	/* yaw setpoint */
	Yaw float32

	/* yaw rate setpoint */
	YawRate float32

	/* Bitmap to indicate which dimensions should be ignored by the vehicle. */
	TypeMask PositionTargetTypemask // uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11 */
	CoordinateFrame MavFrame // byte

}

func (m *SetPositionTargetGlobalInt) ID() int        { return 86 }
func (m *SetPositionTargetGlobalInt) CRCExtra() byte { return 5 }

func (m *SetPositionTargetGlobalInt) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt32(buf, (m.LatInt))
	buf = marshalInt32(buf, (m.LonInt))
	buf = marshalFloat32(buf, (m.Alt))
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))
	buf = marshalFloat32(buf, (m.Afx))
	buf = marshalFloat32(buf, (m.Afy))
	buf = marshalFloat32(buf, (m.Afz))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.YawRate))
	buf = marshalUint16(buf, uint16(m.TypeMask))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, byte(m.CoordinateFrame))

	return buf
}

func (m *SetPositionTargetGlobalInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SetPositionTargetGlobalInt) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.LatInt = unmarshalInt32(buf)
	buf, m.LonInt = unmarshalInt32(buf)
	buf, m.Alt = unmarshalFloat32(buf)
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)
	buf, m.Afx = unmarshalFloat32(buf)
	buf, m.Afy = unmarshalFloat32(buf)
	buf, m.Afz = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.YawRate = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.TypeMask = PositionTargetTypemask(v)
	}
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.CoordinateFrame = MavFrame(v)
	}

	return buf
}

func (m *SetPositionTargetGlobalInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way. */
type PositionTargetGlobalInt struct {
	/* Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency. */
	TimeBootMs uint32

	/* X Position in WGS84 frame */
	LatInt int32

	/* Y Position in WGS84 frame */
	LonInt int32

	/* Altitude (MSL, AGL or relative to home altitude, depending on frame) */
	Alt float32

	/* X velocity in NED frame */
	Vx float32

	/* Y velocity in NED frame */
	Vy float32

	/* Z velocity in NED frame */
	Vz float32

	/* X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afx float32

	/* Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afy float32

	/* Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N */
	Afz float32

	/* yaw setpoint */
	Yaw float32

	/* yaw rate setpoint */
	YawRate float32

	/* Bitmap to indicate which dimensions should be ignored by the vehicle. */
	TypeMask PositionTargetTypemask // uint16

	/* Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11 */
	CoordinateFrame MavFrame // byte

}

func (m *PositionTargetGlobalInt) ID() int        { return 87 }
func (m *PositionTargetGlobalInt) CRCExtra() byte { return 150 }

func (m *PositionTargetGlobalInt) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt32(buf, (m.LatInt))
	buf = marshalInt32(buf, (m.LonInt))
	buf = marshalFloat32(buf, (m.Alt))
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))
	buf = marshalFloat32(buf, (m.Afx))
	buf = marshalFloat32(buf, (m.Afy))
	buf = marshalFloat32(buf, (m.Afz))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.YawRate))
	buf = marshalUint16(buf, uint16(m.TypeMask))
	buf = marshalByte(buf, byte(m.CoordinateFrame))

	return buf
}

func (m *PositionTargetGlobalInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *PositionTargetGlobalInt) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.LatInt = unmarshalInt32(buf)
	buf, m.LonInt = unmarshalInt32(buf)
	buf, m.Alt = unmarshalFloat32(buf)
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)
	buf, m.Afx = unmarshalFloat32(buf)
	buf, m.Afy = unmarshalFloat32(buf)
	buf, m.Afz = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.YawRate = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.TypeMask = PositionTargetTypemask(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.CoordinateFrame = MavFrame(v)
	}

	return buf
}

func (m *PositionTargetGlobalInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention) */
type LocalPositionNedSystemGlobalOffset struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* X Position */
	X float32

	/* Y Position */
	Y float32

	/* Z Position */
	Z float32

	/* Roll */
	Roll float32

	/* Pitch */
	Pitch float32

	/* Yaw */
	Yaw float32
}

func (m *LocalPositionNedSystemGlobalOffset) ID() int        { return 89 }
func (m *LocalPositionNedSystemGlobalOffset) CRCExtra() byte { return 231 }

func (m *LocalPositionNedSystemGlobalOffset) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))

	return buf
}

func (m *LocalPositionNedSystemGlobalOffset) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LocalPositionNedSystemGlobalOffset) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)

	return buf
}

func (m *LocalPositionNedSystemGlobalOffset) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations. */
type HilState struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Roll angle */
	Roll float32

	/* Pitch angle */
	Pitch float32

	/* Yaw angle */
	Yaw float32

	/* Body frame roll / phi angular speed */
	Rollspeed float32

	/* Body frame pitch / theta angular speed */
	Pitchspeed float32

	/* Body frame yaw / psi angular speed */
	Yawspeed float32

	/* Latitude */
	Lat int32

	/* Longitude */
	Lon int32

	/* Altitude */
	Alt int32

	/* Ground X Speed (Latitude) */
	Vx int16

	/* Ground Y Speed (Longitude) */
	Vy int16

	/* Ground Z Speed (Altitude) */
	Vz int16

	/* X acceleration */
	Xacc int16

	/* Y acceleration */
	Yacc int16

	/* Z acceleration */
	Zacc int16
}

func (m *HilState) ID() int        { return 90 }
func (m *HilState) CRCExtra() byte { return 183 }

func (m *HilState) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.Rollspeed))
	buf = marshalFloat32(buf, (m.Pitchspeed))
	buf = marshalFloat32(buf, (m.Yawspeed))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalInt16(buf, (m.Vx))
	buf = marshalInt16(buf, (m.Vy))
	buf = marshalInt16(buf, (m.Vz))
	buf = marshalInt16(buf, (m.Xacc))
	buf = marshalInt16(buf, (m.Yacc))
	buf = marshalInt16(buf, (m.Zacc))

	return buf
}

func (m *HilState) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilState) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.Rollspeed = unmarshalFloat32(buf)
	buf, m.Pitchspeed = unmarshalFloat32(buf)
	buf, m.Yawspeed = unmarshalFloat32(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.Vx = unmarshalInt16(buf)
	buf, m.Vy = unmarshalInt16(buf)
	buf, m.Vz = unmarshalInt16(buf)
	buf, m.Xacc = unmarshalInt16(buf)
	buf, m.Yacc = unmarshalInt16(buf)
	buf, m.Zacc = unmarshalInt16(buf)

	return buf
}

func (m *HilState) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sent from autopilot to simulation. Hardware in the loop control outputs */
type HilControls struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Control output -1 .. 1 */
	RollAilerons float32

	/* Control output -1 .. 1 */
	PitchElevator float32

	/* Control output -1 .. 1 */
	YawRudder float32

	/* Throttle 0 .. 1 */
	Throttle float32

	/* Aux 1, -1 .. 1 */
	Aux1 float32

	/* Aux 2, -1 .. 1 */
	Aux2 float32

	/* Aux 3, -1 .. 1 */
	Aux3 float32

	/* Aux 4, -1 .. 1 */
	Aux4 float32

	/* System mode. */
	Mode MavMode // byte

	/* Navigation mode (MAV_NAV_MODE) */
	NavMode byte
}

func (m *HilControls) ID() int        { return 91 }
func (m *HilControls) CRCExtra() byte { return 63 }

func (m *HilControls) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.RollAilerons))
	buf = marshalFloat32(buf, (m.PitchElevator))
	buf = marshalFloat32(buf, (m.YawRudder))
	buf = marshalFloat32(buf, (m.Throttle))
	buf = marshalFloat32(buf, (m.Aux1))
	buf = marshalFloat32(buf, (m.Aux2))
	buf = marshalFloat32(buf, (m.Aux3))
	buf = marshalFloat32(buf, (m.Aux4))
	buf = marshalByte(buf, byte(m.Mode))
	buf = marshalByte(buf, (m.NavMode))

	return buf
}

func (m *HilControls) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilControls) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.RollAilerons = unmarshalFloat32(buf)
	buf, m.PitchElevator = unmarshalFloat32(buf)
	buf, m.YawRudder = unmarshalFloat32(buf)
	buf, m.Throttle = unmarshalFloat32(buf)
	buf, m.Aux1 = unmarshalFloat32(buf)
	buf, m.Aux2 = unmarshalFloat32(buf)
	buf, m.Aux3 = unmarshalFloat32(buf)
	buf, m.Aux4 = unmarshalFloat32(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Mode = MavMode(v)
	}
	buf, m.NavMode = unmarshalByte(buf)

	return buf
}

func (m *HilControls) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification. */
type HilRcInputsRaw struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* RC channel 1 value */
	Chan1Raw uint16

	/* RC channel 2 value */
	Chan2Raw uint16

	/* RC channel 3 value */
	Chan3Raw uint16

	/* RC channel 4 value */
	Chan4Raw uint16

	/* RC channel 5 value */
	Chan5Raw uint16

	/* RC channel 6 value */
	Chan6Raw uint16

	/* RC channel 7 value */
	Chan7Raw uint16

	/* RC channel 8 value */
	Chan8Raw uint16

	/* RC channel 9 value */
	Chan9Raw uint16

	/* RC channel 10 value */
	Chan10Raw uint16

	/* RC channel 11 value */
	Chan11Raw uint16

	/* RC channel 12 value */
	Chan12Raw uint16

	/* Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown. */
	Rssi byte
}

func (m *HilRcInputsRaw) ID() int        { return 92 }
func (m *HilRcInputsRaw) CRCExtra() byte { return 54 }

func (m *HilRcInputsRaw) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint16(buf, (m.Chan1Raw))
	buf = marshalUint16(buf, (m.Chan2Raw))
	buf = marshalUint16(buf, (m.Chan3Raw))
	buf = marshalUint16(buf, (m.Chan4Raw))
	buf = marshalUint16(buf, (m.Chan5Raw))
	buf = marshalUint16(buf, (m.Chan6Raw))
	buf = marshalUint16(buf, (m.Chan7Raw))
	buf = marshalUint16(buf, (m.Chan8Raw))
	buf = marshalUint16(buf, (m.Chan9Raw))
	buf = marshalUint16(buf, (m.Chan10Raw))
	buf = marshalUint16(buf, (m.Chan11Raw))
	buf = marshalUint16(buf, (m.Chan12Raw))
	buf = marshalByte(buf, (m.Rssi))

	return buf
}

func (m *HilRcInputsRaw) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilRcInputsRaw) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Chan1Raw = unmarshalUint16(buf)
	buf, m.Chan2Raw = unmarshalUint16(buf)
	buf, m.Chan3Raw = unmarshalUint16(buf)
	buf, m.Chan4Raw = unmarshalUint16(buf)
	buf, m.Chan5Raw = unmarshalUint16(buf)
	buf, m.Chan6Raw = unmarshalUint16(buf)
	buf, m.Chan7Raw = unmarshalUint16(buf)
	buf, m.Chan8Raw = unmarshalUint16(buf)
	buf, m.Chan9Raw = unmarshalUint16(buf)
	buf, m.Chan10Raw = unmarshalUint16(buf)
	buf, m.Chan11Raw = unmarshalUint16(buf)
	buf, m.Chan12Raw = unmarshalUint16(buf)
	buf, m.Rssi = unmarshalByte(buf)

	return buf
}

func (m *HilRcInputsRaw) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS) */
type HilActuatorControls struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Flags as bitfield, reserved for future use. */
	Flags uint64

	/* Control outputs -1 .. 1. Channel assignment depends on the simulated hardware. */
	Controls [16]float32

	/* System mode. Includes arming state. */
	Mode MavModeFlag // byte

}

func (m *HilActuatorControls) ID() int        { return 93 }
func (m *HilActuatorControls) CRCExtra() byte { return 47 }

func (m *HilActuatorControls) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint64(buf, (m.Flags))
	for _, v := range m.Controls {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, byte(m.Mode))

	return buf
}

func (m *HilActuatorControls) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilActuatorControls) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Flags = unmarshalUint64(buf)
	for i, _ := range m.Controls {
		buf, m.Controls[i] = unmarshalFloat32(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Mode = MavModeFlag(v)
	}

	return buf
}

func (m *HilActuatorControls) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Optical flow from a flow sensor (e.g. optical mouse sensor) */
type OpticalFlow struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Flow in x-sensor direction, angular-speed compensated */
	FlowCompMX float32

	/* Flow in y-sensor direction, angular-speed compensated */
	FlowCompMY float32

	/* Ground distance. Positive value: distance known. Negative value: Unknown distance */
	GroundDistance float32

	/* Flow in x-sensor direction */
	FlowX int16

	/* Flow in y-sensor direction */
	FlowY int16

	/* Sensor ID */
	SensorId byte

	/* Optical flow quality / confidence. 0: bad, 255: maximum quality */
	Quality byte

	/* Flow rate about X axis */
	FlowRateX float32 /*EXTENSION*/

	/* Flow rate about Y axis */
	FlowRateY float32 /*EXTENSION*/

}

func (m *OpticalFlow) ID() int        { return 100 }
func (m *OpticalFlow) CRCExtra() byte { return 175 }

func (m *OpticalFlow) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.FlowCompMX))
	buf = marshalFloat32(buf, (m.FlowCompMY))
	buf = marshalFloat32(buf, (m.GroundDistance))
	buf = marshalInt16(buf, (m.FlowX))
	buf = marshalInt16(buf, (m.FlowY))
	buf = marshalByte(buf, (m.SensorId))
	buf = marshalByte(buf, (m.Quality))

	return buf
}

func (m *OpticalFlow) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalFloat32(buf, (m.FlowRateX))
	buf = marshalFloat32(buf, (m.FlowRateY))

	return buf
}

func (m *OpticalFlow) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.FlowCompMX = unmarshalFloat32(buf)
	buf, m.FlowCompMY = unmarshalFloat32(buf)
	buf, m.GroundDistance = unmarshalFloat32(buf)
	buf, m.FlowX = unmarshalInt16(buf)
	buf, m.FlowY = unmarshalInt16(buf)
	buf, m.SensorId = unmarshalByte(buf)
	buf, m.Quality = unmarshalByte(buf)

	return buf
}

func (m *OpticalFlow) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.FlowRateX = unmarshalFloat32(buf)
	buf, m.FlowRateY = unmarshalFloat32(buf)

	return buf
}

/* Global position/attitude estimate from a vision source. */
type GlobalVisionPositionEstimate struct {
	/* Timestamp (UNIX time or since system boot) */
	Usec uint64

	/* Global X position */
	X float32

	/* Global Y position */
	Y float32

	/* Global Z position */
	Z float32

	/* Roll angle */
	Roll float32

	/* Pitch angle */
	Pitch float32

	/* Yaw angle */
	Yaw float32

	/* Row-major representation of pose 6x6 cross-covariance matrix upper right triangle (states: x_global, y_global, z_global, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [21]float32 /*EXTENSION*/

	/* Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps. */
	ResetCounter byte /*EXTENSION*/

}

func (m *GlobalVisionPositionEstimate) ID() int        { return 101 }
func (m *GlobalVisionPositionEstimate) CRCExtra() byte { return 102 }

func (m *GlobalVisionPositionEstimate) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.Usec))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))

	return buf
}

func (m *GlobalVisionPositionEstimate) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.ResetCounter))

	return buf
}

func (m *GlobalVisionPositionEstimate) UnmarshalV1(buf []byte) []byte {
	buf, m.Usec = unmarshalUint64(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)

	return buf
}

func (m *GlobalVisionPositionEstimate) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}
	buf, m.ResetCounter = unmarshalByte(buf)

	return buf
}

/* Global position/attitude estimate from a vision source. */
type VisionPositionEstimate struct {
	/* Timestamp (UNIX time or time since system boot) */
	Usec uint64

	/* Global X position */
	X float32

	/* Global Y position */
	Y float32

	/* Global Z position */
	Z float32

	/* Roll angle */
	Roll float32

	/* Pitch angle */
	Pitch float32

	/* Yaw angle */
	Yaw float32

	/* Row-major representation of pose 6x6 cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [21]float32 /*EXTENSION*/

	/* Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps. */
	ResetCounter byte /*EXTENSION*/

}

func (m *VisionPositionEstimate) ID() int        { return 102 }
func (m *VisionPositionEstimate) CRCExtra() byte { return 158 }

func (m *VisionPositionEstimate) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.Usec))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))

	return buf
}

func (m *VisionPositionEstimate) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.ResetCounter))

	return buf
}

func (m *VisionPositionEstimate) UnmarshalV1(buf []byte) []byte {
	buf, m.Usec = unmarshalUint64(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)

	return buf
}

func (m *VisionPositionEstimate) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}
	buf, m.ResetCounter = unmarshalByte(buf)

	return buf
}

/* Speed estimate from a vision source. */
type VisionSpeedEstimate struct {
	/* Timestamp (UNIX time or time since system boot) */
	Usec uint64

	/* Global X speed */
	X float32

	/* Global Y speed */
	Y float32

	/* Global Z speed */
	Z float32

	/* Row-major representation of 3x3 linear velocity covariance matrix (states: vx, vy, vz; 1st three entries - 1st row, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [9]float32 /*EXTENSION*/

	/* Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps. */
	ResetCounter byte /*EXTENSION*/

}

func (m *VisionSpeedEstimate) ID() int        { return 103 }
func (m *VisionSpeedEstimate) CRCExtra() byte { return 208 }

func (m *VisionSpeedEstimate) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.Usec))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))

	return buf
}

func (m *VisionSpeedEstimate) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.ResetCounter))

	return buf
}

func (m *VisionSpeedEstimate) UnmarshalV1(buf []byte) []byte {
	buf, m.Usec = unmarshalUint64(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)

	return buf
}

func (m *VisionSpeedEstimate) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}
	buf, m.ResetCounter = unmarshalByte(buf)

	return buf
}

/* Global position estimate from a Vicon motion system source. */
type ViconPositionEstimate struct {
	/* Timestamp (UNIX time or time since system boot) */
	Usec uint64

	/* Global X position */
	X float32

	/* Global Y position */
	Y float32

	/* Global Z position */
	Z float32

	/* Roll angle */
	Roll float32

	/* Pitch angle */
	Pitch float32

	/* Yaw angle */
	Yaw float32

	/* Row-major representation of 6x6 pose cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [21]float32 /*EXTENSION*/

}

func (m *ViconPositionEstimate) ID() int        { return 104 }
func (m *ViconPositionEstimate) CRCExtra() byte { return 56 }

func (m *ViconPositionEstimate) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.Usec))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))

	return buf
}

func (m *ViconPositionEstimate) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}

	return buf
}

func (m *ViconPositionEstimate) UnmarshalV1(buf []byte) []byte {
	buf, m.Usec = unmarshalUint64(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)

	return buf
}

func (m *ViconPositionEstimate) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}

	return buf
}

/* The IMU readings in SI units in NED body frame */
type HighresImu struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X acceleration */
	Xacc float32

	/* Y acceleration */
	Yacc float32

	/* Z acceleration */
	Zacc float32

	/* Angular speed around X axis */
	Xgyro float32

	/* Angular speed around Y axis */
	Ygyro float32

	/* Angular speed around Z axis */
	Zgyro float32

	/* X Magnetic field */
	Xmag float32

	/* Y Magnetic field */
	Ymag float32

	/* Z Magnetic field */
	Zmag float32

	/* Absolute pressure */
	AbsPressure float32

	/* Differential pressure */
	DiffPressure float32

	/* Altitude calculated from pressure */
	PressureAlt float32

	/* Temperature */
	Temperature float32

	/* Bitmap for fields that have updated since last message, bit 0 = xacc, bit 12: temperature */
	FieldsUpdated uint16
}

func (m *HighresImu) ID() int        { return 105 }
func (m *HighresImu) CRCExtra() byte { return 93 }

func (m *HighresImu) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.Xacc))
	buf = marshalFloat32(buf, (m.Yacc))
	buf = marshalFloat32(buf, (m.Zacc))
	buf = marshalFloat32(buf, (m.Xgyro))
	buf = marshalFloat32(buf, (m.Ygyro))
	buf = marshalFloat32(buf, (m.Zgyro))
	buf = marshalFloat32(buf, (m.Xmag))
	buf = marshalFloat32(buf, (m.Ymag))
	buf = marshalFloat32(buf, (m.Zmag))
	buf = marshalFloat32(buf, (m.AbsPressure))
	buf = marshalFloat32(buf, (m.DiffPressure))
	buf = marshalFloat32(buf, (m.PressureAlt))
	buf = marshalFloat32(buf, (m.Temperature))
	buf = marshalUint16(buf, (m.FieldsUpdated))

	return buf
}

func (m *HighresImu) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HighresImu) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Xacc = unmarshalFloat32(buf)
	buf, m.Yacc = unmarshalFloat32(buf)
	buf, m.Zacc = unmarshalFloat32(buf)
	buf, m.Xgyro = unmarshalFloat32(buf)
	buf, m.Ygyro = unmarshalFloat32(buf)
	buf, m.Zgyro = unmarshalFloat32(buf)
	buf, m.Xmag = unmarshalFloat32(buf)
	buf, m.Ymag = unmarshalFloat32(buf)
	buf, m.Zmag = unmarshalFloat32(buf)
	buf, m.AbsPressure = unmarshalFloat32(buf)
	buf, m.DiffPressure = unmarshalFloat32(buf)
	buf, m.PressureAlt = unmarshalFloat32(buf)
	buf, m.Temperature = unmarshalFloat32(buf)
	buf, m.FieldsUpdated = unmarshalUint16(buf)

	return buf
}

func (m *HighresImu) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor) */
type OpticalFlowRad struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the. */
	IntegrationTimeUs uint32

	/* Flow around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.) */
	IntegratedX float32

	/* Flow around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.) */
	IntegratedY float32

	/* RH rotation around X axis */
	IntegratedXgyro float32

	/* RH rotation around Y axis */
	IntegratedYgyro float32

	/* RH rotation around Z axis */
	IntegratedZgyro float32

	/* Time since the distance was sampled. */
	TimeDeltaDistanceUs uint32

	/* Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance. */
	Distance float32

	/* Temperature */
	Temperature int16

	/* Sensor ID */
	SensorId byte

	/* Optical flow quality / confidence. 0: no valid flow, 255: maximum quality */
	Quality byte
}

func (m *OpticalFlowRad) ID() int        { return 106 }
func (m *OpticalFlowRad) CRCExtra() byte { return 138 }

func (m *OpticalFlowRad) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint32(buf, (m.IntegrationTimeUs))
	buf = marshalFloat32(buf, (m.IntegratedX))
	buf = marshalFloat32(buf, (m.IntegratedY))
	buf = marshalFloat32(buf, (m.IntegratedXgyro))
	buf = marshalFloat32(buf, (m.IntegratedYgyro))
	buf = marshalFloat32(buf, (m.IntegratedZgyro))
	buf = marshalUint32(buf, (m.TimeDeltaDistanceUs))
	buf = marshalFloat32(buf, (m.Distance))
	buf = marshalInt16(buf, (m.Temperature))
	buf = marshalByte(buf, (m.SensorId))
	buf = marshalByte(buf, (m.Quality))

	return buf
}

func (m *OpticalFlowRad) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *OpticalFlowRad) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.IntegrationTimeUs = unmarshalUint32(buf)
	buf, m.IntegratedX = unmarshalFloat32(buf)
	buf, m.IntegratedY = unmarshalFloat32(buf)
	buf, m.IntegratedXgyro = unmarshalFloat32(buf)
	buf, m.IntegratedYgyro = unmarshalFloat32(buf)
	buf, m.IntegratedZgyro = unmarshalFloat32(buf)
	buf, m.TimeDeltaDistanceUs = unmarshalUint32(buf)
	buf, m.Distance = unmarshalFloat32(buf)
	buf, m.Temperature = unmarshalInt16(buf)
	buf, m.SensorId = unmarshalByte(buf)
	buf, m.Quality = unmarshalByte(buf)

	return buf
}

func (m *OpticalFlowRad) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The IMU readings in SI units in NED body frame */
type HilSensor struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X acceleration */
	Xacc float32

	/* Y acceleration */
	Yacc float32

	/* Z acceleration */
	Zacc float32

	/* Angular speed around X axis in body frame */
	Xgyro float32

	/* Angular speed around Y axis in body frame */
	Ygyro float32

	/* Angular speed around Z axis in body frame */
	Zgyro float32

	/* X Magnetic field */
	Xmag float32

	/* Y Magnetic field */
	Ymag float32

	/* Z Magnetic field */
	Zmag float32

	/* Absolute pressure */
	AbsPressure float32

	/* Differential pressure (airspeed) */
	DiffPressure float32

	/* Altitude calculated from pressure */
	PressureAlt float32

	/* Temperature */
	Temperature float32

	/* Bitmap for fields that have updated since last message, bit 0 = xacc, bit 12: temperature, bit 31: full reset of attitude/position/velocities/etc was performed in sim. */
	FieldsUpdated uint32
}

func (m *HilSensor) ID() int        { return 107 }
func (m *HilSensor) CRCExtra() byte { return 108 }

func (m *HilSensor) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.Xacc))
	buf = marshalFloat32(buf, (m.Yacc))
	buf = marshalFloat32(buf, (m.Zacc))
	buf = marshalFloat32(buf, (m.Xgyro))
	buf = marshalFloat32(buf, (m.Ygyro))
	buf = marshalFloat32(buf, (m.Zgyro))
	buf = marshalFloat32(buf, (m.Xmag))
	buf = marshalFloat32(buf, (m.Ymag))
	buf = marshalFloat32(buf, (m.Zmag))
	buf = marshalFloat32(buf, (m.AbsPressure))
	buf = marshalFloat32(buf, (m.DiffPressure))
	buf = marshalFloat32(buf, (m.PressureAlt))
	buf = marshalFloat32(buf, (m.Temperature))
	buf = marshalUint32(buf, (m.FieldsUpdated))

	return buf
}

func (m *HilSensor) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilSensor) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Xacc = unmarshalFloat32(buf)
	buf, m.Yacc = unmarshalFloat32(buf)
	buf, m.Zacc = unmarshalFloat32(buf)
	buf, m.Xgyro = unmarshalFloat32(buf)
	buf, m.Ygyro = unmarshalFloat32(buf)
	buf, m.Zgyro = unmarshalFloat32(buf)
	buf, m.Xmag = unmarshalFloat32(buf)
	buf, m.Ymag = unmarshalFloat32(buf)
	buf, m.Zmag = unmarshalFloat32(buf)
	buf, m.AbsPressure = unmarshalFloat32(buf)
	buf, m.DiffPressure = unmarshalFloat32(buf)
	buf, m.PressureAlt = unmarshalFloat32(buf)
	buf, m.Temperature = unmarshalFloat32(buf)
	buf, m.FieldsUpdated = unmarshalUint32(buf)

	return buf
}

func (m *HilSensor) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Status of simulation environment, if used */
type SimState struct {
	/* True attitude quaternion component 1, w (1 in null-rotation) */
	Q1 float32

	/* True attitude quaternion component 2, x (0 in null-rotation) */
	Q2 float32

	/* True attitude quaternion component 3, y (0 in null-rotation) */
	Q3 float32

	/* True attitude quaternion component 4, z (0 in null-rotation) */
	Q4 float32

	/* Attitude roll expressed as Euler angles, not recommended except for human-readable outputs */
	Roll float32

	/* Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs */
	Pitch float32

	/* Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs */
	Yaw float32

	/* X acceleration */
	Xacc float32

	/* Y acceleration */
	Yacc float32

	/* Z acceleration */
	Zacc float32

	/* Angular speed around X axis */
	Xgyro float32

	/* Angular speed around Y axis */
	Ygyro float32

	/* Angular speed around Z axis */
	Zgyro float32

	/* Latitude */
	Lat float32

	/* Longitude */
	Lon float32

	/* Altitude */
	Alt float32

	/* Horizontal position standard deviation */
	StdDevHorz float32

	/* Vertical position standard deviation */
	StdDevVert float32

	/* True velocity in NORTH direction in earth-fixed NED frame */
	Vn float32

	/* True velocity in EAST direction in earth-fixed NED frame */
	Ve float32

	/* True velocity in DOWN direction in earth-fixed NED frame */
	Vd float32
}

func (m *SimState) ID() int        { return 108 }
func (m *SimState) CRCExtra() byte { return 32 }

func (m *SimState) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Q1))
	buf = marshalFloat32(buf, (m.Q2))
	buf = marshalFloat32(buf, (m.Q3))
	buf = marshalFloat32(buf, (m.Q4))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))
	buf = marshalFloat32(buf, (m.Xacc))
	buf = marshalFloat32(buf, (m.Yacc))
	buf = marshalFloat32(buf, (m.Zacc))
	buf = marshalFloat32(buf, (m.Xgyro))
	buf = marshalFloat32(buf, (m.Ygyro))
	buf = marshalFloat32(buf, (m.Zgyro))
	buf = marshalFloat32(buf, (m.Lat))
	buf = marshalFloat32(buf, (m.Lon))
	buf = marshalFloat32(buf, (m.Alt))
	buf = marshalFloat32(buf, (m.StdDevHorz))
	buf = marshalFloat32(buf, (m.StdDevVert))
	buf = marshalFloat32(buf, (m.Vn))
	buf = marshalFloat32(buf, (m.Ve))
	buf = marshalFloat32(buf, (m.Vd))

	return buf
}

func (m *SimState) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SimState) UnmarshalV1(buf []byte) []byte {
	buf, m.Q1 = unmarshalFloat32(buf)
	buf, m.Q2 = unmarshalFloat32(buf)
	buf, m.Q3 = unmarshalFloat32(buf)
	buf, m.Q4 = unmarshalFloat32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)
	buf, m.Xacc = unmarshalFloat32(buf)
	buf, m.Yacc = unmarshalFloat32(buf)
	buf, m.Zacc = unmarshalFloat32(buf)
	buf, m.Xgyro = unmarshalFloat32(buf)
	buf, m.Ygyro = unmarshalFloat32(buf)
	buf, m.Zgyro = unmarshalFloat32(buf)
	buf, m.Lat = unmarshalFloat32(buf)
	buf, m.Lon = unmarshalFloat32(buf)
	buf, m.Alt = unmarshalFloat32(buf)
	buf, m.StdDevHorz = unmarshalFloat32(buf)
	buf, m.StdDevVert = unmarshalFloat32(buf)
	buf, m.Vn = unmarshalFloat32(buf)
	buf, m.Ve = unmarshalFloat32(buf)
	buf, m.Vd = unmarshalFloat32(buf)

	return buf
}

func (m *SimState) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Status generated by radio and injected into MAVLink stream. */
type RadioStatus struct {
	/* Count of radio packet receive errors (since boot). */
	Rxerrors uint16

	/* Count of error corrected radio packets (since boot). */
	Fixed uint16

	/* Local (message sender) recieved signal strength indication in device-dependent units/scale. Values: [0-254], 255: invalid/unknown. */
	Rssi byte

	/* Remote (message receiver) signal strength indication in device-dependent units/scale. Values: [0-254], 255: invalid/unknown. */
	Remrssi byte

	/* Remaining free transmitter buffer space. */
	Txbuf byte

	/* Local background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], 255: invalid/unknown. */
	Noise byte

	/* Remote background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], 255: invalid/unknown. */
	Remnoise byte
}

func (m *RadioStatus) ID() int        { return 109 }
func (m *RadioStatus) CRCExtra() byte { return 185 }

func (m *RadioStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Rxerrors))
	buf = marshalUint16(buf, (m.Fixed))
	buf = marshalByte(buf, (m.Rssi))
	buf = marshalByte(buf, (m.Remrssi))
	buf = marshalByte(buf, (m.Txbuf))
	buf = marshalByte(buf, (m.Noise))
	buf = marshalByte(buf, (m.Remnoise))

	return buf
}

func (m *RadioStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *RadioStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.Rxerrors = unmarshalUint16(buf)
	buf, m.Fixed = unmarshalUint16(buf)
	buf, m.Rssi = unmarshalByte(buf)
	buf, m.Remrssi = unmarshalByte(buf)
	buf, m.Txbuf = unmarshalByte(buf)
	buf, m.Noise = unmarshalByte(buf)
	buf, m.Remnoise = unmarshalByte(buf)

	return buf
}

func (m *RadioStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* File transfer message */
type FileTransferProtocol struct {
	/* Network ID (0 for broadcast) */
	TargetNetwork byte

	/* System ID (0 for broadcast) */
	TargetSystem byte

	/* Component ID (0 for broadcast) */
	TargetComponent byte

	/* Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. */
	Payload [251]byte
}

func (m *FileTransferProtocol) ID() int        { return 110 }
func (m *FileTransferProtocol) CRCExtra() byte { return 84 }

func (m *FileTransferProtocol) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetNetwork))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.Payload {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *FileTransferProtocol) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *FileTransferProtocol) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetNetwork = unmarshalByte(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.Payload {
		buf, m.Payload[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *FileTransferProtocol) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Time synchronization message. */
type Timesync struct {
	/* Time sync timestamp 1 */
	Tc1 int64

	/* Time sync timestamp 2 */
	Ts1 int64
}

func (m *Timesync) ID() int        { return 111 }
func (m *Timesync) CRCExtra() byte { return 34 }

func (m *Timesync) MarshalV1(buf []byte) []byte {
	buf = marshalInt64(buf, (m.Tc1))
	buf = marshalInt64(buf, (m.Ts1))

	return buf
}

func (m *Timesync) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Timesync) UnmarshalV1(buf []byte) []byte {
	buf, m.Tc1 = unmarshalInt64(buf)
	buf, m.Ts1 = unmarshalInt64(buf)

	return buf
}

func (m *Timesync) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Camera-IMU triggering and synchronisation message. */
type CameraTrigger struct {
	/* Timestamp for image frame (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Image frame sequence */
	Seq uint32
}

func (m *CameraTrigger) ID() int        { return 112 }
func (m *CameraTrigger) CRCExtra() byte { return 174 }

func (m *CameraTrigger) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint32(buf, (m.Seq))

	return buf
}

func (m *CameraTrigger) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *CameraTrigger) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Seq = unmarshalUint32(buf)

	return buf
}

func (m *CameraTrigger) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The global position, as returned by the Global Positioning System (GPS). This is                  NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. */
type HilGps struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Latitude (WGS84) */
	Lat int32

	/* Longitude (WGS84) */
	Lon int32

	/* Altitude (MSL). Positive for up. */
	Alt int32

	/* GPS HDOP horizontal dilution of position. If unknown, set to: 65535 */
	Eph uint16

	/* GPS VDOP vertical dilution of position. If unknown, set to: 65535 */
	Epv uint16

	/* GPS ground speed. If unknown, set to: 65535 */
	Vel uint16

	/* GPS velocity in NORTH direction in earth-fixed NED frame */
	Vn int16

	/* GPS velocity in EAST direction in earth-fixed NED frame */
	Ve int16

	/* GPS velocity in DOWN direction in earth-fixed NED frame */
	Vd int16

	/* Course over ground (NOT heading, but direction of movement), 0.0..359.99 degrees. If unknown, set to: 65535 */
	Cog uint16

	/* 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix. */
	FixType byte

	/* Number of satellites visible. If unknown, set to 255 */
	SatellitesVisible byte
}

func (m *HilGps) ID() int        { return 113 }
func (m *HilGps) CRCExtra() byte { return 124 }

func (m *HilGps) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalUint16(buf, (m.Eph))
	buf = marshalUint16(buf, (m.Epv))
	buf = marshalUint16(buf, (m.Vel))
	buf = marshalInt16(buf, (m.Vn))
	buf = marshalInt16(buf, (m.Ve))
	buf = marshalInt16(buf, (m.Vd))
	buf = marshalUint16(buf, (m.Cog))
	buf = marshalByte(buf, (m.FixType))
	buf = marshalByte(buf, (m.SatellitesVisible))

	return buf
}

func (m *HilGps) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilGps) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.Eph = unmarshalUint16(buf)
	buf, m.Epv = unmarshalUint16(buf)
	buf, m.Vel = unmarshalUint16(buf)
	buf, m.Vn = unmarshalInt16(buf)
	buf, m.Ve = unmarshalInt16(buf)
	buf, m.Vd = unmarshalInt16(buf)
	buf, m.Cog = unmarshalUint16(buf)
	buf, m.FixType = unmarshalByte(buf)
	buf, m.SatellitesVisible = unmarshalByte(buf)

	return buf
}

func (m *HilGps) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor) */
type HilOpticalFlow struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the. */
	IntegrationTimeUs uint32

	/* Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.) */
	IntegratedX float32

	/* Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.) */
	IntegratedY float32

	/* RH rotation around X axis */
	IntegratedXgyro float32

	/* RH rotation around Y axis */
	IntegratedYgyro float32

	/* RH rotation around Z axis */
	IntegratedZgyro float32

	/* Time since the distance was sampled. */
	TimeDeltaDistanceUs uint32

	/* Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance. */
	Distance float32

	/* Temperature */
	Temperature int16

	/* Sensor ID */
	SensorId byte

	/* Optical flow quality / confidence. 0: no valid flow, 255: maximum quality */
	Quality byte
}

func (m *HilOpticalFlow) ID() int        { return 114 }
func (m *HilOpticalFlow) CRCExtra() byte { return 237 }

func (m *HilOpticalFlow) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint32(buf, (m.IntegrationTimeUs))
	buf = marshalFloat32(buf, (m.IntegratedX))
	buf = marshalFloat32(buf, (m.IntegratedY))
	buf = marshalFloat32(buf, (m.IntegratedXgyro))
	buf = marshalFloat32(buf, (m.IntegratedYgyro))
	buf = marshalFloat32(buf, (m.IntegratedZgyro))
	buf = marshalUint32(buf, (m.TimeDeltaDistanceUs))
	buf = marshalFloat32(buf, (m.Distance))
	buf = marshalInt16(buf, (m.Temperature))
	buf = marshalByte(buf, (m.SensorId))
	buf = marshalByte(buf, (m.Quality))

	return buf
}

func (m *HilOpticalFlow) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilOpticalFlow) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.IntegrationTimeUs = unmarshalUint32(buf)
	buf, m.IntegratedX = unmarshalFloat32(buf)
	buf, m.IntegratedY = unmarshalFloat32(buf)
	buf, m.IntegratedXgyro = unmarshalFloat32(buf)
	buf, m.IntegratedYgyro = unmarshalFloat32(buf)
	buf, m.IntegratedZgyro = unmarshalFloat32(buf)
	buf, m.TimeDeltaDistanceUs = unmarshalUint32(buf)
	buf, m.Distance = unmarshalFloat32(buf)
	buf, m.Temperature = unmarshalInt16(buf)
	buf, m.SensorId = unmarshalByte(buf)
	buf, m.Quality = unmarshalByte(buf)

	return buf
}

func (m *HilOpticalFlow) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations. */
type HilStateQuaternion struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation) */
	AttitudeQuaternion [4]float32

	/* Body frame roll / phi angular speed */
	Rollspeed float32

	/* Body frame pitch / theta angular speed */
	Pitchspeed float32

	/* Body frame yaw / psi angular speed */
	Yawspeed float32

	/* Latitude */
	Lat int32

	/* Longitude */
	Lon int32

	/* Altitude */
	Alt int32

	/* Ground X Speed (Latitude) */
	Vx int16

	/* Ground Y Speed (Longitude) */
	Vy int16

	/* Ground Z Speed (Altitude) */
	Vz int16

	/* Indicated airspeed */
	IndAirspeed uint16

	/* True airspeed */
	TrueAirspeed uint16

	/* X acceleration */
	Xacc int16

	/* Y acceleration */
	Yacc int16

	/* Z acceleration */
	Zacc int16
}

func (m *HilStateQuaternion) ID() int        { return 115 }
func (m *HilStateQuaternion) CRCExtra() byte { return 4 }

func (m *HilStateQuaternion) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.AttitudeQuaternion {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.Rollspeed))
	buf = marshalFloat32(buf, (m.Pitchspeed))
	buf = marshalFloat32(buf, (m.Yawspeed))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalInt16(buf, (m.Vx))
	buf = marshalInt16(buf, (m.Vy))
	buf = marshalInt16(buf, (m.Vz))
	buf = marshalUint16(buf, (m.IndAirspeed))
	buf = marshalUint16(buf, (m.TrueAirspeed))
	buf = marshalInt16(buf, (m.Xacc))
	buf = marshalInt16(buf, (m.Yacc))
	buf = marshalInt16(buf, (m.Zacc))

	return buf
}

func (m *HilStateQuaternion) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HilStateQuaternion) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.AttitudeQuaternion {
		buf, m.AttitudeQuaternion[i] = unmarshalFloat32(buf)
	}
	buf, m.Rollspeed = unmarshalFloat32(buf)
	buf, m.Pitchspeed = unmarshalFloat32(buf)
	buf, m.Yawspeed = unmarshalFloat32(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.Vx = unmarshalInt16(buf)
	buf, m.Vy = unmarshalInt16(buf)
	buf, m.Vz = unmarshalInt16(buf)
	buf, m.IndAirspeed = unmarshalUint16(buf)
	buf, m.TrueAirspeed = unmarshalUint16(buf)
	buf, m.Xacc = unmarshalInt16(buf)
	buf, m.Yacc = unmarshalInt16(buf)
	buf, m.Zacc = unmarshalInt16(buf)

	return buf
}

func (m *HilStateQuaternion) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units */
type ScaledImu2 struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* X acceleration */
	Xacc int16

	/* Y acceleration */
	Yacc int16

	/* Z acceleration */
	Zacc int16

	/* Angular speed around X axis */
	Xgyro int16

	/* Angular speed around Y axis */
	Ygyro int16

	/* Angular speed around Z axis */
	Zgyro int16

	/* X Magnetic field */
	Xmag int16

	/* Y Magnetic field */
	Ymag int16

	/* Z Magnetic field */
	Zmag int16
}

func (m *ScaledImu2) ID() int        { return 116 }
func (m *ScaledImu2) CRCExtra() byte { return 76 }

func (m *ScaledImu2) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt16(buf, (m.Xacc))
	buf = marshalInt16(buf, (m.Yacc))
	buf = marshalInt16(buf, (m.Zacc))
	buf = marshalInt16(buf, (m.Xgyro))
	buf = marshalInt16(buf, (m.Ygyro))
	buf = marshalInt16(buf, (m.Zgyro))
	buf = marshalInt16(buf, (m.Xmag))
	buf = marshalInt16(buf, (m.Ymag))
	buf = marshalInt16(buf, (m.Zmag))

	return buf
}

func (m *ScaledImu2) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ScaledImu2) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Xacc = unmarshalInt16(buf)
	buf, m.Yacc = unmarshalInt16(buf)
	buf, m.Zacc = unmarshalInt16(buf)
	buf, m.Xgyro = unmarshalInt16(buf)
	buf, m.Ygyro = unmarshalInt16(buf)
	buf, m.Zgyro = unmarshalInt16(buf)
	buf, m.Xmag = unmarshalInt16(buf)
	buf, m.Ymag = unmarshalInt16(buf)
	buf, m.Zmag = unmarshalInt16(buf)

	return buf
}

func (m *ScaledImu2) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called. */
type LogRequestList struct {
	/* First log id (0 for first available) */
	Start uint16

	/* Last log id (0xffff for last available) */
	End uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *LogRequestList) ID() int        { return 117 }
func (m *LogRequestList) CRCExtra() byte { return 128 }

func (m *LogRequestList) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Start))
	buf = marshalUint16(buf, (m.End))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *LogRequestList) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LogRequestList) UnmarshalV1(buf []byte) []byte {
	buf, m.Start = unmarshalUint16(buf)
	buf, m.End = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *LogRequestList) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Reply to LOG_REQUEST_LIST */
type LogEntry struct {
	/* UTC timestamp of log since 1970, or 0 if not available */
	TimeUtc uint32

	/* Size of the log (may be approximate) */
	Size uint32

	/* Log id */
	Id uint16

	/* Total number of logs */
	NumLogs uint16

	/* High log number */
	LastLogNum uint16
}

func (m *LogEntry) ID() int        { return 118 }
func (m *LogEntry) CRCExtra() byte { return 56 }

func (m *LogEntry) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeUtc))
	buf = marshalUint32(buf, (m.Size))
	buf = marshalUint16(buf, (m.Id))
	buf = marshalUint16(buf, (m.NumLogs))
	buf = marshalUint16(buf, (m.LastLogNum))

	return buf
}

func (m *LogEntry) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LogEntry) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUtc = unmarshalUint32(buf)
	buf, m.Size = unmarshalUint32(buf)
	buf, m.Id = unmarshalUint16(buf)
	buf, m.NumLogs = unmarshalUint16(buf)
	buf, m.LastLogNum = unmarshalUint16(buf)

	return buf
}

func (m *LogEntry) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request a chunk of a log */
type LogRequestData struct {
	/* Offset into the log */
	Ofs uint32

	/* Number of bytes */
	Count uint32

	/* Log id (from LOG_ENTRY reply) */
	Id uint16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *LogRequestData) ID() int        { return 119 }
func (m *LogRequestData) CRCExtra() byte { return 116 }

func (m *LogRequestData) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Ofs))
	buf = marshalUint32(buf, (m.Count))
	buf = marshalUint16(buf, (m.Id))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *LogRequestData) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LogRequestData) UnmarshalV1(buf []byte) []byte {
	buf, m.Ofs = unmarshalUint32(buf)
	buf, m.Count = unmarshalUint32(buf)
	buf, m.Id = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *LogRequestData) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Reply to LOG_REQUEST_DATA */
type LogData struct {
	/* Offset into the log */
	Ofs uint32

	/* Log id (from LOG_ENTRY reply) */
	Id uint16

	/* Number of bytes (zero for end of log) */
	Count byte

	/* log data */
	Data [90]byte
}

func (m *LogData) ID() int        { return 120 }
func (m *LogData) CRCExtra() byte { return 134 }

func (m *LogData) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Ofs))
	buf = marshalUint16(buf, (m.Id))
	buf = marshalByte(buf, (m.Count))
	for _, v := range m.Data {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *LogData) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LogData) UnmarshalV1(buf []byte) []byte {
	buf, m.Ofs = unmarshalUint32(buf)
	buf, m.Id = unmarshalUint16(buf)
	buf, m.Count = unmarshalByte(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *LogData) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Erase all logs */
type LogErase struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *LogErase) ID() int        { return 121 }
func (m *LogErase) CRCExtra() byte { return 237 }

func (m *LogErase) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *LogErase) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LogErase) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *LogErase) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Stop log transfer and resume normal logging */
type LogRequestEnd struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *LogRequestEnd) ID() int        { return 122 }
func (m *LogRequestEnd) CRCExtra() byte { return 203 }

func (m *LogRequestEnd) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *LogRequestEnd) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LogRequestEnd) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *LogRequestEnd) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Data for injecting into the onboard GPS (used for DGPS) */
type GpsInjectData struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Data length */
	Len byte

	/* Raw data (110 is enough for 12 satellites of RTCMv2) */
	Data [110]byte
}

func (m *GpsInjectData) ID() int        { return 123 }
func (m *GpsInjectData) CRCExtra() byte { return 250 }

func (m *GpsInjectData) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, (m.Len))
	for _, v := range m.Data {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *GpsInjectData) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *GpsInjectData) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	buf, m.Len = unmarshalByte(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *GpsInjectData) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Second GPS data. */
type Gps2Raw struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Latitude (WGS84) */
	Lat int32

	/* Longitude (WGS84) */
	Lon int32

	/* Altitude (MSL). Positive for up. */
	Alt int32

	/* Age of DGPS info */
	DgpsAge uint32

	/* GPS HDOP horizontal dilution of position. If unknown, set to: UINT16_MAX */
	Eph uint16

	/* GPS VDOP vertical dilution of position. If unknown, set to: UINT16_MAX */
	Epv uint16

	/* GPS ground speed. If unknown, set to: UINT16_MAX */
	Vel uint16

	/* Course over ground (NOT heading, but direction of movement): 0.0..359.99 degrees. If unknown, set to: UINT16_MAX */
	Cog uint16

	/* GPS fix type. */
	FixType GpsFixType // byte

	/* Number of satellites visible. If unknown, set to 255 */
	SatellitesVisible byte

	/* Number of DGPS satellites */
	DgpsNumch byte
}

func (m *Gps2Raw) ID() int        { return 124 }
func (m *Gps2Raw) CRCExtra() byte { return 87 }

func (m *Gps2Raw) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalUint32(buf, (m.DgpsAge))
	buf = marshalUint16(buf, (m.Eph))
	buf = marshalUint16(buf, (m.Epv))
	buf = marshalUint16(buf, (m.Vel))
	buf = marshalUint16(buf, (m.Cog))
	buf = marshalByte(buf, byte(m.FixType))
	buf = marshalByte(buf, (m.SatellitesVisible))
	buf = marshalByte(buf, (m.DgpsNumch))

	return buf
}

func (m *Gps2Raw) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Gps2Raw) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.DgpsAge = unmarshalUint32(buf)
	buf, m.Eph = unmarshalUint16(buf)
	buf, m.Epv = unmarshalUint16(buf)
	buf, m.Vel = unmarshalUint16(buf)
	buf, m.Cog = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.FixType = GpsFixType(v)
	}
	buf, m.SatellitesVisible = unmarshalByte(buf)
	buf, m.DgpsNumch = unmarshalByte(buf)

	return buf
}

func (m *Gps2Raw) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Power supply status */
type PowerStatus struct {
	/* 5V rail voltage. */
	Vcc uint16

	/* Servo rail voltage. */
	Vservo uint16

	/* Bitmap of power supply status flags. */
	Flags MavPowerStatus // uint16

}

func (m *PowerStatus) ID() int        { return 125 }
func (m *PowerStatus) CRCExtra() byte { return 203 }

func (m *PowerStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Vcc))
	buf = marshalUint16(buf, (m.Vservo))
	buf = marshalUint16(buf, uint16(m.Flags))

	return buf
}

func (m *PowerStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *PowerStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.Vcc = unmarshalUint16(buf)
	buf, m.Vservo = unmarshalUint16(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Flags = MavPowerStatus(v)
	}

	return buf
}

func (m *PowerStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate. */
type SerialControl struct {
	/* Baudrate of transfer. Zero means no change. */
	Baudrate uint32

	/* Timeout for reply data */
	Timeout uint16

	/* Serial control device type. */
	Device SerialControlDev // byte

	/* Bitmap of serial control flags. */
	Flags SerialControlFlag // byte

	/* how many bytes in this transfer */
	Count byte

	/* serial data */
	Data [70]byte
}

func (m *SerialControl) ID() int        { return 126 }
func (m *SerialControl) CRCExtra() byte { return 220 }

func (m *SerialControl) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Baudrate))
	buf = marshalUint16(buf, (m.Timeout))
	buf = marshalByte(buf, byte(m.Device))
	buf = marshalByte(buf, byte(m.Flags))
	buf = marshalByte(buf, (m.Count))
	for _, v := range m.Data {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *SerialControl) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SerialControl) UnmarshalV1(buf []byte) []byte {
	buf, m.Baudrate = unmarshalUint32(buf)
	buf, m.Timeout = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Device = SerialControlDev(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Flags = SerialControlFlag(v)
	}
	buf, m.Count = unmarshalByte(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *SerialControl) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
type GpsRtk struct {
	/* Time since boot of last baseline message received. */
	TimeLastBaselineMs uint32

	/* GPS Time of Week of last baseline */
	Tow uint32

	/* Current baseline in ECEF x or NED north component. */
	BaselineAMm int32

	/* Current baseline in ECEF y or NED east component. */
	BaselineBMm int32

	/* Current baseline in ECEF z or NED down component. */
	BaselineCMm int32

	/* Current estimate of baseline accuracy. */
	Accuracy uint32

	/* Current number of integer ambiguity hypotheses. */
	IarNumHypotheses int32

	/* GPS Week Number of last baseline */
	Wn uint16

	/* Identification of connected RTK receiver. */
	RtkReceiverId byte

	/* GPS-specific health report for RTK data. */
	RtkHealth byte

	/* Rate of baseline messages being received by GPS */
	RtkRate byte

	/* Current number of sats used for RTK calculation. */
	Nsats byte

	/* Coordinate system of baseline */
	BaselineCoordsType RtkBaselineCoordinateSystem // byte

}

func (m *GpsRtk) ID() int        { return 127 }
func (m *GpsRtk) CRCExtra() byte { return 25 }

func (m *GpsRtk) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeLastBaselineMs))
	buf = marshalUint32(buf, (m.Tow))
	buf = marshalInt32(buf, (m.BaselineAMm))
	buf = marshalInt32(buf, (m.BaselineBMm))
	buf = marshalInt32(buf, (m.BaselineCMm))
	buf = marshalUint32(buf, (m.Accuracy))
	buf = marshalInt32(buf, (m.IarNumHypotheses))
	buf = marshalUint16(buf, (m.Wn))
	buf = marshalByte(buf, (m.RtkReceiverId))
	buf = marshalByte(buf, (m.RtkHealth))
	buf = marshalByte(buf, (m.RtkRate))
	buf = marshalByte(buf, (m.Nsats))
	buf = marshalByte(buf, byte(m.BaselineCoordsType))

	return buf
}

func (m *GpsRtk) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *GpsRtk) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeLastBaselineMs = unmarshalUint32(buf)
	buf, m.Tow = unmarshalUint32(buf)
	buf, m.BaselineAMm = unmarshalInt32(buf)
	buf, m.BaselineBMm = unmarshalInt32(buf)
	buf, m.BaselineCMm = unmarshalInt32(buf)
	buf, m.Accuracy = unmarshalUint32(buf)
	buf, m.IarNumHypotheses = unmarshalInt32(buf)
	buf, m.Wn = unmarshalUint16(buf)
	buf, m.RtkReceiverId = unmarshalByte(buf)
	buf, m.RtkHealth = unmarshalByte(buf)
	buf, m.RtkRate = unmarshalByte(buf)
	buf, m.Nsats = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.BaselineCoordsType = RtkBaselineCoordinateSystem(v)
	}

	return buf
}

func (m *GpsRtk) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
type Gps2Rtk struct {
	/* Time since boot of last baseline message received. */
	TimeLastBaselineMs uint32

	/* GPS Time of Week of last baseline */
	Tow uint32

	/* Current baseline in ECEF x or NED north component. */
	BaselineAMm int32

	/* Current baseline in ECEF y or NED east component. */
	BaselineBMm int32

	/* Current baseline in ECEF z or NED down component. */
	BaselineCMm int32

	/* Current estimate of baseline accuracy. */
	Accuracy uint32

	/* Current number of integer ambiguity hypotheses. */
	IarNumHypotheses int32

	/* GPS Week Number of last baseline */
	Wn uint16

	/* Identification of connected RTK receiver. */
	RtkReceiverId byte

	/* GPS-specific health report for RTK data. */
	RtkHealth byte

	/* Rate of baseline messages being received by GPS */
	RtkRate byte

	/* Current number of sats used for RTK calculation. */
	Nsats byte

	/* Coordinate system of baseline */
	BaselineCoordsType RtkBaselineCoordinateSystem // byte

}

func (m *Gps2Rtk) ID() int        { return 128 }
func (m *Gps2Rtk) CRCExtra() byte { return 226 }

func (m *Gps2Rtk) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeLastBaselineMs))
	buf = marshalUint32(buf, (m.Tow))
	buf = marshalInt32(buf, (m.BaselineAMm))
	buf = marshalInt32(buf, (m.BaselineBMm))
	buf = marshalInt32(buf, (m.BaselineCMm))
	buf = marshalUint32(buf, (m.Accuracy))
	buf = marshalInt32(buf, (m.IarNumHypotheses))
	buf = marshalUint16(buf, (m.Wn))
	buf = marshalByte(buf, (m.RtkReceiverId))
	buf = marshalByte(buf, (m.RtkHealth))
	buf = marshalByte(buf, (m.RtkRate))
	buf = marshalByte(buf, (m.Nsats))
	buf = marshalByte(buf, byte(m.BaselineCoordsType))

	return buf
}

func (m *Gps2Rtk) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Gps2Rtk) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeLastBaselineMs = unmarshalUint32(buf)
	buf, m.Tow = unmarshalUint32(buf)
	buf, m.BaselineAMm = unmarshalInt32(buf)
	buf, m.BaselineBMm = unmarshalInt32(buf)
	buf, m.BaselineCMm = unmarshalInt32(buf)
	buf, m.Accuracy = unmarshalUint32(buf)
	buf, m.IarNumHypotheses = unmarshalInt32(buf)
	buf, m.Wn = unmarshalUint16(buf)
	buf, m.RtkReceiverId = unmarshalByte(buf)
	buf, m.RtkHealth = unmarshalByte(buf)
	buf, m.RtkRate = unmarshalByte(buf)
	buf, m.Nsats = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.BaselineCoordsType = RtkBaselineCoordinateSystem(v)
	}

	return buf
}

func (m *Gps2Rtk) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units */
type ScaledImu3 struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* X acceleration */
	Xacc int16

	/* Y acceleration */
	Yacc int16

	/* Z acceleration */
	Zacc int16

	/* Angular speed around X axis */
	Xgyro int16

	/* Angular speed around Y axis */
	Ygyro int16

	/* Angular speed around Z axis */
	Zgyro int16

	/* X Magnetic field */
	Xmag int16

	/* Y Magnetic field */
	Ymag int16

	/* Z Magnetic field */
	Zmag int16
}

func (m *ScaledImu3) ID() int        { return 129 }
func (m *ScaledImu3) CRCExtra() byte { return 46 }

func (m *ScaledImu3) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt16(buf, (m.Xacc))
	buf = marshalInt16(buf, (m.Yacc))
	buf = marshalInt16(buf, (m.Zacc))
	buf = marshalInt16(buf, (m.Xgyro))
	buf = marshalInt16(buf, (m.Ygyro))
	buf = marshalInt16(buf, (m.Zgyro))
	buf = marshalInt16(buf, (m.Xmag))
	buf = marshalInt16(buf, (m.Ymag))
	buf = marshalInt16(buf, (m.Zmag))

	return buf
}

func (m *ScaledImu3) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ScaledImu3) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Xacc = unmarshalInt16(buf)
	buf, m.Yacc = unmarshalInt16(buf)
	buf, m.Zacc = unmarshalInt16(buf)
	buf, m.Xgyro = unmarshalInt16(buf)
	buf, m.Ygyro = unmarshalInt16(buf)
	buf, m.Zgyro = unmarshalInt16(buf)
	buf, m.Xmag = unmarshalInt16(buf)
	buf, m.Ymag = unmarshalInt16(buf)
	buf, m.Zmag = unmarshalInt16(buf)

	return buf
}

func (m *ScaledImu3) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Handshake message to initiate, control and stop image streaming when using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html. */
type DataTransmissionHandshake struct {
	/* total data size (set on ACK only). */
	Size uint32

	/* Width of a matrix or image. */
	Width uint16

	/* Height of a matrix or image. */
	Height uint16

	/* Number of packets being sent (set on ACK only). */
	Packets uint16

	/* Type of requested/acknowledged data. */
	Type MavlinkDataStreamType // byte

	/* Payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only). */
	Payload byte

	/* JPEG quality. Values: [1-100]. */
	JpgQuality byte
}

func (m *DataTransmissionHandshake) ID() int        { return 130 }
func (m *DataTransmissionHandshake) CRCExtra() byte { return 29 }

func (m *DataTransmissionHandshake) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Size))
	buf = marshalUint16(buf, (m.Width))
	buf = marshalUint16(buf, (m.Height))
	buf = marshalUint16(buf, (m.Packets))
	buf = marshalByte(buf, byte(m.Type))
	buf = marshalByte(buf, (m.Payload))
	buf = marshalByte(buf, (m.JpgQuality))

	return buf
}

func (m *DataTransmissionHandshake) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *DataTransmissionHandshake) UnmarshalV1(buf []byte) []byte {
	buf, m.Size = unmarshalUint32(buf)
	buf, m.Width = unmarshalUint16(buf)
	buf, m.Height = unmarshalUint16(buf)
	buf, m.Packets = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = MavlinkDataStreamType(v)
	}
	buf, m.Payload = unmarshalByte(buf)
	buf, m.JpgQuality = unmarshalByte(buf)

	return buf
}

func (m *DataTransmissionHandshake) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Data packet for images sent using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html. */
type EncapsulatedData struct {
	/* sequence number (starting with 0 on every transmission) */
	Seqnr uint16

	/* image data bytes */
	Data [253]byte
}

func (m *EncapsulatedData) ID() int        { return 131 }
func (m *EncapsulatedData) CRCExtra() byte { return 223 }

func (m *EncapsulatedData) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Seqnr))
	for _, v := range m.Data {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *EncapsulatedData) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *EncapsulatedData) UnmarshalV1(buf []byte) []byte {
	buf, m.Seqnr = unmarshalUint16(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *EncapsulatedData) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Distance sensor information for an onboard rangefinder. */
type DistanceSensor struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Minimum distance the sensor can measure */
	MinDistance uint16

	/* Maximum distance the sensor can measure */
	MaxDistance uint16

	/* Current distance reading */
	CurrentDistance uint16

	/* Type of distance sensor. */
	Type MavDistanceSensor // byte

	/* Onboard ID of the sensor */
	Id byte

	/* Direction the sensor faces. downward-facing: ROTATION_PITCH_270, upward-facing: ROTATION_PITCH_90, backward-facing: ROTATION_PITCH_180, forward-facing: ROTATION_NONE, left-facing: ROTATION_YAW_90, right-facing: ROTATION_YAW_270 */
	Orientation MavSensorOrientation // byte

	/* Measurement variance. Max standard deviation is 6cm. 255 if unknown. */
	Covariance byte

	/* Horizontal Field of View (angle) where the distance measurement is valid and the field of view is known. Otherwise this is set to 0. */
	HorizontalFov float32 /*EXTENSION*/

	/* Vertical Field of View (angle) where the distance measurement is valid and the field of view is known. Otherwise this is set to 0. */
	VerticalFov float32 /*EXTENSION*/

	/* Quaternion of the sensor orientation in vehicle body frame (w, x, y, z order, zero-rotation is 1, 0, 0, 0). Zero-rotation is along the vehicle body x-axis. This field is required if the orientation is set to MAV_SENSOR_ROTATION_CUSTOM. Set it to 0 if invalid." */
	Quaternion [4]float32 /*EXTENSION*/

}

func (m *DistanceSensor) ID() int        { return 132 }
func (m *DistanceSensor) CRCExtra() byte { return 85 }

func (m *DistanceSensor) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalUint16(buf, (m.MinDistance))
	buf = marshalUint16(buf, (m.MaxDistance))
	buf = marshalUint16(buf, (m.CurrentDistance))
	buf = marshalByte(buf, byte(m.Type))
	buf = marshalByte(buf, (m.Id))
	buf = marshalByte(buf, byte(m.Orientation))
	buf = marshalByte(buf, (m.Covariance))

	return buf
}

func (m *DistanceSensor) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalFloat32(buf, (m.HorizontalFov))
	buf = marshalFloat32(buf, (m.VerticalFov))
	for _, v := range m.Quaternion {
		buf = marshalFloat32(buf, (v))
	}

	return buf
}

func (m *DistanceSensor) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.MinDistance = unmarshalUint16(buf)
	buf, m.MaxDistance = unmarshalUint16(buf)
	buf, m.CurrentDistance = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = MavDistanceSensor(v)
	}
	buf, m.Id = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Orientation = MavSensorOrientation(v)
	}
	buf, m.Covariance = unmarshalByte(buf)

	return buf
}

func (m *DistanceSensor) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.HorizontalFov = unmarshalFloat32(buf)
	buf, m.VerticalFov = unmarshalFloat32(buf)
	for i, _ := range m.Quaternion {
		buf, m.Quaternion[i] = unmarshalFloat32(buf)
	}

	return buf
}

/* Request for terrain data and terrain status */
type TerrainRequest struct {
	/* Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits) */
	Mask uint64

	/* Latitude of SW corner of first grid */
	Lat int32

	/* Longitude of SW corner of first grid */
	Lon int32

	/* Grid spacing */
	GridSpacing uint16
}

func (m *TerrainRequest) ID() int        { return 133 }
func (m *TerrainRequest) CRCExtra() byte { return 6 }

func (m *TerrainRequest) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.Mask))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalUint16(buf, (m.GridSpacing))

	return buf
}

func (m *TerrainRequest) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *TerrainRequest) UnmarshalV1(buf []byte) []byte {
	buf, m.Mask = unmarshalUint64(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.GridSpacing = unmarshalUint16(buf)

	return buf
}

func (m *TerrainRequest) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST */
type TerrainData struct {
	/* Latitude of SW corner of first grid */
	Lat int32

	/* Longitude of SW corner of first grid */
	Lon int32

	/* Grid spacing */
	GridSpacing uint16

	/* Terrain data MSL */
	Data [16]int16

	/* bit within the terrain request mask */
	Gridbit byte
}

func (m *TerrainData) ID() int        { return 134 }
func (m *TerrainData) CRCExtra() byte { return 229 }

func (m *TerrainData) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalUint16(buf, (m.GridSpacing))
	for _, v := range m.Data {
		buf = marshalInt16(buf, (v))
	}
	buf = marshalByte(buf, (m.Gridbit))

	return buf
}

func (m *TerrainData) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *TerrainData) UnmarshalV1(buf []byte) []byte {
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.GridSpacing = unmarshalUint16(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalInt16(buf)
	}
	buf, m.Gridbit = unmarshalByte(buf)

	return buf
}

func (m *TerrainData) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle has all terrain data needed for a mission. */
type TerrainCheck struct {
	/* Latitude */
	Lat int32

	/* Longitude */
	Lon int32
}

func (m *TerrainCheck) ID() int        { return 135 }
func (m *TerrainCheck) CRCExtra() byte { return 203 }

func (m *TerrainCheck) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))

	return buf
}

func (m *TerrainCheck) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *TerrainCheck) UnmarshalV1(buf []byte) []byte {
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)

	return buf
}

func (m *TerrainCheck) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Response from a TERRAIN_CHECK request */
type TerrainReport struct {
	/* Latitude */
	Lat int32

	/* Longitude */
	Lon int32

	/* Terrain height MSL */
	TerrainHeight float32

	/* Current vehicle height above lat/lon terrain height */
	CurrentHeight float32

	/* grid spacing (zero if terrain at this location unavailable) */
	Spacing uint16

	/* Number of 4x4 terrain blocks waiting to be received or read from disk */
	Pending uint16

	/* Number of 4x4 terrain blocks in memory */
	Loaded uint16
}

func (m *TerrainReport) ID() int        { return 136 }
func (m *TerrainReport) CRCExtra() byte { return 1 }

func (m *TerrainReport) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalFloat32(buf, (m.TerrainHeight))
	buf = marshalFloat32(buf, (m.CurrentHeight))
	buf = marshalUint16(buf, (m.Spacing))
	buf = marshalUint16(buf, (m.Pending))
	buf = marshalUint16(buf, (m.Loaded))

	return buf
}

func (m *TerrainReport) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *TerrainReport) UnmarshalV1(buf []byte) []byte {
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.TerrainHeight = unmarshalFloat32(buf)
	buf, m.CurrentHeight = unmarshalFloat32(buf)
	buf, m.Spacing = unmarshalUint16(buf)
	buf, m.Pending = unmarshalUint16(buf)
	buf, m.Loaded = unmarshalUint16(buf)

	return buf
}

func (m *TerrainReport) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Barometer readings for 2nd barometer */
type ScaledPressure2 struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Absolute pressure */
	PressAbs float32

	/* Differential pressure */
	PressDiff float32

	/* Temperature measurement */
	Temperature int16
}

func (m *ScaledPressure2) ID() int        { return 137 }
func (m *ScaledPressure2) CRCExtra() byte { return 195 }

func (m *ScaledPressure2) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.PressAbs))
	buf = marshalFloat32(buf, (m.PressDiff))
	buf = marshalInt16(buf, (m.Temperature))

	return buf
}

func (m *ScaledPressure2) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ScaledPressure2) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.PressAbs = unmarshalFloat32(buf)
	buf, m.PressDiff = unmarshalFloat32(buf)
	buf, m.Temperature = unmarshalInt16(buf)

	return buf
}

func (m *ScaledPressure2) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Motion capture attitude and position */
type AttPosMocap struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) */
	Q [4]float32

	/* X position (NED) */
	X float32

	/* Y position (NED) */
	Y float32

	/* Z position (NED) */
	Z float32

	/* Row-major representation of a pose 6x6 cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array. */
	Covariance [21]float32 /*EXTENSION*/

}

func (m *AttPosMocap) ID() int        { return 138 }
func (m *AttPosMocap) CRCExtra() byte { return 109 }

func (m *AttPosMocap) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))

	return buf
}

func (m *AttPosMocap) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Covariance {
		buf = marshalFloat32(buf, (v))
	}

	return buf
}

func (m *AttPosMocap) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)

	return buf
}

func (m *AttPosMocap) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Covariance {
		buf, m.Covariance[i] = unmarshalFloat32(buf)
	}

	return buf
}

/* Set the vehicle attitude and body angular rates. */
type SetActuatorControlTarget struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs. */
	Controls [8]float32

	/* Actuator group. The "_mlx" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances. */
	GroupMlx byte

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *SetActuatorControlTarget) ID() int        { return 139 }
func (m *SetActuatorControlTarget) CRCExtra() byte { return 168 }

func (m *SetActuatorControlTarget) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.Controls {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.GroupMlx))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *SetActuatorControlTarget) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SetActuatorControlTarget) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.Controls {
		buf, m.Controls[i] = unmarshalFloat32(buf)
	}
	buf, m.GroupMlx = unmarshalByte(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *SetActuatorControlTarget) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Set the vehicle attitude and body angular rates. */
type ActuatorControlTarget struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs. */
	Controls [8]float32

	/* Actuator group. The "_mlx" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances. */
	GroupMlx byte
}

func (m *ActuatorControlTarget) ID() int        { return 140 }
func (m *ActuatorControlTarget) CRCExtra() byte { return 181 }

func (m *ActuatorControlTarget) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.Controls {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.GroupMlx))

	return buf
}

func (m *ActuatorControlTarget) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ActuatorControlTarget) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.Controls {
		buf, m.Controls[i] = unmarshalFloat32(buf)
	}
	buf, m.GroupMlx = unmarshalByte(buf)

	return buf
}

func (m *ActuatorControlTarget) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The current system altitude. */
type Altitude struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights. */
	AltitudeMonotonic float32

	/* This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output MSL by default and not the WGS84 altitude. */
	AltitudeAmsl float32

	/* This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive. */
	AltitudeLocal float32

	/* This is the altitude above the home position. It resets on each change of the current home position. */
	AltitudeRelative float32

	/* This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown. */
	AltitudeTerrain float32

	/* This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available. */
	BottomClearance float32
}

func (m *Altitude) ID() int        { return 141 }
func (m *Altitude) CRCExtra() byte { return 47 }

func (m *Altitude) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.AltitudeMonotonic))
	buf = marshalFloat32(buf, (m.AltitudeAmsl))
	buf = marshalFloat32(buf, (m.AltitudeLocal))
	buf = marshalFloat32(buf, (m.AltitudeRelative))
	buf = marshalFloat32(buf, (m.AltitudeTerrain))
	buf = marshalFloat32(buf, (m.BottomClearance))

	return buf
}

func (m *Altitude) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Altitude) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.AltitudeMonotonic = unmarshalFloat32(buf)
	buf, m.AltitudeAmsl = unmarshalFloat32(buf)
	buf, m.AltitudeLocal = unmarshalFloat32(buf)
	buf, m.AltitudeRelative = unmarshalFloat32(buf)
	buf, m.AltitudeTerrain = unmarshalFloat32(buf)
	buf, m.BottomClearance = unmarshalFloat32(buf)

	return buf
}

func (m *Altitude) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The autopilot is requesting a resource (file, binary, other type of data) */
type ResourceRequest struct {
	/* Request ID. This ID should be re-used when sending back URI contents */
	RequestId byte

	/* The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary */
	UriType byte

	/* The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum) */
	Uri [120]byte

	/* The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream. */
	TransferType byte

	/* The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP). */
	Storage [120]byte
}

func (m *ResourceRequest) ID() int        { return 142 }
func (m *ResourceRequest) CRCExtra() byte { return 72 }

func (m *ResourceRequest) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.RequestId))
	buf = marshalByte(buf, (m.UriType))
	for _, v := range m.Uri {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, (m.TransferType))
	for _, v := range m.Storage {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *ResourceRequest) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ResourceRequest) UnmarshalV1(buf []byte) []byte {
	buf, m.RequestId = unmarshalByte(buf)
	buf, m.UriType = unmarshalByte(buf)
	for i, _ := range m.Uri {
		buf, m.Uri[i] = unmarshalByte(buf)
	}
	buf, m.TransferType = unmarshalByte(buf)
	for i, _ := range m.Storage {
		buf, m.Storage[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *ResourceRequest) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Barometer readings for 3rd barometer */
type ScaledPressure3 struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Absolute pressure */
	PressAbs float32

	/* Differential pressure */
	PressDiff float32

	/* Temperature measurement */
	Temperature int16
}

func (m *ScaledPressure3) ID() int        { return 143 }
func (m *ScaledPressure3) CRCExtra() byte { return 131 }

func (m *ScaledPressure3) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.PressAbs))
	buf = marshalFloat32(buf, (m.PressDiff))
	buf = marshalInt16(buf, (m.Temperature))

	return buf
}

func (m *ScaledPressure3) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ScaledPressure3) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.PressAbs = unmarshalFloat32(buf)
	buf, m.PressDiff = unmarshalFloat32(buf)
	buf, m.Temperature = unmarshalInt16(buf)

	return buf
}

func (m *ScaledPressure3) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Current motion information from a designated system */
type FollowTarget struct {
	/* Timestamp (time since system boot). */
	Timestamp uint64

	/* button states or switches of a tracker device */
	CustomState uint64

	/* Latitude (WGS84) */
	Lat int32

	/* Longitude (WGS84) */
	Lon int32

	/* Altitude (MSL) */
	Alt float32

	/* target velocity (0,0,0) for unknown */
	Vel [3]float32

	/* linear target acceleration (0,0,0) for unknown */
	Acc [3]float32

	/* (1 0 0 0 for unknown) */
	AttitudeQ [4]float32

	/* (0 0 0 for unknown) */
	Rates [3]float32

	/* eph epv */
	PositionCov [3]float32

	/* bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3) */
	EstCapabilities byte
}

func (m *FollowTarget) ID() int        { return 144 }
func (m *FollowTarget) CRCExtra() byte { return 127 }

func (m *FollowTarget) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.Timestamp))
	buf = marshalUint64(buf, (m.CustomState))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalFloat32(buf, (m.Alt))
	for _, v := range m.Vel {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.Acc {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.AttitudeQ {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.Rates {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PositionCov {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.EstCapabilities))

	return buf
}

func (m *FollowTarget) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *FollowTarget) UnmarshalV1(buf []byte) []byte {
	buf, m.Timestamp = unmarshalUint64(buf)
	buf, m.CustomState = unmarshalUint64(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalFloat32(buf)
	for i, _ := range m.Vel {
		buf, m.Vel[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.Acc {
		buf, m.Acc[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.AttitudeQ {
		buf, m.AttitudeQ[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.Rates {
		buf, m.Rates[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PositionCov {
		buf, m.PositionCov[i] = unmarshalFloat32(buf)
	}
	buf, m.EstCapabilities = unmarshalByte(buf)

	return buf
}

func (m *FollowTarget) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The smoothed, monotonic system state used to feed the control loops of the system. */
type ControlSystemState struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X acceleration in body frame */
	XAcc float32

	/* Y acceleration in body frame */
	YAcc float32

	/* Z acceleration in body frame */
	ZAcc float32

	/* X velocity in body frame */
	XVel float32

	/* Y velocity in body frame */
	YVel float32

	/* Z velocity in body frame */
	ZVel float32

	/* X position in local frame */
	XPos float32

	/* Y position in local frame */
	YPos float32

	/* Z position in local frame */
	ZPos float32

	/* Airspeed, set to -1 if unknown */
	Airspeed float32

	/* Variance of body velocity estimate */
	VelVariance [3]float32

	/* Variance in local position */
	PosVariance [3]float32

	/* The attitude, represented as Quaternion */
	Q [4]float32

	/* Angular rate in roll axis */
	RollRate float32

	/* Angular rate in pitch axis */
	PitchRate float32

	/* Angular rate in yaw axis */
	YawRate float32
}

func (m *ControlSystemState) ID() int        { return 146 }
func (m *ControlSystemState) CRCExtra() byte { return 103 }

func (m *ControlSystemState) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.XAcc))
	buf = marshalFloat32(buf, (m.YAcc))
	buf = marshalFloat32(buf, (m.ZAcc))
	buf = marshalFloat32(buf, (m.XVel))
	buf = marshalFloat32(buf, (m.YVel))
	buf = marshalFloat32(buf, (m.ZVel))
	buf = marshalFloat32(buf, (m.XPos))
	buf = marshalFloat32(buf, (m.YPos))
	buf = marshalFloat32(buf, (m.ZPos))
	buf = marshalFloat32(buf, (m.Airspeed))
	for _, v := range m.VelVariance {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PosVariance {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.RollRate))
	buf = marshalFloat32(buf, (m.PitchRate))
	buf = marshalFloat32(buf, (m.YawRate))

	return buf
}

func (m *ControlSystemState) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ControlSystemState) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.XAcc = unmarshalFloat32(buf)
	buf, m.YAcc = unmarshalFloat32(buf)
	buf, m.ZAcc = unmarshalFloat32(buf)
	buf, m.XVel = unmarshalFloat32(buf)
	buf, m.YVel = unmarshalFloat32(buf)
	buf, m.ZVel = unmarshalFloat32(buf)
	buf, m.XPos = unmarshalFloat32(buf)
	buf, m.YPos = unmarshalFloat32(buf)
	buf, m.ZPos = unmarshalFloat32(buf)
	buf, m.Airspeed = unmarshalFloat32(buf)
	for i, _ := range m.VelVariance {
		buf, m.VelVariance[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PosVariance {
		buf, m.PosVariance[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.RollRate = unmarshalFloat32(buf)
	buf, m.PitchRate = unmarshalFloat32(buf)
	buf, m.YawRate = unmarshalFloat32(buf)

	return buf
}

func (m *ControlSystemState) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Battery information. Updates GCS with flight controller battery status. Use SMART_BATTERY_* messages instead for smart batteries. */
type BatteryStatus struct {
	/* Consumed charge, -1: autopilot does not provide consumption estimate */
	CurrentConsumed int32

	/* Consumed energy, -1: autopilot does not provide energy consumption estimate */
	EnergyConsumed int32

	/* Temperature of the battery. INT16_MAX for unknown temperature. */
	Temperature int16

	/* Battery voltage of cells. Cells above the valid cell count for this battery should have the UINT16_MAX value. */
	Voltages [10]uint16

	/* Battery current, -1: autopilot does not measure the current */
	CurrentBattery int16

	/* Battery ID */
	Id byte

	/* Function of the battery */
	BatteryFunction MavBatteryFunction // byte

	/* Type (chemistry) of the battery */
	Type MavBatteryType // byte

	/* Remaining battery energy. Values: [0-100], -1: autopilot does not estimate the remaining battery. */
	BatteryRemaining int8

	/* Remaining battery time, 0: autopilot does not provide remaining battery time estimate */
	TimeRemaining int32 /*EXTENSION*/

	/* State for extent of discharge, provided by autopilot for warning or external reactions */
	ChargeState MavBatteryChargeState // byte /*EXTENSION*/

}

func (m *BatteryStatus) ID() int        { return 147 }
func (m *BatteryStatus) CRCExtra() byte { return 154 }

func (m *BatteryStatus) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.CurrentConsumed))
	buf = marshalInt32(buf, (m.EnergyConsumed))
	buf = marshalInt16(buf, (m.Temperature))
	for _, v := range m.Voltages {
		buf = marshalUint16(buf, (v))
	}
	buf = marshalInt16(buf, (m.CurrentBattery))
	buf = marshalByte(buf, (m.Id))
	buf = marshalByte(buf, byte(m.BatteryFunction))
	buf = marshalByte(buf, byte(m.Type))
	buf = marshalInt8(buf, (m.BatteryRemaining))

	return buf
}

func (m *BatteryStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalInt32(buf, (m.TimeRemaining))
	buf = marshalByte(buf, byte(m.ChargeState))

	return buf
}

func (m *BatteryStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.CurrentConsumed = unmarshalInt32(buf)
	buf, m.EnergyConsumed = unmarshalInt32(buf)
	buf, m.Temperature = unmarshalInt16(buf)
	for i, _ := range m.Voltages {
		buf, m.Voltages[i] = unmarshalUint16(buf)
	}
	buf, m.CurrentBattery = unmarshalInt16(buf)
	buf, m.Id = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.BatteryFunction = MavBatteryFunction(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = MavBatteryType(v)
	}
	buf, m.BatteryRemaining = unmarshalInt8(buf)

	return buf
}

func (m *BatteryStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.TimeRemaining = unmarshalInt32(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ChargeState = MavBatteryChargeState(v)
	}

	return buf
}

/* Version and capability of autopilot software */
type AutopilotVersion struct {
	/* Bitmap of capabilities */
	Capabilities MavProtocolCapability // uint64

	/* UID if provided by hardware (see uid2) */
	Uid uint64

	/* Firmware version number */
	FlightSwVersion uint32

	/* Middleware version number */
	MiddlewareSwVersion uint32

	/* Operating system version number */
	OsSwVersion uint32

	/* HW / board version (last 8 bytes should be silicon ID, if any) */
	BoardVersion uint32

	/* ID of the board vendor */
	VendorId uint16

	/* ID of the product */
	ProductId uint16

	/* Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. */
	FlightCustomVersion [8]byte

	/* Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. */
	MiddlewareCustomVersion [8]byte

	/* Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases. */
	OsCustomVersion [8]byte

	/* UID if provided by hardware (supersedes the uid field. If this is non-zero, use this field, otherwise use uid) */
	Uid2 [18]byte /*EXTENSION*/

}

func (m *AutopilotVersion) ID() int        { return 148 }
func (m *AutopilotVersion) CRCExtra() byte { return 178 }

func (m *AutopilotVersion) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, uint64(m.Capabilities))
	buf = marshalUint64(buf, (m.Uid))
	buf = marshalUint32(buf, (m.FlightSwVersion))
	buf = marshalUint32(buf, (m.MiddlewareSwVersion))
	buf = marshalUint32(buf, (m.OsSwVersion))
	buf = marshalUint32(buf, (m.BoardVersion))
	buf = marshalUint16(buf, (m.VendorId))
	buf = marshalUint16(buf, (m.ProductId))
	for _, v := range m.FlightCustomVersion {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.MiddlewareCustomVersion {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.OsCustomVersion {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *AutopilotVersion) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Uid2 {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *AutopilotVersion) UnmarshalV1(buf []byte) []byte {
	{
		var v uint64
		buf, v = unmarshalUint64(buf)
		m.Capabilities = MavProtocolCapability(v)
	}
	buf, m.Uid = unmarshalUint64(buf)
	buf, m.FlightSwVersion = unmarshalUint32(buf)
	buf, m.MiddlewareSwVersion = unmarshalUint32(buf)
	buf, m.OsSwVersion = unmarshalUint32(buf)
	buf, m.BoardVersion = unmarshalUint32(buf)
	buf, m.VendorId = unmarshalUint16(buf)
	buf, m.ProductId = unmarshalUint16(buf)
	for i, _ := range m.FlightCustomVersion {
		buf, m.FlightCustomVersion[i] = unmarshalByte(buf)
	}
	for i, _ := range m.MiddlewareCustomVersion {
		buf, m.MiddlewareCustomVersion[i] = unmarshalByte(buf)
	}
	for i, _ := range m.OsCustomVersion {
		buf, m.OsCustomVersion[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *AutopilotVersion) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Uid2 {
		buf, m.Uid2[i] = unmarshalByte(buf)
	}

	return buf
}

/* The location of a landing target. See: https://mavlink.io/en/services/landing_target.html */
type LandingTarget struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X-axis angular offset of the target from the center of the image */
	AngleX float32

	/* Y-axis angular offset of the target from the center of the image */
	AngleY float32

	/* Distance to the target from the vehicle */
	Distance float32

	/* Size of target along x-axis */
	SizeX float32

	/* Size of target along y-axis */
	SizeY float32

	/* The ID of the target if multiple targets are present */
	TargetNum byte

	/* Coordinate frame used for following fields. */
	Frame MavFrame // byte

	/* X Position of the landing target in MAV_FRAME */
	X float32 /*EXTENSION*/

	/* Y Position of the landing target in MAV_FRAME */
	Y float32 /*EXTENSION*/

	/* Z Position of the landing target in MAV_FRAME */
	Z float32 /*EXTENSION*/

	/* Quaternion of landing target orientation (w, x, y, z order, zero-rotation is 1, 0, 0, 0) */
	Q [4]float32 /*EXTENSION*/

	/* Type of landing target */
	Type LandingTargetType // byte /*EXTENSION*/

	/* Boolean indicating whether the position fields (x, y, z, q, type) contain valid target position information (valid: 1, invalid: 0). Default is 0 (invalid). */
	PositionValid byte /*EXTENSION*/

}

func (m *LandingTarget) ID() int        { return 149 }
func (m *LandingTarget) CRCExtra() byte { return 200 }

func (m *LandingTarget) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.AngleX))
	buf = marshalFloat32(buf, (m.AngleY))
	buf = marshalFloat32(buf, (m.Distance))
	buf = marshalFloat32(buf, (m.SizeX))
	buf = marshalFloat32(buf, (m.SizeY))
	buf = marshalByte(buf, (m.TargetNum))
	buf = marshalByte(buf, byte(m.Frame))

	return buf
}

func (m *LandingTarget) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, byte(m.Type))
	buf = marshalByte(buf, (m.PositionValid))

	return buf
}

func (m *LandingTarget) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.AngleX = unmarshalFloat32(buf)
	buf, m.AngleY = unmarshalFloat32(buf)
	buf, m.Distance = unmarshalFloat32(buf)
	buf, m.SizeX = unmarshalFloat32(buf)
	buf, m.SizeY = unmarshalFloat32(buf)
	buf, m.TargetNum = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Frame = MavFrame(v)
	}

	return buf
}

func (m *LandingTarget) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = LandingTargetType(v)
	}
	buf, m.PositionValid = unmarshalByte(buf)

	return buf
}

/* Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovation test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovation test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user. */
type EstimatorStatus struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Velocity innovation test ratio */
	VelRatio float32

	/* Horizontal position innovation test ratio */
	PosHorizRatio float32

	/* Vertical position innovation test ratio */
	PosVertRatio float32

	/* Magnetometer innovation test ratio */
	MagRatio float32

	/* Height above terrain innovation test ratio */
	HaglRatio float32

	/* True airspeed innovation test ratio */
	TasRatio float32

	/* Horizontal position 1-STD accuracy relative to the EKF local origin */
	PosHorizAccuracy float32

	/* Vertical position 1-STD accuracy relative to the EKF local origin */
	PosVertAccuracy float32

	/* Bitmap indicating which EKF outputs are valid. */
	Flags EstimatorStatusFlags // uint16

}

func (m *EstimatorStatus) ID() int        { return 230 }
func (m *EstimatorStatus) CRCExtra() byte { return 163 }

func (m *EstimatorStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.VelRatio))
	buf = marshalFloat32(buf, (m.PosHorizRatio))
	buf = marshalFloat32(buf, (m.PosVertRatio))
	buf = marshalFloat32(buf, (m.MagRatio))
	buf = marshalFloat32(buf, (m.HaglRatio))
	buf = marshalFloat32(buf, (m.TasRatio))
	buf = marshalFloat32(buf, (m.PosHorizAccuracy))
	buf = marshalFloat32(buf, (m.PosVertAccuracy))
	buf = marshalUint16(buf, uint16(m.Flags))

	return buf
}

func (m *EstimatorStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *EstimatorStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.VelRatio = unmarshalFloat32(buf)
	buf, m.PosHorizRatio = unmarshalFloat32(buf)
	buf, m.PosVertRatio = unmarshalFloat32(buf)
	buf, m.MagRatio = unmarshalFloat32(buf)
	buf, m.HaglRatio = unmarshalFloat32(buf)
	buf, m.TasRatio = unmarshalFloat32(buf)
	buf, m.PosHorizAccuracy = unmarshalFloat32(buf)
	buf, m.PosVertAccuracy = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Flags = EstimatorStatusFlags(v)
	}

	return buf
}

func (m *EstimatorStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Wind covariance estimate from vehicle. */
type WindCov struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Wind in X (NED) direction */
	WindX float32

	/* Wind in Y (NED) direction */
	WindY float32

	/* Wind in Z (NED) direction */
	WindZ float32

	/* Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate. */
	VarHoriz float32

	/* Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate. */
	VarVert float32

	/* Altitude (MSL) that this measurement was taken at */
	WindAlt float32

	/* Horizontal speed 1-STD accuracy */
	HorizAccuracy float32

	/* Vertical speed 1-STD accuracy */
	VertAccuracy float32
}

func (m *WindCov) ID() int        { return 231 }
func (m *WindCov) CRCExtra() byte { return 105 }

func (m *WindCov) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.WindX))
	buf = marshalFloat32(buf, (m.WindY))
	buf = marshalFloat32(buf, (m.WindZ))
	buf = marshalFloat32(buf, (m.VarHoriz))
	buf = marshalFloat32(buf, (m.VarVert))
	buf = marshalFloat32(buf, (m.WindAlt))
	buf = marshalFloat32(buf, (m.HorizAccuracy))
	buf = marshalFloat32(buf, (m.VertAccuracy))

	return buf
}

func (m *WindCov) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *WindCov) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.WindX = unmarshalFloat32(buf)
	buf, m.WindY = unmarshalFloat32(buf)
	buf, m.WindZ = unmarshalFloat32(buf)
	buf, m.VarHoriz = unmarshalFloat32(buf)
	buf, m.VarVert = unmarshalFloat32(buf)
	buf, m.WindAlt = unmarshalFloat32(buf)
	buf, m.HorizAccuracy = unmarshalFloat32(buf)
	buf, m.VertAccuracy = unmarshalFloat32(buf)

	return buf
}

func (m *WindCov) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position estimate of the system. */
type GpsInput struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* GPS time (from start of GPS week) */
	TimeWeekMs uint32

	/* Latitude (WGS84) */
	Lat int32

	/* Longitude (WGS84) */
	Lon int32

	/* Altitude (MSL). Positive for up. */
	Alt float32

	/* GPS HDOP horizontal dilution of position */
	Hdop float32

	/* GPS VDOP vertical dilution of position */
	Vdop float32

	/* GPS velocity in NORTH direction in earth-fixed NED frame */
	Vn float32

	/* GPS velocity in EAST direction in earth-fixed NED frame */
	Ve float32

	/* GPS velocity in DOWN direction in earth-fixed NED frame */
	Vd float32

	/* GPS speed accuracy */
	SpeedAccuracy float32

	/* GPS horizontal accuracy */
	HorizAccuracy float32

	/* GPS vertical accuracy */
	VertAccuracy float32

	/* Bitmap indicating which GPS input flags fields to ignore.  All other fields must be provided. */
	IgnoreFlags GpsInputIgnoreFlags // uint16

	/* GPS week number */
	TimeWeek uint16

	/* ID of the GPS for multiple GPS inputs */
	GpsId byte

	/* 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK */
	FixType byte

	/* Number of satellites visible. */
	SatellitesVisible byte
}

func (m *GpsInput) ID() int        { return 232 }
func (m *GpsInput) CRCExtra() byte { return 151 }

func (m *GpsInput) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint32(buf, (m.TimeWeekMs))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalFloat32(buf, (m.Alt))
	buf = marshalFloat32(buf, (m.Hdop))
	buf = marshalFloat32(buf, (m.Vdop))
	buf = marshalFloat32(buf, (m.Vn))
	buf = marshalFloat32(buf, (m.Ve))
	buf = marshalFloat32(buf, (m.Vd))
	buf = marshalFloat32(buf, (m.SpeedAccuracy))
	buf = marshalFloat32(buf, (m.HorizAccuracy))
	buf = marshalFloat32(buf, (m.VertAccuracy))
	buf = marshalUint16(buf, uint16(m.IgnoreFlags))
	buf = marshalUint16(buf, (m.TimeWeek))
	buf = marshalByte(buf, (m.GpsId))
	buf = marshalByte(buf, (m.FixType))
	buf = marshalByte(buf, (m.SatellitesVisible))

	return buf
}

func (m *GpsInput) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *GpsInput) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.TimeWeekMs = unmarshalUint32(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalFloat32(buf)
	buf, m.Hdop = unmarshalFloat32(buf)
	buf, m.Vdop = unmarshalFloat32(buf)
	buf, m.Vn = unmarshalFloat32(buf)
	buf, m.Ve = unmarshalFloat32(buf)
	buf, m.Vd = unmarshalFloat32(buf)
	buf, m.SpeedAccuracy = unmarshalFloat32(buf)
	buf, m.HorizAccuracy = unmarshalFloat32(buf)
	buf, m.VertAccuracy = unmarshalFloat32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.IgnoreFlags = GpsInputIgnoreFlags(v)
	}
	buf, m.TimeWeek = unmarshalUint16(buf)
	buf, m.GpsId = unmarshalByte(buf)
	buf, m.FixType = unmarshalByte(buf)
	buf, m.SatellitesVisible = unmarshalByte(buf)

	return buf
}

func (m *GpsInput) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* RTCM message for injecting into the onboard GPS (used for DGPS) */
type GpsRtcmData struct {
	/* LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order. */
	Flags byte

	/* data length */
	Len byte

	/* RTCM message (may be fragmented) */
	Data [180]byte
}

func (m *GpsRtcmData) ID() int        { return 233 }
func (m *GpsRtcmData) CRCExtra() byte { return 35 }

func (m *GpsRtcmData) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.Flags))
	buf = marshalByte(buf, (m.Len))
	for _, v := range m.Data {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *GpsRtcmData) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *GpsRtcmData) UnmarshalV1(buf []byte) []byte {
	buf, m.Flags = unmarshalByte(buf)
	buf, m.Len = unmarshalByte(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *GpsRtcmData) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Message appropriate for high latency connections like Iridium */
type HighLatency struct {
	/* A bitfield for use for autopilot-specific flags. */
	CustomMode uint32

	/* Latitude */
	Latitude int32

	/* Longitude */
	Longitude int32

	/* roll */
	Roll int16

	/* pitch */
	Pitch int16

	/* heading */
	Heading uint16

	/* heading setpoint */
	HeadingSp int16

	/* Altitude above mean sea level */
	AltitudeAmsl int16

	/* Altitude setpoint relative to the home position */
	AltitudeSp int16

	/* distance to target */
	WpDistance uint16

	/* Bitmap of enabled system modes. */
	BaseMode MavModeFlag // byte

	/* The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown. */
	LandedState MavLandedState // byte

	/* throttle (percentage) */
	Throttle int8

	/* airspeed */
	Airspeed byte

	/* airspeed setpoint */
	AirspeedSp byte

	/* groundspeed */
	Groundspeed byte

	/* climb rate */
	ClimbRate int8

	/* Number of satellites visible. If unknown, set to 255 */
	GpsNsat byte

	/* GPS Fix type. */
	GpsFixType GpsFixType // byte

	/* Remaining battery (percentage) */
	BatteryRemaining byte

	/* Autopilot temperature (degrees C) */
	Temperature int8

	/* Air temperature (degrees C) from airspeed sensor */
	TemperatureAir int8

	/* failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence) */
	Failsafe byte

	/* current waypoint number */
	WpNum byte
}

func (m *HighLatency) ID() int        { return 234 }
func (m *HighLatency) CRCExtra() byte { return 150 }

func (m *HighLatency) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.CustomMode))
	buf = marshalInt32(buf, (m.Latitude))
	buf = marshalInt32(buf, (m.Longitude))
	buf = marshalInt16(buf, (m.Roll))
	buf = marshalInt16(buf, (m.Pitch))
	buf = marshalUint16(buf, (m.Heading))
	buf = marshalInt16(buf, (m.HeadingSp))
	buf = marshalInt16(buf, (m.AltitudeAmsl))
	buf = marshalInt16(buf, (m.AltitudeSp))
	buf = marshalUint16(buf, (m.WpDistance))
	buf = marshalByte(buf, byte(m.BaseMode))
	buf = marshalByte(buf, byte(m.LandedState))
	buf = marshalInt8(buf, (m.Throttle))
	buf = marshalByte(buf, (m.Airspeed))
	buf = marshalByte(buf, (m.AirspeedSp))
	buf = marshalByte(buf, (m.Groundspeed))
	buf = marshalInt8(buf, (m.ClimbRate))
	buf = marshalByte(buf, (m.GpsNsat))
	buf = marshalByte(buf, byte(m.GpsFixType))
	buf = marshalByte(buf, (m.BatteryRemaining))
	buf = marshalInt8(buf, (m.Temperature))
	buf = marshalInt8(buf, (m.TemperatureAir))
	buf = marshalByte(buf, (m.Failsafe))
	buf = marshalByte(buf, (m.WpNum))

	return buf
}

func (m *HighLatency) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HighLatency) UnmarshalV1(buf []byte) []byte {
	buf, m.CustomMode = unmarshalUint32(buf)
	buf, m.Latitude = unmarshalInt32(buf)
	buf, m.Longitude = unmarshalInt32(buf)
	buf, m.Roll = unmarshalInt16(buf)
	buf, m.Pitch = unmarshalInt16(buf)
	buf, m.Heading = unmarshalUint16(buf)
	buf, m.HeadingSp = unmarshalInt16(buf)
	buf, m.AltitudeAmsl = unmarshalInt16(buf)
	buf, m.AltitudeSp = unmarshalInt16(buf)
	buf, m.WpDistance = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.BaseMode = MavModeFlag(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.LandedState = MavLandedState(v)
	}
	buf, m.Throttle = unmarshalInt8(buf)
	buf, m.Airspeed = unmarshalByte(buf)
	buf, m.AirspeedSp = unmarshalByte(buf)
	buf, m.Groundspeed = unmarshalByte(buf)
	buf, m.ClimbRate = unmarshalInt8(buf)
	buf, m.GpsNsat = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.GpsFixType = GpsFixType(v)
	}
	buf, m.BatteryRemaining = unmarshalByte(buf)
	buf, m.Temperature = unmarshalInt8(buf)
	buf, m.TemperatureAir = unmarshalInt8(buf)
	buf, m.Failsafe = unmarshalByte(buf)
	buf, m.WpNum = unmarshalByte(buf)

	return buf
}

func (m *HighLatency) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Message appropriate for high latency connections like Iridium (version 2) */
type HighLatency2 struct {
	/* Timestamp (milliseconds since boot or Unix epoch) */
	Timestamp uint32

	/* Latitude */
	Latitude int32

	/* Longitude */
	Longitude int32

	/* A bitfield for use for autopilot-specific flags (2 byte version). */
	CustomMode uint16

	/* Altitude above mean sea level */
	Altitude int16

	/* Altitude setpoint */
	TargetAltitude int16

	/* Distance to target waypoint or position */
	TargetDistance uint16

	/* Current waypoint number */
	WpNum uint16

	/* Bitmap of failure flags. */
	FailureFlags HlFailureFlag // uint16

	/* Type of the MAV (quadrotor, helicopter, etc.) */
	Type MavType // byte

	/* Autopilot type / class. */
	Autopilot MavAutopilot // byte

	/* Heading */
	Heading byte

	/* Heading setpoint */
	TargetHeading byte

	/* Throttle */
	Throttle byte

	/* Airspeed */
	Airspeed byte

	/* Airspeed setpoint */
	AirspeedSp byte

	/* Groundspeed */
	Groundspeed byte

	/* Windspeed */
	Windspeed byte

	/* Wind heading */
	WindHeading byte

	/* Maximum error horizontal position since last message */
	Eph byte

	/* Maximum error vertical position since last message */
	Epv byte

	/* Air temperature from airspeed sensor */
	TemperatureAir int8

	/* Maximum climb rate magnitude since last message */
	ClimbRate int8

	/* Battery (percentage, -1 for DNU) */
	Battery int8

	/* Field for custom payload. */
	Custom0 int8

	/* Field for custom payload. */
	Custom1 int8

	/* Field for custom payload. */
	Custom2 int8
}

func (m *HighLatency2) ID() int        { return 235 }
func (m *HighLatency2) CRCExtra() byte { return 179 }

func (m *HighLatency2) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Timestamp))
	buf = marshalInt32(buf, (m.Latitude))
	buf = marshalInt32(buf, (m.Longitude))
	buf = marshalUint16(buf, (m.CustomMode))
	buf = marshalInt16(buf, (m.Altitude))
	buf = marshalInt16(buf, (m.TargetAltitude))
	buf = marshalUint16(buf, (m.TargetDistance))
	buf = marshalUint16(buf, (m.WpNum))
	buf = marshalUint16(buf, uint16(m.FailureFlags))
	buf = marshalByte(buf, byte(m.Type))
	buf = marshalByte(buf, byte(m.Autopilot))
	buf = marshalByte(buf, (m.Heading))
	buf = marshalByte(buf, (m.TargetHeading))
	buf = marshalByte(buf, (m.Throttle))
	buf = marshalByte(buf, (m.Airspeed))
	buf = marshalByte(buf, (m.AirspeedSp))
	buf = marshalByte(buf, (m.Groundspeed))
	buf = marshalByte(buf, (m.Windspeed))
	buf = marshalByte(buf, (m.WindHeading))
	buf = marshalByte(buf, (m.Eph))
	buf = marshalByte(buf, (m.Epv))
	buf = marshalInt8(buf, (m.TemperatureAir))
	buf = marshalInt8(buf, (m.ClimbRate))
	buf = marshalInt8(buf, (m.Battery))
	buf = marshalInt8(buf, (m.Custom0))
	buf = marshalInt8(buf, (m.Custom1))
	buf = marshalInt8(buf, (m.Custom2))

	return buf
}

func (m *HighLatency2) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *HighLatency2) UnmarshalV1(buf []byte) []byte {
	buf, m.Timestamp = unmarshalUint32(buf)
	buf, m.Latitude = unmarshalInt32(buf)
	buf, m.Longitude = unmarshalInt32(buf)
	buf, m.CustomMode = unmarshalUint16(buf)
	buf, m.Altitude = unmarshalInt16(buf)
	buf, m.TargetAltitude = unmarshalInt16(buf)
	buf, m.TargetDistance = unmarshalUint16(buf)
	buf, m.WpNum = unmarshalUint16(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.FailureFlags = HlFailureFlag(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = MavType(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Autopilot = MavAutopilot(v)
	}
	buf, m.Heading = unmarshalByte(buf)
	buf, m.TargetHeading = unmarshalByte(buf)
	buf, m.Throttle = unmarshalByte(buf)
	buf, m.Airspeed = unmarshalByte(buf)
	buf, m.AirspeedSp = unmarshalByte(buf)
	buf, m.Groundspeed = unmarshalByte(buf)
	buf, m.Windspeed = unmarshalByte(buf)
	buf, m.WindHeading = unmarshalByte(buf)
	buf, m.Eph = unmarshalByte(buf)
	buf, m.Epv = unmarshalByte(buf)
	buf, m.TemperatureAir = unmarshalInt8(buf)
	buf, m.ClimbRate = unmarshalInt8(buf)
	buf, m.Battery = unmarshalInt8(buf)
	buf, m.Custom0 = unmarshalInt8(buf)
	buf, m.Custom1 = unmarshalInt8(buf)
	buf, m.Custom2 = unmarshalInt8(buf)

	return buf
}

func (m *HighLatency2) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Vibration levels and accelerometer clipping */
type Vibration struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Vibration levels on X-axis */
	VibrationX float32

	/* Vibration levels on Y-axis */
	VibrationY float32

	/* Vibration levels on Z-axis */
	VibrationZ float32

	/* first accelerometer clipping count */
	Clipping0 uint32

	/* second accelerometer clipping count */
	Clipping1 uint32

	/* third accelerometer clipping count */
	Clipping2 uint32
}

func (m *Vibration) ID() int        { return 241 }
func (m *Vibration) CRCExtra() byte { return 90 }

func (m *Vibration) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.VibrationX))
	buf = marshalFloat32(buf, (m.VibrationY))
	buf = marshalFloat32(buf, (m.VibrationZ))
	buf = marshalUint32(buf, (m.Clipping0))
	buf = marshalUint32(buf, (m.Clipping1))
	buf = marshalUint32(buf, (m.Clipping2))

	return buf
}

func (m *Vibration) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Vibration) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.VibrationX = unmarshalFloat32(buf)
	buf, m.VibrationY = unmarshalFloat32(buf)
	buf, m.VibrationZ = unmarshalFloat32(buf)
	buf, m.Clipping0 = unmarshalUint32(buf)
	buf, m.Clipping1 = unmarshalUint32(buf)
	buf, m.Clipping2 = unmarshalUint32(buf)

	return buf
}

func (m *Vibration) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The position the system will return to and land on. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector. */
type HomePosition struct {
	/* Latitude (WGS84) */
	Latitude int32

	/* Longitude (WGS84) */
	Longitude int32

	/* Altitude (MSL). Positive for up. */
	Altitude int32

	/* Local X position of this position in the local coordinate frame */
	X float32

	/* Local Y position of this position in the local coordinate frame */
	Y float32

	/* Local Z position of this position in the local coordinate frame */
	Z float32

	/* World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground */
	Q [4]float32

	/* Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. */
	ApproachX float32

	/* Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. */
	ApproachY float32

	/* Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. */
	ApproachZ float32

	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64 /*EXTENSION*/

}

func (m *HomePosition) ID() int        { return 242 }
func (m *HomePosition) CRCExtra() byte { return 104 }

func (m *HomePosition) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.Latitude))
	buf = marshalInt32(buf, (m.Longitude))
	buf = marshalInt32(buf, (m.Altitude))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.ApproachX))
	buf = marshalFloat32(buf, (m.ApproachY))
	buf = marshalFloat32(buf, (m.ApproachZ))

	return buf
}

func (m *HomePosition) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalUint64(buf, (m.TimeUsec))

	return buf
}

func (m *HomePosition) UnmarshalV1(buf []byte) []byte {
	buf, m.Latitude = unmarshalInt32(buf)
	buf, m.Longitude = unmarshalInt32(buf)
	buf, m.Altitude = unmarshalInt32(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.ApproachX = unmarshalFloat32(buf)
	buf, m.ApproachY = unmarshalFloat32(buf)
	buf, m.ApproachZ = unmarshalFloat32(buf)

	return buf
}

func (m *HomePosition) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.TimeUsec = unmarshalUint64(buf)

	return buf
}

/* The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector. */
type SetHomePosition struct {
	/* Latitude (WGS84) */
	Latitude int32

	/* Longitude (WGS84) */
	Longitude int32

	/* Altitude (MSL). Positive for up. */
	Altitude int32

	/* Local X position of this position in the local coordinate frame */
	X float32

	/* Local Y position of this position in the local coordinate frame */
	Y float32

	/* Local Z position of this position in the local coordinate frame */
	Z float32

	/* World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground */
	Q [4]float32

	/* Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. */
	ApproachX float32

	/* Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. */
	ApproachY float32

	/* Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone. */
	ApproachZ float32

	/* System ID. */
	TargetSystem byte

	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64 /*EXTENSION*/

}

func (m *SetHomePosition) ID() int        { return 243 }
func (m *SetHomePosition) CRCExtra() byte { return 85 }

func (m *SetHomePosition) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.Latitude))
	buf = marshalInt32(buf, (m.Longitude))
	buf = marshalInt32(buf, (m.Altitude))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.ApproachX))
	buf = marshalFloat32(buf, (m.ApproachY))
	buf = marshalFloat32(buf, (m.ApproachZ))
	buf = marshalByte(buf, (m.TargetSystem))

	return buf
}

func (m *SetHomePosition) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalUint64(buf, (m.TimeUsec))

	return buf
}

func (m *SetHomePosition) UnmarshalV1(buf []byte) []byte {
	buf, m.Latitude = unmarshalInt32(buf)
	buf, m.Longitude = unmarshalInt32(buf)
	buf, m.Altitude = unmarshalInt32(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.ApproachX = unmarshalFloat32(buf)
	buf, m.ApproachY = unmarshalFloat32(buf)
	buf, m.ApproachZ = unmarshalFloat32(buf)
	buf, m.TargetSystem = unmarshalByte(buf)

	return buf
}

func (m *SetHomePosition) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.TimeUsec = unmarshalUint64(buf)

	return buf
}

/* The interval between messages for a particular MAVLink message ID. This interface replaces DATA_STREAM */
type MessageInterval struct {
	/* The interval between two messages. A value of -1 indicates this stream is disabled, 0 indicates it is not available, &gt; 0 indicates the interval at which it is sent. */
	IntervalUs int32

	/* The ID of the requested MAVLink message. v1.0 is limited to 254 messages. */
	MessageId uint16
}

func (m *MessageInterval) ID() int        { return 244 }
func (m *MessageInterval) CRCExtra() byte { return 95 }

func (m *MessageInterval) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.IntervalUs))
	buf = marshalUint16(buf, (m.MessageId))

	return buf
}

func (m *MessageInterval) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *MessageInterval) UnmarshalV1(buf []byte) []byte {
	buf, m.IntervalUs = unmarshalInt32(buf)
	buf, m.MessageId = unmarshalUint16(buf)

	return buf
}

func (m *MessageInterval) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Provides state for additional features */
type ExtendedSysState struct {
	/* The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration. */
	VtolState MavVtolState // byte

	/* The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown. */
	LandedState MavLandedState // byte

}

func (m *ExtendedSysState) ID() int        { return 245 }
func (m *ExtendedSysState) CRCExtra() byte { return 130 }

func (m *ExtendedSysState) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, byte(m.VtolState))
	buf = marshalByte(buf, byte(m.LandedState))

	return buf
}

func (m *ExtendedSysState) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ExtendedSysState) UnmarshalV1(buf []byte) []byte {
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.VtolState = MavVtolState(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.LandedState = MavLandedState(v)
	}

	return buf
}

func (m *ExtendedSysState) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The location and information of an ADSB vehicle */
type AdsbVehicle struct {
	/* ICAO address */
	IcaoAddress uint32

	/* Latitude */
	Lat int32

	/* Longitude */
	Lon int32

	/* Altitude(ASL) */
	Altitude int32

	/* Course over ground */
	Heading uint16

	/* The horizontal velocity */
	HorVelocity uint16

	/* The vertical velocity. Positive is up */
	VerVelocity int16

	/* Bitmap to indicate various statuses including valid data fields */
	Flags AdsbFlags // uint16

	/* Squawk code */
	Squawk uint16

	/* ADSB altitude type. */
	AltitudeType AdsbAltitudeType // byte

	/* The callsign, 8+null */
	Callsign [9]byte

	/* ADSB emitter type. */
	EmitterType AdsbEmitterType // byte

	/* Time since last communication in seconds */
	Tslc byte
}

func (m *AdsbVehicle) ID() int        { return 246 }
func (m *AdsbVehicle) CRCExtra() byte { return 184 }

func (m *AdsbVehicle) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.IcaoAddress))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Altitude))
	buf = marshalUint16(buf, (m.Heading))
	buf = marshalUint16(buf, (m.HorVelocity))
	buf = marshalInt16(buf, (m.VerVelocity))
	buf = marshalUint16(buf, uint16(m.Flags))
	buf = marshalUint16(buf, (m.Squawk))
	buf = marshalByte(buf, byte(m.AltitudeType))
	for _, v := range m.Callsign {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.EmitterType))
	buf = marshalByte(buf, (m.Tslc))

	return buf
}

func (m *AdsbVehicle) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *AdsbVehicle) UnmarshalV1(buf []byte) []byte {
	buf, m.IcaoAddress = unmarshalUint32(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Altitude = unmarshalInt32(buf)
	buf, m.Heading = unmarshalUint16(buf)
	buf, m.HorVelocity = unmarshalUint16(buf)
	buf, m.VerVelocity = unmarshalInt16(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Flags = AdsbFlags(v)
	}
	buf, m.Squawk = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.AltitudeType = AdsbAltitudeType(v)
	}
	for i, _ := range m.Callsign {
		buf, m.Callsign[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.EmitterType = AdsbEmitterType(v)
	}
	buf, m.Tslc = unmarshalByte(buf)

	return buf
}

func (m *AdsbVehicle) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Information about a potential collision */
type Collision struct {
	/* Unique identifier, domain based on src field */
	Id uint32

	/* Estimated time until collision occurs */
	TimeToMinimumDelta float32

	/* Closest vertical distance between vehicle and object */
	AltitudeMinimumDelta float32

	/* Closest horizontal distance between vehicle and object */
	HorizontalMinimumDelta float32

	/* Collision data source */
	Src MavCollisionSrc // byte

	/* Action that is being taken to avoid this collision */
	Action MavCollisionAction // byte

	/* How concerned the aircraft is about this collision */
	ThreatLevel MavCollisionThreatLevel // byte

}

func (m *Collision) ID() int        { return 247 }
func (m *Collision) CRCExtra() byte { return 81 }

func (m *Collision) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Id))
	buf = marshalFloat32(buf, (m.TimeToMinimumDelta))
	buf = marshalFloat32(buf, (m.AltitudeMinimumDelta))
	buf = marshalFloat32(buf, (m.HorizontalMinimumDelta))
	buf = marshalByte(buf, byte(m.Src))
	buf = marshalByte(buf, byte(m.Action))
	buf = marshalByte(buf, byte(m.ThreatLevel))

	return buf
}

func (m *Collision) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Collision) UnmarshalV1(buf []byte) []byte {
	buf, m.Id = unmarshalUint32(buf)
	buf, m.TimeToMinimumDelta = unmarshalFloat32(buf)
	buf, m.AltitudeMinimumDelta = unmarshalFloat32(buf)
	buf, m.HorizontalMinimumDelta = unmarshalFloat32(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Src = MavCollisionSrc(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Action = MavCollisionAction(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ThreatLevel = MavCollisionThreatLevel(v)
	}

	return buf
}

func (m *Collision) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Message implementing parts of the V2 payload specs in V1 frames for transitional support. */
type V2Extension struct {
	/* A code that identifies the software component that understands this message (analogous to USB device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase. */
	MessageType uint16

	/* Network ID (0 for broadcast) */
	TargetNetwork byte

	/* System ID (0 for broadcast) */
	TargetSystem byte

	/* Component ID (0 for broadcast) */
	TargetComponent byte

	/* Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification. */
	Payload [249]byte
}

func (m *V2Extension) ID() int        { return 248 }
func (m *V2Extension) CRCExtra() byte { return 8 }

func (m *V2Extension) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.MessageType))
	buf = marshalByte(buf, (m.TargetNetwork))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.Payload {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *V2Extension) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *V2Extension) UnmarshalV1(buf []byte) []byte {
	buf, m.MessageType = unmarshalUint16(buf)
	buf, m.TargetNetwork = unmarshalByte(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.Payload {
		buf, m.Payload[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *V2Extension) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output. */
type MemoryVect struct {
	/* Starting address of the debug variables */
	Address uint16

	/* Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below */
	Ver byte

	/* Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14 */
	Type byte

	/* Memory contents at specified address */
	Value [32]int8
}

func (m *MemoryVect) ID() int        { return 249 }
func (m *MemoryVect) CRCExtra() byte { return 204 }

func (m *MemoryVect) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Address))
	buf = marshalByte(buf, (m.Ver))
	buf = marshalByte(buf, (m.Type))
	for _, v := range m.Value {
		buf = marshalInt8(buf, (v))
	}

	return buf
}

func (m *MemoryVect) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *MemoryVect) UnmarshalV1(buf []byte) []byte {
	buf, m.Address = unmarshalUint16(buf)
	buf, m.Ver = unmarshalByte(buf)
	buf, m.Type = unmarshalByte(buf)
	for i, _ := range m.Value {
		buf, m.Value[i] = unmarshalInt8(buf)
	}

	return buf
}

func (m *MemoryVect) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* To debug something using a named 3D vector. */
type DebugVect struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* x */
	X float32

	/* y */
	Y float32

	/* z */
	Z float32

	/* Name */
	Name [10]byte
}

func (m *DebugVect) ID() int        { return 250 }
func (m *DebugVect) CRCExtra() byte { return 49 }

func (m *DebugVect) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	for _, v := range m.Name {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *DebugVect) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *DebugVect) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	for i, _ := range m.Name {
		buf, m.Name[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *DebugVect) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output. */
type NamedValueFloat struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Floating point value */
	Value float32

	/* Name of the debug variable */
	Name [10]byte
}

func (m *NamedValueFloat) ID() int        { return 251 }
func (m *NamedValueFloat) CRCExtra() byte { return 170 }

func (m *NamedValueFloat) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.Value))
	for _, v := range m.Name {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *NamedValueFloat) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *NamedValueFloat) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Value = unmarshalFloat32(buf)
	for i, _ := range m.Name {
		buf, m.Name[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *NamedValueFloat) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output. */
type NamedValueInt struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Signed integer value */
	Value int32

	/* Name of the debug variable */
	Name [10]byte
}

func (m *NamedValueInt) ID() int        { return 252 }
func (m *NamedValueInt) CRCExtra() byte { return 44 }

func (m *NamedValueInt) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt32(buf, (m.Value))
	for _, v := range m.Name {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *NamedValueInt) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *NamedValueInt) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Value = unmarshalInt32(buf)
	for i, _ := range m.Name {
		buf, m.Name[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *NamedValueInt) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz). */
type Statustext struct {
	/* Severity of status. Relies on the definitions within RFC-5424. */
	Severity MavSeverity // byte

	/* Status text message, without null termination character */
	Text [50]byte
}

func (m *Statustext) ID() int        { return 253 }
func (m *Statustext) CRCExtra() byte { return 83 }

func (m *Statustext) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, byte(m.Severity))
	for _, v := range m.Text {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *Statustext) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Statustext) UnmarshalV1(buf []byte) []byte {
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Severity = MavSeverity(v)
	}
	for i, _ := range m.Text {
		buf, m.Text[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *Statustext) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N. */
type Debug struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* DEBUG value */
	Value float32

	/* index of debug variable */
	Ind byte
}

func (m *Debug) ID() int        { return 254 }
func (m *Debug) CRCExtra() byte { return 46 }

func (m *Debug) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.Value))
	buf = marshalByte(buf, (m.Ind))

	return buf
}

func (m *Debug) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *Debug) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Value = unmarshalFloat32(buf)
	buf, m.Ind = unmarshalByte(buf)

	return buf
}

func (m *Debug) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable signing */
type SetupSigning struct {
	/* initial timestamp */
	InitialTimestamp uint64

	/* system id of the target */
	TargetSystem byte

	/* component ID of the target */
	TargetComponent byte

	/* signing key */
	SecretKey [32]byte
}

func (m *SetupSigning) ID() int        { return 256 }
func (m *SetupSigning) CRCExtra() byte { return 71 }

func (m *SetupSigning) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.InitialTimestamp))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.SecretKey {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *SetupSigning) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SetupSigning) UnmarshalV1(buf []byte) []byte {
	buf, m.InitialTimestamp = unmarshalUint64(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.SecretKey {
		buf, m.SecretKey[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *SetupSigning) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Report button state change. */
type ButtonChange struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Time of last change of button state. */
	LastChangeMs uint32

	/* Bitmap for state of buttons. */
	State byte
}

func (m *ButtonChange) ID() int        { return 257 }
func (m *ButtonChange) CRCExtra() byte { return 131 }

func (m *ButtonChange) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalUint32(buf, (m.LastChangeMs))
	buf = marshalByte(buf, (m.State))

	return buf
}

func (m *ButtonChange) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ButtonChange) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.LastChangeMs = unmarshalUint32(buf)
	buf, m.State = unmarshalByte(buf)

	return buf
}

func (m *ButtonChange) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Control vehicle tone generation (buzzer) */
type PlayTune struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* tune in board specific format */
	Tune [30]byte

	/* tune extension (appended to tune) */
	Tune2 [200]byte /*EXTENSION*/

}

func (m *PlayTune) ID() int        { return 258 }
func (m *PlayTune) CRCExtra() byte { return 187 }

func (m *PlayTune) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.Tune {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *PlayTune) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Tune2 {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *PlayTune) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.Tune {
		buf, m.Tune[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *PlayTune) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Tune2 {
		buf, m.Tune2[i] = unmarshalByte(buf)
	}

	return buf
}

/* Information about a camera */
type CameraInformation struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Version of the camera firmware (v &lt;&lt; 24 &amp; 0xff = Dev, v &lt;&lt; 16 &amp; 0xff = Patch, v &lt;&lt; 8 &amp; 0xff = Minor, v &amp; 0xff = Major) */
	FirmwareVersion uint32

	/* Focal length */
	FocalLength float32

	/* Image sensor size horizontal */
	SensorSizeH float32

	/* Image sensor size vertical */
	SensorSizeV float32

	/* Bitmap of camera capability flags. */
	Flags CameraCapFlags // uint32

	/* Horizontal image resolution */
	ResolutionH uint16

	/* Vertical image resolution */
	ResolutionV uint16

	/* Camera definition version (iteration) */
	CamDefinitionVersion uint16

	/* Name of the camera vendor */
	VendorName [32]byte

	/* Name of the camera model */
	ModelName [32]byte

	/* Reserved for a lens ID */
	LensId byte

	/* Camera definition URI (if any, otherwise only basic functions will be available). */
	CamDefinitionUri [140]byte
}

func (m *CameraInformation) ID() int        { return 259 }
func (m *CameraInformation) CRCExtra() byte { return 92 }

func (m *CameraInformation) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalUint32(buf, (m.FirmwareVersion))
	buf = marshalFloat32(buf, (m.FocalLength))
	buf = marshalFloat32(buf, (m.SensorSizeH))
	buf = marshalFloat32(buf, (m.SensorSizeV))
	buf = marshalUint32(buf, uint32(m.Flags))
	buf = marshalUint16(buf, (m.ResolutionH))
	buf = marshalUint16(buf, (m.ResolutionV))
	buf = marshalUint16(buf, (m.CamDefinitionVersion))
	for _, v := range m.VendorName {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.ModelName {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, (m.LensId))
	for _, v := range m.CamDefinitionUri {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *CameraInformation) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *CameraInformation) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.FirmwareVersion = unmarshalUint32(buf)
	buf, m.FocalLength = unmarshalFloat32(buf)
	buf, m.SensorSizeH = unmarshalFloat32(buf)
	buf, m.SensorSizeV = unmarshalFloat32(buf)
	{
		var v uint32
		buf, v = unmarshalUint32(buf)
		m.Flags = CameraCapFlags(v)
	}
	buf, m.ResolutionH = unmarshalUint16(buf)
	buf, m.ResolutionV = unmarshalUint16(buf)
	buf, m.CamDefinitionVersion = unmarshalUint16(buf)
	for i, _ := range m.VendorName {
		buf, m.VendorName[i] = unmarshalByte(buf)
	}
	for i, _ := range m.ModelName {
		buf, m.ModelName[i] = unmarshalByte(buf)
	}
	buf, m.LensId = unmarshalByte(buf)
	for i, _ := range m.CamDefinitionUri {
		buf, m.CamDefinitionUri[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *CameraInformation) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Settings of a camera, can be requested using MAV_CMD_REQUEST_CAMERA_SETTINGS. */
type CameraSettings struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Camera mode */
	ModeId CameraMode // byte

	/* Current zoom level (0.0 to 100.0, NaN if not known) */
	Zoomlevel float32 /*EXTENSION*/

	/* Current focus level (0.0 to 100.0, NaN if not known) */
	Focuslevel float32 /*EXTENSION*/

}

func (m *CameraSettings) ID() int        { return 260 }
func (m *CameraSettings) CRCExtra() byte { return 146 }

func (m *CameraSettings) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalByte(buf, byte(m.ModeId))

	return buf
}

func (m *CameraSettings) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalFloat32(buf, (m.Zoomlevel))
	buf = marshalFloat32(buf, (m.Focuslevel))

	return buf
}

func (m *CameraSettings) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ModeId = CameraMode(v)
	}

	return buf
}

func (m *CameraSettings) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.Zoomlevel = unmarshalFloat32(buf)
	buf, m.Focuslevel = unmarshalFloat32(buf)

	return buf
}

/* Information about a storage medium. */
type StorageInformation struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Total capacity. */
	TotalCapacity float32

	/* Used capacity. */
	UsedCapacity float32

	/* Available storage capacity. */
	AvailableCapacity float32

	/* Read speed. */
	ReadSpeed float32

	/* Write speed. */
	WriteSpeed float32

	/* Storage ID (1 for first, 2 for second, etc.) */
	StorageId byte

	/* Number of storage devices */
	StorageCount byte

	/* Status of storage (0 not available, 1 unformatted, 2 formatted) */
	Status byte
}

func (m *StorageInformation) ID() int        { return 261 }
func (m *StorageInformation) CRCExtra() byte { return 179 }

func (m *StorageInformation) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.TotalCapacity))
	buf = marshalFloat32(buf, (m.UsedCapacity))
	buf = marshalFloat32(buf, (m.AvailableCapacity))
	buf = marshalFloat32(buf, (m.ReadSpeed))
	buf = marshalFloat32(buf, (m.WriteSpeed))
	buf = marshalByte(buf, (m.StorageId))
	buf = marshalByte(buf, (m.StorageCount))
	buf = marshalByte(buf, (m.Status))

	return buf
}

func (m *StorageInformation) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *StorageInformation) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.TotalCapacity = unmarshalFloat32(buf)
	buf, m.UsedCapacity = unmarshalFloat32(buf)
	buf, m.AvailableCapacity = unmarshalFloat32(buf)
	buf, m.ReadSpeed = unmarshalFloat32(buf)
	buf, m.WriteSpeed = unmarshalFloat32(buf)
	buf, m.StorageId = unmarshalByte(buf)
	buf, m.StorageCount = unmarshalByte(buf)
	buf, m.Status = unmarshalByte(buf)

	return buf
}

func (m *StorageInformation) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Information about the status of a capture. */
type CameraCaptureStatus struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Image capture interval */
	ImageInterval float32

	/* Time since recording started */
	RecordingTimeMs uint32

	/* Available storage capacity. */
	AvailableCapacity float32

	/* Current status of image capturing (0: idle, 1: capture in progress, 2: interval set but idle, 3: interval set and capture in progress) */
	ImageStatus byte

	/* Current status of video capturing (0: idle, 1: capture in progress) */
	VideoStatus byte
}

func (m *CameraCaptureStatus) ID() int        { return 262 }
func (m *CameraCaptureStatus) CRCExtra() byte { return 12 }

func (m *CameraCaptureStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.ImageInterval))
	buf = marshalUint32(buf, (m.RecordingTimeMs))
	buf = marshalFloat32(buf, (m.AvailableCapacity))
	buf = marshalByte(buf, (m.ImageStatus))
	buf = marshalByte(buf, (m.VideoStatus))

	return buf
}

func (m *CameraCaptureStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *CameraCaptureStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.ImageInterval = unmarshalFloat32(buf)
	buf, m.RecordingTimeMs = unmarshalUint32(buf)
	buf, m.AvailableCapacity = unmarshalFloat32(buf)
	buf, m.ImageStatus = unmarshalByte(buf)
	buf, m.VideoStatus = unmarshalByte(buf)

	return buf
}

func (m *CameraCaptureStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Information about a captured image */
type CameraImageCaptured struct {
	/* Timestamp (time since UNIX epoch) in UTC. 0 for unknown. */
	TimeUtc uint64

	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Latitude where image was taken */
	Lat int32

	/* Longitude where capture was taken */
	Lon int32

	/* Altitude (MSL) where image was taken */
	Alt int32

	/* Altitude above ground */
	RelativeAlt int32

	/* Quaternion of camera orientation (w, x, y, z order, zero-rotation is 0, 0, 0, 0) */
	Q [4]float32

	/* Zero based index of this image (image count since armed -1) */
	ImageIndex int32

	/* Camera ID (1 for first, 2 for second, etc.) */
	CameraId byte

	/* Boolean indicating success (1) or failure (0) while capturing this image. */
	CaptureResult int8

	/* URL of image taken. Either local storage or http://foo.jpg if camera provides an HTTP interface. */
	FileUrl [205]byte
}

func (m *CameraImageCaptured) ID() int        { return 263 }
func (m *CameraImageCaptured) CRCExtra() byte { return 133 }

func (m *CameraImageCaptured) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUtc))
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalInt32(buf, (m.RelativeAlt))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalInt32(buf, (m.ImageIndex))
	buf = marshalByte(buf, (m.CameraId))
	buf = marshalInt8(buf, (m.CaptureResult))
	for _, v := range m.FileUrl {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *CameraImageCaptured) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *CameraImageCaptured) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUtc = unmarshalUint64(buf)
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.RelativeAlt = unmarshalInt32(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.ImageIndex = unmarshalInt32(buf)
	buf, m.CameraId = unmarshalByte(buf)
	buf, m.CaptureResult = unmarshalInt8(buf)
	for i, _ := range m.FileUrl {
		buf, m.FileUrl[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *CameraImageCaptured) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Information about flight since last arming. */
type FlightInformation struct {
	/* Timestamp at arming (time since UNIX epoch) in UTC, 0 for unknown */
	ArmingTimeUtc uint64

	/* Timestamp at takeoff (time since UNIX epoch) in UTC, 0 for unknown */
	TakeoffTimeUtc uint64

	/* Universally unique identifier (UUID) of flight, should correspond to name of log files */
	FlightUuid uint64

	/* Timestamp (time since system boot). */
	TimeBootMs uint32
}

func (m *FlightInformation) ID() int        { return 264 }
func (m *FlightInformation) CRCExtra() byte { return 49 }

func (m *FlightInformation) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.ArmingTimeUtc))
	buf = marshalUint64(buf, (m.TakeoffTimeUtc))
	buf = marshalUint64(buf, (m.FlightUuid))
	buf = marshalUint32(buf, (m.TimeBootMs))

	return buf
}

func (m *FlightInformation) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *FlightInformation) UnmarshalV1(buf []byte) []byte {
	buf, m.ArmingTimeUtc = unmarshalUint64(buf)
	buf, m.TakeoffTimeUtc = unmarshalUint64(buf)
	buf, m.FlightUuid = unmarshalUint64(buf)
	buf, m.TimeBootMs = unmarshalUint32(buf)

	return buf
}

func (m *FlightInformation) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Orientation of a mount */
type MountOrientation struct {
	/* Timestamp (time since system boot). */
	TimeBootMs uint32

	/* Roll in global frame (set to NaN for invalid). */
	Roll float32

	/* Pitch in global frame (set to NaN for invalid). */
	Pitch float32

	/* Yaw relative to vehicle(set to NaN for invalid). */
	Yaw float32

	/* Yaw in absolute frame, North is 0 (set to NaN for invalid). */
	YawAbsolute float32 /*EXTENSION*/

}

func (m *MountOrientation) ID() int        { return 265 }
func (m *MountOrientation) CRCExtra() byte { return 26 }

func (m *MountOrientation) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.TimeBootMs))
	buf = marshalFloat32(buf, (m.Roll))
	buf = marshalFloat32(buf, (m.Pitch))
	buf = marshalFloat32(buf, (m.Yaw))

	return buf
}

func (m *MountOrientation) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalFloat32(buf, (m.YawAbsolute))

	return buf
}

func (m *MountOrientation) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeBootMs = unmarshalUint32(buf)
	buf, m.Roll = unmarshalFloat32(buf)
	buf, m.Pitch = unmarshalFloat32(buf)
	buf, m.Yaw = unmarshalFloat32(buf)

	return buf
}

func (m *MountOrientation) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.YawAbsolute = unmarshalFloat32(buf)

	return buf
}

/* A message containing logged data (see also MAV_CMD_LOGGING_START) */
type LoggingData struct {
	/* sequence number (can wrap) */
	Sequence uint16

	/* system ID of the target */
	TargetSystem byte

	/* component ID of the target */
	TargetComponent byte

	/* data length */
	Length byte

	/* offset into data where first message starts. This can be used for recovery, when a previous message got lost (set to 255 if no start exists). */
	FirstMessageOffset byte

	/* logged data */
	Data [249]byte
}

func (m *LoggingData) ID() int        { return 266 }
func (m *LoggingData) CRCExtra() byte { return 193 }

func (m *LoggingData) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Sequence))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, (m.Length))
	buf = marshalByte(buf, (m.FirstMessageOffset))
	for _, v := range m.Data {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *LoggingData) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LoggingData) UnmarshalV1(buf []byte) []byte {
	buf, m.Sequence = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	buf, m.Length = unmarshalByte(buf)
	buf, m.FirstMessageOffset = unmarshalByte(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *LoggingData) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* A message containing logged data which requires a LOGGING_ACK to be sent back */
type LoggingDataAcked struct {
	/* sequence number (can wrap) */
	Sequence uint16

	/* system ID of the target */
	TargetSystem byte

	/* component ID of the target */
	TargetComponent byte

	/* data length */
	Length byte

	/* offset into data where first message starts. This can be used for recovery, when a previous message got lost (set to 255 if no start exists). */
	FirstMessageOffset byte

	/* logged data */
	Data [249]byte
}

func (m *LoggingDataAcked) ID() int        { return 267 }
func (m *LoggingDataAcked) CRCExtra() byte { return 35 }

func (m *LoggingDataAcked) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Sequence))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	buf = marshalByte(buf, (m.Length))
	buf = marshalByte(buf, (m.FirstMessageOffset))
	for _, v := range m.Data {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *LoggingDataAcked) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LoggingDataAcked) UnmarshalV1(buf []byte) []byte {
	buf, m.Sequence = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	buf, m.Length = unmarshalByte(buf)
	buf, m.FirstMessageOffset = unmarshalByte(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *LoggingDataAcked) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* An ack for a LOGGING_DATA_ACKED message */
type LoggingAck struct {
	/* sequence number (must match the one in LOGGING_DATA_ACKED) */
	Sequence uint16

	/* system ID of the target */
	TargetSystem byte

	/* component ID of the target */
	TargetComponent byte
}

func (m *LoggingAck) ID() int        { return 268 }
func (m *LoggingAck) CRCExtra() byte { return 14 }

func (m *LoggingAck) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Sequence))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *LoggingAck) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *LoggingAck) UnmarshalV1(buf []byte) []byte {
	buf, m.Sequence = unmarshalUint16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *LoggingAck) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Information about video stream */
type VideoStreamInformation struct {
	/* Frame rate. */
	Framerate float32

	/* Bit rate. */
	Bitrate uint32

	/* Bitmap of stream status flags. */
	Flags VideoStreamStatusFlags // uint16

	/* Horizontal resolution. */
	ResolutionH uint16

	/* Vertical resolution. */
	ResolutionV uint16

	/* Video image rotation clockwise. */
	Rotation uint16

	/* Horizontal Field of view. */
	Hfov uint16

	/* Video Stream ID (1 for first, 2 for second, etc.) */
	StreamId byte

	/* Number of streams available. */
	Count byte

	/* Type of stream. */
	Type VideoStreamType // byte

	/* Stream name. */
	Name [32]byte

	/* Video stream URI (TCP or RTSP URI ground station should connect to) or port number (UDP port ground station should listen to). */
	Uri [160]byte
}

func (m *VideoStreamInformation) ID() int        { return 269 }
func (m *VideoStreamInformation) CRCExtra() byte { return 109 }

func (m *VideoStreamInformation) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Framerate))
	buf = marshalUint32(buf, (m.Bitrate))
	buf = marshalUint16(buf, uint16(m.Flags))
	buf = marshalUint16(buf, (m.ResolutionH))
	buf = marshalUint16(buf, (m.ResolutionV))
	buf = marshalUint16(buf, (m.Rotation))
	buf = marshalUint16(buf, (m.Hfov))
	buf = marshalByte(buf, (m.StreamId))
	buf = marshalByte(buf, (m.Count))
	buf = marshalByte(buf, byte(m.Type))
	for _, v := range m.Name {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.Uri {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *VideoStreamInformation) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *VideoStreamInformation) UnmarshalV1(buf []byte) []byte {
	buf, m.Framerate = unmarshalFloat32(buf)
	buf, m.Bitrate = unmarshalUint32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Flags = VideoStreamStatusFlags(v)
	}
	buf, m.ResolutionH = unmarshalUint16(buf)
	buf, m.ResolutionV = unmarshalUint16(buf)
	buf, m.Rotation = unmarshalUint16(buf)
	buf, m.Hfov = unmarshalUint16(buf)
	buf, m.StreamId = unmarshalByte(buf)
	buf, m.Count = unmarshalByte(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = VideoStreamType(v)
	}
	for i, _ := range m.Name {
		buf, m.Name[i] = unmarshalByte(buf)
	}
	for i, _ := range m.Uri {
		buf, m.Uri[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *VideoStreamInformation) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Information about the status of a video stream. */
type VideoStreamStatus struct {
	/* Frame rate */
	Framerate float32

	/* Bit rate */
	Bitrate uint32

	/* Bitmap of stream status flags */
	Flags VideoStreamStatusFlags // uint16

	/* Horizontal resolution */
	ResolutionH uint16

	/* Vertical resolution */
	ResolutionV uint16

	/* Video image rotation clockwise */
	Rotation uint16

	/* Horizontal Field of view */
	Hfov uint16

	/* Video Stream ID (1 for first, 2 for second, etc.) */
	StreamId byte
}

func (m *VideoStreamStatus) ID() int        { return 270 }
func (m *VideoStreamStatus) CRCExtra() byte { return 59 }

func (m *VideoStreamStatus) MarshalV1(buf []byte) []byte {
	buf = marshalFloat32(buf, (m.Framerate))
	buf = marshalUint32(buf, (m.Bitrate))
	buf = marshalUint16(buf, uint16(m.Flags))
	buf = marshalUint16(buf, (m.ResolutionH))
	buf = marshalUint16(buf, (m.ResolutionV))
	buf = marshalUint16(buf, (m.Rotation))
	buf = marshalUint16(buf, (m.Hfov))
	buf = marshalByte(buf, (m.StreamId))

	return buf
}

func (m *VideoStreamStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *VideoStreamStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.Framerate = unmarshalFloat32(buf)
	buf, m.Bitrate = unmarshalUint32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Flags = VideoStreamStatusFlags(v)
	}
	buf, m.ResolutionH = unmarshalUint16(buf)
	buf, m.ResolutionV = unmarshalUint16(buf)
	buf, m.Rotation = unmarshalUint16(buf)
	buf, m.Hfov = unmarshalUint16(buf)
	buf, m.StreamId = unmarshalByte(buf)

	return buf
}

func (m *VideoStreamStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Configure AP SSID and Password. */
type WifiConfigAp struct {
	/* Name of Wi-Fi network (SSID). Leave it blank to leave it unchanged. */
	Ssid [32]byte

	/* Password. Leave it blank for an open AP. */
	Password [64]byte
}

func (m *WifiConfigAp) ID() int        { return 299 }
func (m *WifiConfigAp) CRCExtra() byte { return 19 }

func (m *WifiConfigAp) MarshalV1(buf []byte) []byte {
	for _, v := range m.Ssid {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.Password {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *WifiConfigAp) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *WifiConfigAp) UnmarshalV1(buf []byte) []byte {
	for i, _ := range m.Ssid {
		buf, m.Ssid[i] = unmarshalByte(buf)
	}
	for i, _ := range m.Password {
		buf, m.Password[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *WifiConfigAp) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Version and capability of protocol version. This message is the response to REQUEST_PROTOCOL_VERSION and is used as part of the handshaking to establish which MAVLink version should be used on the network. Every node should respond to REQUEST_PROTOCOL_VERSION to enable the handshaking. Library implementers should consider adding this into the default decoding state machine to allow the protocol core to respond directly. */
type ProtocolVersion struct {
	/* Currently active MAVLink version number * 100: v1.0 is 100, v2.0 is 200, etc. */
	Version uint16

	/* Minimum MAVLink version supported */
	MinVersion uint16

	/* Maximum MAVLink version supported (set to the same value as version by default) */
	MaxVersion uint16

	/* The first 8 bytes (not characters printed in hex!) of the git hash. */
	SpecVersionHash [8]byte

	/* The first 8 bytes (not characters printed in hex!) of the git hash. */
	LibraryVersionHash [8]byte
}

func (m *ProtocolVersion) ID() int        { return 300 }
func (m *ProtocolVersion) CRCExtra() byte { return 217 }

func (m *ProtocolVersion) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.Version))
	buf = marshalUint16(buf, (m.MinVersion))
	buf = marshalUint16(buf, (m.MaxVersion))
	for _, v := range m.SpecVersionHash {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.LibraryVersionHash {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *ProtocolVersion) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ProtocolVersion) UnmarshalV1(buf []byte) []byte {
	buf, m.Version = unmarshalUint16(buf)
	buf, m.MinVersion = unmarshalUint16(buf)
	buf, m.MaxVersion = unmarshalUint16(buf)
	for i, _ := range m.SpecVersionHash {
		buf, m.SpecVersionHash[i] = unmarshalByte(buf)
	}
	for i, _ := range m.LibraryVersionHash {
		buf, m.LibraryVersionHash[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *ProtocolVersion) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus" for the background information. The UAVCAN specification is available at http://uavcan.org. */
type UavcanNodeStatus struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Time since the start-up of the node. */
	UptimeSec uint32

	/* Vendor-specific status information. */
	VendorSpecificStatusCode uint16

	/* Generalized node health status. */
	Health UavcanNodeHealth // byte

	/* Generalized operating mode. */
	Mode UavcanNodeMode // byte

	/* Not used currently. */
	SubMode byte
}

func (m *UavcanNodeStatus) ID() int        { return 310 }
func (m *UavcanNodeStatus) CRCExtra() byte { return 28 }

func (m *UavcanNodeStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint32(buf, (m.UptimeSec))
	buf = marshalUint16(buf, (m.VendorSpecificStatusCode))
	buf = marshalByte(buf, byte(m.Health))
	buf = marshalByte(buf, byte(m.Mode))
	buf = marshalByte(buf, (m.SubMode))

	return buf
}

func (m *UavcanNodeStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *UavcanNodeStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.UptimeSec = unmarshalUint32(buf)
	buf, m.VendorSpecificStatusCode = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Health = UavcanNodeHealth(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Mode = UavcanNodeMode(v)
	}
	buf, m.SubMode = unmarshalByte(buf)

	return buf
}

func (m *UavcanNodeStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification is available at http://uavcan.org. */
type UavcanNodeInfo struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Time since the start-up of the node. */
	UptimeSec uint32

	/* Version control system (VCS) revision identifier (e.g. git short commit hash). Zero if unknown. */
	SwVcsCommit uint32

	/* Node name string. For example, "sapog.px4.io". */
	Name [80]byte

	/* Hardware major version number. */
	HwVersionMajor byte

	/* Hardware minor version number. */
	HwVersionMinor byte

	/* Hardware unique 128-bit ID. */
	HwUniqueId [16]byte

	/* Software major version number. */
	SwVersionMajor byte

	/* Software minor version number. */
	SwVersionMinor byte
}

func (m *UavcanNodeInfo) ID() int        { return 311 }
func (m *UavcanNodeInfo) CRCExtra() byte { return 95 }

func (m *UavcanNodeInfo) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint32(buf, (m.UptimeSec))
	buf = marshalUint32(buf, (m.SwVcsCommit))
	for _, v := range m.Name {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, (m.HwVersionMajor))
	buf = marshalByte(buf, (m.HwVersionMinor))
	for _, v := range m.HwUniqueId {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, (m.SwVersionMajor))
	buf = marshalByte(buf, (m.SwVersionMinor))

	return buf
}

func (m *UavcanNodeInfo) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *UavcanNodeInfo) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.UptimeSec = unmarshalUint32(buf)
	buf, m.SwVcsCommit = unmarshalUint32(buf)
	for i, _ := range m.Name {
		buf, m.Name[i] = unmarshalByte(buf)
	}
	buf, m.HwVersionMajor = unmarshalByte(buf)
	buf, m.HwVersionMinor = unmarshalByte(buf)
	for i, _ := range m.HwUniqueId {
		buf, m.HwUniqueId[i] = unmarshalByte(buf)
	}
	buf, m.SwVersionMajor = unmarshalByte(buf)
	buf, m.SwVersionMinor = unmarshalByte(buf)

	return buf
}

func (m *UavcanNodeInfo) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request to read the value of a parameter with the either the param_id string id or param_index. */
type ParamExtRequestRead struct {
	/* Parameter index. Set to -1 to use the Parameter ID field as identifier (else param_id will be ignored) */
	ParamIndex int16

	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte
}

func (m *ParamExtRequestRead) ID() int        { return 320 }
func (m *ParamExtRequestRead) CRCExtra() byte { return 243 }

func (m *ParamExtRequestRead) MarshalV1(buf []byte) []byte {
	buf = marshalInt16(buf, (m.ParamIndex))
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *ParamExtRequestRead) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamExtRequestRead) UnmarshalV1(buf []byte) []byte {
	buf, m.ParamIndex = unmarshalInt16(buf)
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *ParamExtRequestRead) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Request all parameters of this component. After this request, all parameters are emitted. */
type ParamExtRequestList struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte
}

func (m *ParamExtRequestList) ID() int        { return 321 }
func (m *ParamExtRequestList) CRCExtra() byte { return 88 }

func (m *ParamExtRequestList) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))

	return buf
}

func (m *ParamExtRequestList) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamExtRequestList) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)

	return buf
}

func (m *ParamExtRequestList) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows them to re-request missing parameters after a loss or timeout. */
type ParamExtValue struct {
	/* Total number of parameters */
	ParamCount uint16

	/* Index of this parameter */
	ParamIndex uint16

	/* Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte

	/* Parameter value */
	ParamValue [128]byte

	/* Parameter type. */
	ParamType MavParamExtType // byte

}

func (m *ParamExtValue) ID() int        { return 322 }
func (m *ParamExtValue) CRCExtra() byte { return 243 }

func (m *ParamExtValue) MarshalV1(buf []byte) []byte {
	buf = marshalUint16(buf, (m.ParamCount))
	buf = marshalUint16(buf, (m.ParamIndex))
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.ParamValue {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.ParamType))

	return buf
}

func (m *ParamExtValue) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamExtValue) UnmarshalV1(buf []byte) []byte {
	buf, m.ParamCount = unmarshalUint16(buf)
	buf, m.ParamIndex = unmarshalUint16(buf)
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}
	for i, _ := range m.ParamValue {
		buf, m.ParamValue[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ParamType = MavParamExtType(v)
	}

	return buf
}

func (m *ParamExtValue) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when setting a parameter value and the new value is the same as the current value, you will immediately get a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive a PARAM_ACK_IN_PROGRESS in response. */
type ParamExtSet struct {
	/* System ID */
	TargetSystem byte

	/* Component ID */
	TargetComponent byte

	/* Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte

	/* Parameter value */
	ParamValue [128]byte

	/* Parameter type. */
	ParamType MavParamExtType // byte

}

func (m *ParamExtSet) ID() int        { return 323 }
func (m *ParamExtSet) CRCExtra() byte { return 78 }

func (m *ParamExtSet) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, (m.TargetSystem))
	buf = marshalByte(buf, (m.TargetComponent))
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.ParamValue {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.ParamType))

	return buf
}

func (m *ParamExtSet) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamExtSet) UnmarshalV1(buf []byte) []byte {
	buf, m.TargetSystem = unmarshalByte(buf)
	buf, m.TargetComponent = unmarshalByte(buf)
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}
	for i, _ := range m.ParamValue {
		buf, m.ParamValue[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ParamType = MavParamExtType(v)
	}

	return buf
}

func (m *ParamExtSet) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Response from a PARAM_EXT_SET message. */
type ParamExtAck struct {
	/* Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string */
	ParamId [16]byte

	/* Parameter value (new value if PARAM_ACK_ACCEPTED, current value otherwise) */
	ParamValue [128]byte

	/* Parameter type. */
	ParamType MavParamExtType // byte

	/* Result code. */
	ParamResult ParamAck // byte

}

func (m *ParamExtAck) ID() int        { return 324 }
func (m *ParamExtAck) CRCExtra() byte { return 132 }

func (m *ParamExtAck) MarshalV1(buf []byte) []byte {
	for _, v := range m.ParamId {
		buf = marshalByte(buf, (v))
	}
	for _, v := range m.ParamValue {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.ParamType))
	buf = marshalByte(buf, byte(m.ParamResult))

	return buf
}

func (m *ParamExtAck) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ParamExtAck) UnmarshalV1(buf []byte) []byte {
	for i, _ := range m.ParamId {
		buf, m.ParamId[i] = unmarshalByte(buf)
	}
	for i, _ := range m.ParamValue {
		buf, m.ParamValue[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ParamType = MavParamExtType(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ParamResult = ParamAck(v)
	}

	return buf
}

func (m *ParamExtAck) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Obstacle distances in front of the sensor, starting from the left in increment degrees to the right */
type ObstacleDistance struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Distance of obstacles around the UAV with index 0 corresponding to local North. A value of 0 means that the obstacle is right in front of the sensor. A value of max_distance +1 means no obstacle is present. A value of UINT16_MAX for unknown/not used. In a array element, one unit corresponds to 1cm. */
	Distances [72]uint16

	/* Minimum distance the sensor can measure. */
	MinDistance uint16

	/* Maximum distance the sensor can measure. */
	MaxDistance uint16

	/* Class id of the distance sensor type. */
	SensorType MavDistanceSensor // byte

	/* Angular width in degrees of each array element. */
	Increment byte
}

func (m *ObstacleDistance) ID() int        { return 330 }
func (m *ObstacleDistance) CRCExtra() byte { return 23 }

func (m *ObstacleDistance) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.Distances {
		buf = marshalUint16(buf, (v))
	}
	buf = marshalUint16(buf, (m.MinDistance))
	buf = marshalUint16(buf, (m.MaxDistance))
	buf = marshalByte(buf, byte(m.SensorType))
	buf = marshalByte(buf, (m.Increment))

	return buf
}

func (m *ObstacleDistance) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *ObstacleDistance) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.Distances {
		buf, m.Distances[i] = unmarshalUint16(buf)
	}
	buf, m.MinDistance = unmarshalUint16(buf)
	buf, m.MaxDistance = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.SensorType = MavDistanceSensor(v)
	}
	buf, m.Increment = unmarshalByte(buf)

	return buf
}

func (m *ObstacleDistance) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Odometry message to communicate odometry information with an external interface. Fits ROS REP 147 standard for aerial vehicles (http://www.ros.org/reps/rep-0147.html). */
type Odometry struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X Position */
	X float32

	/* Y Position */
	Y float32

	/* Z Position */
	Z float32

	/* Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation) */
	Q [4]float32

	/* X linear speed */
	Vx float32

	/* Y linear speed */
	Vy float32

	/* Z linear speed */
	Vz float32

	/* Roll angular speed */
	Rollspeed float32

	/* Pitch angular speed */
	Pitchspeed float32

	/* Yaw angular speed */
	Yawspeed float32

	/* Row-major representation of a 6x6 pose cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array. */
	PoseCovariance [21]float32

	/* Row-major representation of a 6x6 velocity cross-covariance matrix upper right triangle (states: vx, vy, vz, rollspeed, pitchspeed, yawspeed; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array. */
	VelocityCovariance [21]float32

	/* Coordinate frame of reference for the pose data. */
	FrameId MavFrame // byte

	/* Coordinate frame of reference for the velocity in free space (twist) data. */
	ChildFrameId MavFrame // byte

	/* Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps. */
	ResetCounter byte /*EXTENSION*/

}

func (m *Odometry) ID() int        { return 331 }
func (m *Odometry) CRCExtra() byte { return 91 }

func (m *Odometry) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.X))
	buf = marshalFloat32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	for _, v := range m.Q {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalFloat32(buf, (m.Vx))
	buf = marshalFloat32(buf, (m.Vy))
	buf = marshalFloat32(buf, (m.Vz))
	buf = marshalFloat32(buf, (m.Rollspeed))
	buf = marshalFloat32(buf, (m.Pitchspeed))
	buf = marshalFloat32(buf, (m.Yawspeed))
	for _, v := range m.PoseCovariance {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.VelocityCovariance {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, byte(m.FrameId))
	buf = marshalByte(buf, byte(m.ChildFrameId))

	return buf
}

func (m *Odometry) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	buf = marshalByte(buf, (m.ResetCounter))

	return buf
}

func (m *Odometry) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.X = unmarshalFloat32(buf)
	buf, m.Y = unmarshalFloat32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	for i, _ := range m.Q {
		buf, m.Q[i] = unmarshalFloat32(buf)
	}
	buf, m.Vx = unmarshalFloat32(buf)
	buf, m.Vy = unmarshalFloat32(buf)
	buf, m.Vz = unmarshalFloat32(buf)
	buf, m.Rollspeed = unmarshalFloat32(buf)
	buf, m.Pitchspeed = unmarshalFloat32(buf)
	buf, m.Yawspeed = unmarshalFloat32(buf)
	for i, _ := range m.PoseCovariance {
		buf, m.PoseCovariance[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.VelocityCovariance {
		buf, m.VelocityCovariance[i] = unmarshalFloat32(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.FrameId = MavFrame(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.ChildFrameId = MavFrame(v)
	}

	return buf
}

func (m *Odometry) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	buf, m.ResetCounter = unmarshalByte(buf)

	return buf
}

/* Describe a trajectory using an array of up-to 5 waypoints in the local frame. */
type TrajectoryRepresentationWaypoints struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X-coordinate of waypoint, set to NaN if not being used */
	PosX [5]float32

	/* Y-coordinate of waypoint, set to NaN if not being used */
	PosY [5]float32

	/* Z-coordinate of waypoint, set to NaN if not being used */
	PosZ [5]float32

	/* X-velocity of waypoint, set to NaN if not being used */
	VelX [5]float32

	/* Y-velocity of waypoint, set to NaN if not being used */
	VelY [5]float32

	/* Z-velocity of waypoint, set to NaN if not being used */
	VelZ [5]float32

	/* X-acceleration of waypoint, set to NaN if not being used */
	AccX [5]float32

	/* Y-acceleration of waypoint, set to NaN if not being used */
	AccY [5]float32

	/* Z-acceleration of waypoint, set to NaN if not being used */
	AccZ [5]float32

	/* Yaw angle, set to NaN if not being used */
	PosYaw [5]float32

	/* Yaw rate, set to NaN if not being used */
	VelYaw [5]float32

	/* Number of valid points (up-to 5 waypoints are possible) */
	ValidPoints byte
}

func (m *TrajectoryRepresentationWaypoints) ID() int        { return 332 }
func (m *TrajectoryRepresentationWaypoints) CRCExtra() byte { return 91 }

func (m *TrajectoryRepresentationWaypoints) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.PosX {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PosY {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PosZ {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.VelX {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.VelY {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.VelZ {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.AccX {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.AccY {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.AccZ {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PosYaw {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.VelYaw {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.ValidPoints))

	return buf
}

func (m *TrajectoryRepresentationWaypoints) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *TrajectoryRepresentationWaypoints) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.PosX {
		buf, m.PosX[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PosY {
		buf, m.PosY[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PosZ {
		buf, m.PosZ[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.VelX {
		buf, m.VelX[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.VelY {
		buf, m.VelY[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.VelZ {
		buf, m.VelZ[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.AccX {
		buf, m.AccX[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.AccY {
		buf, m.AccY[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.AccZ {
		buf, m.AccZ[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PosYaw {
		buf, m.PosYaw[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.VelYaw {
		buf, m.VelYaw[i] = unmarshalFloat32(buf)
	}
	buf, m.ValidPoints = unmarshalByte(buf)

	return buf
}

func (m *TrajectoryRepresentationWaypoints) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Describe a trajectory using an array of up-to 5 bezier points in the local frame. */
type TrajectoryRepresentationBezier struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* X-coordinate of starting bezier point, set to NaN if not being used */
	PosX [5]float32

	/* Y-coordinate of starting bezier point, set to NaN if not being used */
	PosY [5]float32

	/* Z-coordinate of starting bezier point, set to NaN if not being used */
	PosZ [5]float32

	/* Bezier time horizon, set to NaN if velocity/acceleration should not be incorporated */
	Delta [5]float32

	/* Yaw, set to NaN for unchanged */
	PosYaw [5]float32

	/* Number of valid points (up-to 5 waypoints are possible) */
	ValidPoints byte
}

func (m *TrajectoryRepresentationBezier) ID() int        { return 333 }
func (m *TrajectoryRepresentationBezier) CRCExtra() byte { return 231 }

func (m *TrajectoryRepresentationBezier) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.PosX {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PosY {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PosZ {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.Delta {
		buf = marshalFloat32(buf, (v))
	}
	for _, v := range m.PosYaw {
		buf = marshalFloat32(buf, (v))
	}
	buf = marshalByte(buf, (m.ValidPoints))

	return buf
}

func (m *TrajectoryRepresentationBezier) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *TrajectoryRepresentationBezier) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.PosX {
		buf, m.PosX[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PosY {
		buf, m.PosY[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PosZ {
		buf, m.PosZ[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.Delta {
		buf, m.Delta[i] = unmarshalFloat32(buf)
	}
	for i, _ := range m.PosYaw {
		buf, m.PosYaw[i] = unmarshalFloat32(buf)
	}
	buf, m.ValidPoints = unmarshalByte(buf)

	return buf
}

func (m *TrajectoryRepresentationBezier) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Report current used cellular network status */
type CellularStatus struct {
	/* Cell ID. If unknown, set to: UINT32_MAX */
	Cid uint32

	/* Status bitmap */
	Status CellularNetworkStatusFlag // uint16

	/* Mobile country code. If unknown, set to: UINT16_MAX */
	Mcc uint16

	/* Mobile network code. If unknown, set to: UINT16_MAX */
	Mnc uint16

	/* Location area code. If unknown, set to: 0 */
	Lac uint16

	/* Cellular network radio type: gsm, cdma, lte... */
	Type CellularNetworkRadioType // byte

	/* Cellular network RSSI/RSRP in dBm, absolute value */
	Quality byte
}

func (m *CellularStatus) ID() int        { return 334 }
func (m *CellularStatus) CRCExtra() byte { return 135 }

func (m *CellularStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint32(buf, (m.Cid))
	buf = marshalUint16(buf, uint16(m.Status))
	buf = marshalUint16(buf, (m.Mcc))
	buf = marshalUint16(buf, (m.Mnc))
	buf = marshalUint16(buf, (m.Lac))
	buf = marshalByte(buf, byte(m.Type))
	buf = marshalByte(buf, (m.Quality))

	return buf
}

func (m *CellularStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *CellularStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.Cid = unmarshalUint32(buf)
	{
		var v uint16
		buf, v = unmarshalUint16(buf)
		m.Status = CellularNetworkStatusFlag(v)
	}
	buf, m.Mcc = unmarshalUint16(buf)
	buf, m.Mnc = unmarshalUint16(buf)
	buf, m.Lac = unmarshalUint16(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Type = CellularNetworkRadioType(v)
	}
	buf, m.Quality = unmarshalByte(buf)

	return buf
}

func (m *CellularStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* The global position resulting from GPS and sensor fusion. */
type UtmGlobalPosition struct {
	/* Time of applicability of position (microseconds since UNIX epoch). */
	Time uint64

	/* Latitude (WGS84) */
	Lat int32

	/* Longitude (WGS84) */
	Lon int32

	/* Altitude (WGS84) */
	Alt int32

	/* Altitude above ground */
	RelativeAlt int32

	/* Next waypoint, latitude (WGS84) */
	NextLat int32

	/* Next waypoint, longitude (WGS84) */
	NextLon int32

	/* Next waypoint, altitude (WGS84) */
	NextAlt int32

	/* Ground X speed (latitude, positive north) */
	Vx int16

	/* Ground Y speed (longitude, positive east) */
	Vy int16

	/* Ground Z speed (altitude, positive down) */
	Vz int16

	/* Horizontal position uncertainty (standard deviation) */
	HAcc uint16

	/* Altitude uncertainty (standard deviation) */
	VAcc uint16

	/* Speed uncertainty (standard deviation) */
	VelAcc uint16

	/* Time until next update. Set to 0 if unknown or in data driven mode. */
	UpdateRate uint16

	/* Unique UAS ID. */
	UasId [18]byte

	/* Flight state */
	FlightState UtmFlightState // byte

	/* Bitwise OR combination of the data available flags. */
	Flags UtmDataAvailFlags // byte

}

func (m *UtmGlobalPosition) ID() int        { return 340 }
func (m *UtmGlobalPosition) CRCExtra() byte { return 99 }

func (m *UtmGlobalPosition) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.Time))
	buf = marshalInt32(buf, (m.Lat))
	buf = marshalInt32(buf, (m.Lon))
	buf = marshalInt32(buf, (m.Alt))
	buf = marshalInt32(buf, (m.RelativeAlt))
	buf = marshalInt32(buf, (m.NextLat))
	buf = marshalInt32(buf, (m.NextLon))
	buf = marshalInt32(buf, (m.NextAlt))
	buf = marshalInt16(buf, (m.Vx))
	buf = marshalInt16(buf, (m.Vy))
	buf = marshalInt16(buf, (m.Vz))
	buf = marshalUint16(buf, (m.HAcc))
	buf = marshalUint16(buf, (m.VAcc))
	buf = marshalUint16(buf, (m.VelAcc))
	buf = marshalUint16(buf, (m.UpdateRate))
	for _, v := range m.UasId {
		buf = marshalByte(buf, (v))
	}
	buf = marshalByte(buf, byte(m.FlightState))
	buf = marshalByte(buf, byte(m.Flags))

	return buf
}

func (m *UtmGlobalPosition) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *UtmGlobalPosition) UnmarshalV1(buf []byte) []byte {
	buf, m.Time = unmarshalUint64(buf)
	buf, m.Lat = unmarshalInt32(buf)
	buf, m.Lon = unmarshalInt32(buf)
	buf, m.Alt = unmarshalInt32(buf)
	buf, m.RelativeAlt = unmarshalInt32(buf)
	buf, m.NextLat = unmarshalInt32(buf)
	buf, m.NextLon = unmarshalInt32(buf)
	buf, m.NextAlt = unmarshalInt32(buf)
	buf, m.Vx = unmarshalInt16(buf)
	buf, m.Vy = unmarshalInt16(buf)
	buf, m.Vz = unmarshalInt16(buf)
	buf, m.HAcc = unmarshalUint16(buf)
	buf, m.VAcc = unmarshalUint16(buf)
	buf, m.VelAcc = unmarshalUint16(buf)
	buf, m.UpdateRate = unmarshalUint16(buf)
	for i, _ := range m.UasId {
		buf, m.UasId[i] = unmarshalByte(buf)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.FlightState = UtmFlightState(v)
	}
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Flags = UtmDataAvailFlags(v)
	}

	return buf
}

func (m *UtmGlobalPosition) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Large debug/prototyping array. The message uses the maximum available payload for data. The array_id and name fields are used to discriminate between messages in code and in user interfaces (respectively). Do not use in production code. */
type DebugFloatArray struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Unique ID used to discriminate between arrays */
	ArrayId uint16

	/* Name, for human-friendly display in a Ground Control Station */
	Name [10]byte

	/* data */
	Data [58]float32 /*EXTENSION*/

}

func (m *DebugFloatArray) ID() int        { return 350 }
func (m *DebugFloatArray) CRCExtra() byte { return 232 }

func (m *DebugFloatArray) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalUint16(buf, (m.ArrayId))
	for _, v := range m.Name {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *DebugFloatArray) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)
	for _, v := range m.Data {
		buf = marshalFloat32(buf, (v))
	}

	return buf
}

func (m *DebugFloatArray) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.ArrayId = unmarshalUint16(buf)
	for i, _ := range m.Name {
		buf, m.Name[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *DebugFloatArray) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)
	for i, _ := range m.Data {
		buf, m.Data[i] = unmarshalFloat32(buf)
	}

	return buf
}

/* Vehicle status report that is sent out while orbit execution is in progress (see MAV_CMD_DO_ORBIT). */
type OrbitExecutionStatus struct {
	/* Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number. */
	TimeUsec uint64

	/* Radius of the orbit circle. Positive values orbit clockwise, negative values orbit counter-clockwise. */
	Radius float32

	/* X coordinate of center point. Coordinate system depends on frame field: local = x position in meters * 1e4, global = latitude in degrees * 1e7. */
	X int32

	/* Y coordinate of center point.  Coordinate system depends on frame field: local = x position in meters * 1e4, global = latitude in degrees * 1e7. */
	Y int32

	/* Altitude of center point. Coordinate system depends on frame field. */
	Z float32

	/* The coordinate system of the fields: x, y, z. */
	Frame MavFrame // byte

}

func (m *OrbitExecutionStatus) ID() int        { return 360 }
func (m *OrbitExecutionStatus) CRCExtra() byte { return 11 }

func (m *OrbitExecutionStatus) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	buf = marshalFloat32(buf, (m.Radius))
	buf = marshalInt32(buf, (m.X))
	buf = marshalInt32(buf, (m.Y))
	buf = marshalFloat32(buf, (m.Z))
	buf = marshalByte(buf, byte(m.Frame))

	return buf
}

func (m *OrbitExecutionStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *OrbitExecutionStatus) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	buf, m.Radius = unmarshalFloat32(buf)
	buf, m.X = unmarshalInt32(buf)
	buf, m.Y = unmarshalInt32(buf)
	buf, m.Z = unmarshalFloat32(buf)
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Frame = MavFrame(v)
	}

	return buf
}

func (m *OrbitExecutionStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Status text message (use only for important status and error messages). The full message payload can be used for status text, but we recommend that updates be kept concise. Note: The message is intended as a less restrictive replacement for STATUSTEXT. */
type StatustextLong struct {
	/* Severity of status. Relies on the definitions within RFC-5424. */
	Severity MavSeverity // byte

	/* Status text message, without null termination character. */
	Text [254]byte
}

func (m *StatustextLong) ID() int        { return 365 }
func (m *StatustextLong) CRCExtra() byte { return 36 }

func (m *StatustextLong) MarshalV1(buf []byte) []byte {
	buf = marshalByte(buf, byte(m.Severity))
	for _, v := range m.Text {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *StatustextLong) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *StatustextLong) UnmarshalV1(buf []byte) []byte {
	{
		var v byte
		buf, v = unmarshalByte(buf)
		m.Severity = MavSeverity(v)
	}
	for i, _ := range m.Text {
		buf, m.Text[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *StatustextLong) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Smart Battery information (static/infrequent update). Use for updates from: smart battery to flight stack, flight stack to GCS. Use instead of BATTERY_STATUS for smart batteries. */
type SmartBatteryInfo struct {
	/* Capacity when full according to manufacturer, -1: field not provided. */
	CapacityFullSpecification int32

	/* Capacity when full (accounting for battery degradation), -1: field not provided. */
	CapacityFull int32

	/* Serial number. -1: field not provided. */
	SerialNumber int32

	/* Charge/discharge cycle count. -1: field not provided. */
	CycleCount uint16

	/* Battery weight. 0: field not provided. */
	Weight uint16

	/* Minimum per-cell voltage when discharging. If not supplied set to UINT16_MAX value. */
	DischargeMinimumVoltage uint16

	/* Minimum per-cell voltage when charging. If not supplied set to UINT16_MAX value. */
	ChargingMinimumVoltage uint16

	/* Minimum per-cell voltage when resting. If not supplied set to UINT16_MAX value. */
	RestingMinimumVoltage uint16

	/* Battery ID */
	Id byte

	/* Static device name. Encode as manufacturer and product names separated using an underscore. */
	DeviceName [50]byte
}

func (m *SmartBatteryInfo) ID() int        { return 370 }
func (m *SmartBatteryInfo) CRCExtra() byte { return 98 }

func (m *SmartBatteryInfo) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.CapacityFullSpecification))
	buf = marshalInt32(buf, (m.CapacityFull))
	buf = marshalInt32(buf, (m.SerialNumber))
	buf = marshalUint16(buf, (m.CycleCount))
	buf = marshalUint16(buf, (m.Weight))
	buf = marshalUint16(buf, (m.DischargeMinimumVoltage))
	buf = marshalUint16(buf, (m.ChargingMinimumVoltage))
	buf = marshalUint16(buf, (m.RestingMinimumVoltage))
	buf = marshalByte(buf, (m.Id))
	for _, v := range m.DeviceName {
		buf = marshalByte(buf, (v))
	}

	return buf
}

func (m *SmartBatteryInfo) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SmartBatteryInfo) UnmarshalV1(buf []byte) []byte {
	buf, m.CapacityFullSpecification = unmarshalInt32(buf)
	buf, m.CapacityFull = unmarshalInt32(buf)
	buf, m.SerialNumber = unmarshalInt32(buf)
	buf, m.CycleCount = unmarshalUint16(buf)
	buf, m.Weight = unmarshalUint16(buf)
	buf, m.DischargeMinimumVoltage = unmarshalUint16(buf)
	buf, m.ChargingMinimumVoltage = unmarshalUint16(buf)
	buf, m.RestingMinimumVoltage = unmarshalUint16(buf)
	buf, m.Id = unmarshalByte(buf)
	for i, _ := range m.DeviceName {
		buf, m.DeviceName[i] = unmarshalByte(buf)
	}

	return buf
}

func (m *SmartBatteryInfo) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Smart Battery information (dynamic). Use for updates from: smart battery to flight stack, flight stack to GCS. Use instead of BATTERY_STATUS for smart batteries. */
type SmartBatteryStatus struct {
	/* Fault/health indications. */
	FaultBitmask MavSmartBatteryFault // int32

	/* Estimated remaining battery time. -1: field not provided. */
	TimeRemaining int32

	/* Battery ID */
	Id uint16

	/* Remaining battery energy. Values: [0-100], -1: field not provided. */
	CapacityRemaining int16

	/* Battery current (through all cells/loads). Positive if discharging, negative if charging. UINT16_MAX: field not provided. */
	Current int16

	/* Battery temperature. -1: field not provided. */
	Temperature int16

	/* The cell number of the first index in the 'voltages' array field. Using this field allows you to specify cell voltages for batteries with more than 16 cells. */
	CellOffset uint16

	/* Individual cell voltages. Batteries with more 16 cells can use the cell_offset field to specify the cell offset for the array specified in the current message . Index values above the valid cell count for this battery should have the UINT16_MAX value. */
	Voltages [16]uint16
}

func (m *SmartBatteryStatus) ID() int        { return 371 }
func (m *SmartBatteryStatus) CRCExtra() byte { return 161 }

func (m *SmartBatteryStatus) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, int32(m.FaultBitmask))
	buf = marshalInt32(buf, (m.TimeRemaining))
	buf = marshalUint16(buf, (m.Id))
	buf = marshalInt16(buf, (m.CapacityRemaining))
	buf = marshalInt16(buf, (m.Current))
	buf = marshalInt16(buf, (m.Temperature))
	buf = marshalUint16(buf, (m.CellOffset))
	for _, v := range m.Voltages {
		buf = marshalUint16(buf, (v))
	}

	return buf
}

func (m *SmartBatteryStatus) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *SmartBatteryStatus) UnmarshalV1(buf []byte) []byte {
	{
		var v int32
		buf, v = unmarshalInt32(buf)
		m.FaultBitmask = MavSmartBatteryFault(v)
	}
	buf, m.TimeRemaining = unmarshalInt32(buf)
	buf, m.Id = unmarshalUint16(buf)
	buf, m.CapacityRemaining = unmarshalInt16(buf)
	buf, m.Current = unmarshalInt16(buf)
	buf, m.Temperature = unmarshalInt16(buf)
	buf, m.CellOffset = unmarshalUint16(buf)
	for i, _ := range m.Voltages {
		buf, m.Voltages[i] = unmarshalUint16(buf)
	}

	return buf
}

func (m *SmartBatteryStatus) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Time/duration estimates for various events and actions given the current vehicle state and position. */
type TimeEstimateToTarget struct {
	/* Estimated time to complete the vehicle's configured "safe return" action from its current position (e.g. RTL, Smart RTL, etc.). -1 indicates that the vehicle is landed, or that no time estimate available. */
	SafeReturn int32

	/* Estimated time for vehicle to complete the LAND action from its current position. -1 indicates that the vehicle is landed, or that no time estimate available. */
	Land int32

	/* Estimated time for reaching/completing the currently active mission item. -1 means no time estimate available. */
	MissionNextItem int32

	/* Estimated time for completing the current mission. -1 means no mission active and/or no estimate available. */
	MissionEnd int32

	/* Estimated time for completing the current commanded action (i.e. Go To, Takeoff, Land, etc.). -1 means no action active and/or no estimate available. */
	CommandedAction int32
}

func (m *TimeEstimateToTarget) ID() int        { return 380 }
func (m *TimeEstimateToTarget) CRCExtra() byte { return 232 }

func (m *TimeEstimateToTarget) MarshalV1(buf []byte) []byte {
	buf = marshalInt32(buf, (m.SafeReturn))
	buf = marshalInt32(buf, (m.Land))
	buf = marshalInt32(buf, (m.MissionNextItem))
	buf = marshalInt32(buf, (m.MissionEnd))
	buf = marshalInt32(buf, (m.CommandedAction))

	return buf
}

func (m *TimeEstimateToTarget) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *TimeEstimateToTarget) UnmarshalV1(buf []byte) []byte {
	buf, m.SafeReturn = unmarshalInt32(buf)
	buf, m.Land = unmarshalInt32(buf)
	buf, m.MissionNextItem = unmarshalInt32(buf)
	buf, m.MissionEnd = unmarshalInt32(buf)
	buf, m.CommandedAction = unmarshalInt32(buf)

	return buf
}

func (m *TimeEstimateToTarget) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

/* Cumulative distance traveled for each reported wheel. */
type WheelDistance struct {
	/* Timestamp (synced to UNIX time or since system boot). */
	TimeUsec uint64

	/* Distance reported by individual wheel encoders. Forward rotations increase values, reverse rotations decrease them. Not all wheels will necessarily have wheel encoders; the mapping of encoders to wheel positions must be agreed/understood by the endpoints. */
	Distance [16]float64

	/* Number of wheels reported. */
	Count byte
}

func (m *WheelDistance) ID() int        { return 9000 }
func (m *WheelDistance) CRCExtra() byte { return 113 }

func (m *WheelDistance) MarshalV1(buf []byte) []byte {
	buf = marshalUint64(buf, (m.TimeUsec))
	for _, v := range m.Distance {
		buf = marshalFloat64(buf, (v))
	}
	buf = marshalByte(buf, (m.Count))

	return buf
}

func (m *WheelDistance) MarshalV2(buf []byte) []byte {
	buf = m.MarshalV1(buf)

	return buf
}

func (m *WheelDistance) UnmarshalV1(buf []byte) []byte {
	buf, m.TimeUsec = unmarshalUint64(buf)
	for i, _ := range m.Distance {
		buf, m.Distance[i] = unmarshalFloat64(buf)
	}
	buf, m.Count = unmarshalByte(buf)

	return buf
}

func (m *WheelDistance) UnmarshalV2(buf []byte) []byte {
	buf = m.UnmarshalV1(buf)

	return buf
}

// These will be inlined.
func marshalByte(b []byte, v byte) []byte     { return append(b, v) }
func marshalInt8(b []byte, v int8) []byte     { return append(b, byte(v)) }
func marshalInt16(b []byte, v int16) []byte   { return append(b, byte(v), byte(v>>8)) }
func marshalUint16(b []byte, v uint16) []byte { return append(b, byte(v), byte(v>>8)) }
func marshalInt32(b []byte, v int32) []byte {
	return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24))
}
func marshalUint32(b []byte, v uint32) []byte {
	return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24))
}
func marshalInt64(b []byte, v int64) []byte {
	return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24), byte(v>>32), byte(v>>40), byte(v>>48), byte(v>>56))
}
func marshalUint64(b []byte, v uint64) []byte {
	return append(b, byte(v), byte(v>>8), byte(v>>16), byte(v>>24), byte(v>>32), byte(v>>40), byte(v>>48), byte(v>>56))
}
func marshalFloat32(b []byte, v float32) []byte { return marshalUint32(b, math.Float32bits(v)) }
func marshalFloat64(b []byte, v float64) []byte { return marshalUint64(b, math.Float64bits(v)) }

func unmarshalByte(b []byte) ([]byte, byte)     { return b[1:], b[0] }
func unmarshalInt8(b []byte) ([]byte, int8)     { return b[1:], int8(b[0]) }
func unmarshalInt16(b []byte) ([]byte, int16)   { return b[2:], int16(b[0]) | int16(b[1])<<8 }
func unmarshalUint16(b []byte) ([]byte, uint16) { return b[2:], uint16(b[0]) | uint16(b[1])<<8 }
func unmarshalInt32(b []byte) ([]byte, int32) {
	return b[4:], int32(b[0]) | int32(b[1])<<8 | int32(b[2])<<16 | int32(b[3])<<24
}
func unmarshalUint32(b []byte) ([]byte, uint32) {
	return b[4:], uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
}
func unmarshalInt64(b []byte) ([]byte, int64) {
	return b[8:], int64(b[0]) | int64(b[1])<<8 | int64(b[2])<<16 | int64(b[3])<<24 | int64(b[4])<<32 | int64(b[5])<<40 | int64(b[6])<<48 | int64(b[7])<<56
}
func unmarshalUint64(b []byte) ([]byte, uint64) {
	return b[8:], uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
}
func unmarshalFloat32(b []byte) ([]byte, float32) {
	b, v := unmarshalUint32(b)
	return b, math.Float32frombits(v)
}
func unmarshalFloat64(b []byte) ([]byte, float64) {
	b, v := unmarshalUint64(b)
	return b, math.Float64frombits(v)
}
